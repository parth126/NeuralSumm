{
    "abstract_sentences": {
        "1": "We consider the problem of translating high-level textual descriptions to formal representations in technical documentation as part of an effort to model the meaning of such documentation.", 
        "2": "We focus specifically on the problem of learning translational correspondences between text descriptions and grounded representations in the target documentation, such as formal representation of functions or code templates.", 
        "3": "Our approach exploits the parallel nature of such documentation, or the tight coupling between high-level text and the low-level representations we aim to learn.", 
        "4": "Data is collected by mining technical documents for such parallel text-representation pairs, which we use to train a simple semantic parsing model.", 
        "5": "We report new baseline results on sixteen novel datasets, including the standard library documentation for nine popular programming languages across seven natural languages, and a small collection of Unix utility manuals."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1612\u20131622 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1148  1 Introduction  Technical documentation in the computer domain, such as source code documentation and other howto manuals, provide high-level descriptions of how lower-level computer programs and utilities work.", 
        "2": "Often these descriptions are coupled with formal representations of these lower-level features, expressed in the target programming languages.", 
        "3": "For example, Figure 1.1 shows the source code documentation (in red/bold) for the max function in the Java programming language paired with the representation of this function in the underlying Java language (in black).", 
        "4": "This formal representation captures the name of the function, the return\nvalue, the types of arguments the function takes, among other details related to the function\u2019s place and visibility in the overall source code collection or API.", 
        "5": "Given the high-level nature of the textual annotations, modeling the meaning of any given description is not an easy task, as it involves much more information than what is directly provided in the associated documentation.", 
        "6": "For example, capturing the meaning of the description the greater of might require having a background theory about quantity/numbers and relations between different quantities.", 
        "7": "A first step towards capturing the meaning, however, is learning to translate this description to symbols in the target representation, in this case to the max symbol.", 
        "8": "By doing this translation to a formal language, modeling and learning the subsequent semantics becomes easier since we are eliminating the ambiguity of ordinary lan-\n1612\nguage.", 
        "9": "Similarly, we would want to first translate the description two long values, which specifies the number and type of argument taken by this function, to the sequence long a,long b.", 
        "10": "By focusing on translation, we can create new datasets by mining these types of source code collections for sets of parallel text-representation pairs.", 
        "11": "Given the wide variety of available programming languages, many such datasets can be constructed, each offering new challenges related to differences in the formal representations used by different programming languages.", 
        "12": "Figure 1.2 shows example documentation for the Clojure programming language, which is part of the Lisp family of languages.", 
        "13": "In this case, the description Returns random probability of should be translated to the function name random-sample since it describes what the overall function does.", 
        "14": "Similarly, the argument descriptions from coll and of prob should translate to coll and prob.", 
        "15": "Given the large community of programmers around the world, many source code collections are available in languages other than English.", 
        "16": "Figure 1.3 shows an example entry from the French version of the PHP standard library, which was translated by volunteer developers.", 
        "17": "Having multilingual data raises new challenges, and broadens the scope of investigations into this type of semantic translation.", 
        "18": "Other types of technical documentation, such as utility manuals, exhibit similar features.", 
        "19": "Figure 2 shows an example manual in the domain of Unix utilities.", 
        "20": "The textual description in red/bold describes an example use of the dappprof utility paired with formal representations in the form of executable code.", 
        "21": "As with the previous exam-\nples, such formal representations do not capture the full meaning of the different descriptions, but serve as a convenient operationalization, or translational semantics, of the meaning in Unix.", 
        "22": "Print elapsed time, for example, roughly describes what the dappprof utility does, whereas PID 1871 describes the second half of the code sequence.", 
        "23": "In both types of technical documentation, information is not limited to raw pairs of descriptions and representations, but can include other information and clues that are useful for learning.", 
        "24": "Java function annotations include textual descriptions of individual arguments and return values (shown in green).", 
        "25": "Taxonomic information and pointers to related functions or utilities are also annotated (e.g., the @see section in Figure 1, or SEE ALSO section in Figure 2).", 
        "26": "Structural information about code sequences, and the types of abstract arguments these sequences take, are described in the SYNOPSIS section of the Unix manual.", 
        "27": "This last piece of information allows us to generate abstract code templates, and generalize individual arguments.", 
        "28": "For example, the raw argument 1871 in the sequence dappprof -p 1871 can be typed as a PID instance, and an argument of the -p flag.", 
        "29": "Given this type of data, a natural experiment is to see whether we can build programs that translate high-level textual descriptions to correct formal representations.", 
        "30": "We aim to learn these translations using raw text-meaning pairs as the sole supervision.", 
        "31": "Our focus is on learning function translations or representations within nine programming language APIs, each varying in size, representation style, and source natural language.", 
        "32": "To our knowledge, our work is the first to look at translating source code descriptions to formal representations using such a wide variety of programming and natural languages.", 
        "33": "In total, we introduce fourteen new datasets in the source code domain that include seven natural languages, and report new results for an existing dataset.", 
        "34": "As well, we look at learning simple code templates using a small collection of English Unix manuals.", 
        "35": "The main goal of this paper is to establish strong baselines results on these resources, which we hope can be used for benchmarking and developing new semantic parsing methods.", 
        "36": "We achieved initial baselines using the language modeling and translation approach of Deng and Chrupa\u0142a (2014).", 
        "37": "We also show that modest improvements can be achieved by using a more conventional\ndiscriminative model (Zettlemoyer and Collins, 2009) that, in part, exploits document-level features from the technical documentation sets.", 
        "38": "2 Related Work  Our work is situated within research on semantic parsing, which focuses on the problem of generating formal meaning representations from text for natural language understanding applications.", 
        "39": "Recent interest in this topic has centered around learning meaning representation from example text-meaning pairs, for applications such as automated question-answering (Berant et al., 2013), robot control (Matuszek et al., 2012) and text generation (Wong and Mooney, 2007a).", 
        "40": "While generating representations for natural language understanding is a complex task, most studies focus on the translation or generation problem independently of other semantic or knowledge representation issues.", 
        "41": "Earlier work looks at supervised learning of logical representations using example text-meaning pairs using tools from statistical machine translation (Wong andMooney, 2006) and parsing (Zettlemoyer and Collins, 2009).", 
        "42": "These methods are meant to be applicable to a wide range of translation problems and representation types, which make new parallel datasets or resources useful for furthering the research.", 
        "43": "In general, however, such datasets are hard to construct since building them requires considerable domain knowledge and knowledge of logic.", 
        "44": "Alternatively, we construct parallel datasets automatically from technical documentation, which obviates the need for annotation.", 
        "45": "While the formal representations are not actual logical forms, they still provide a good test case for testing how well semantic parsers learn translations to representations.", 
        "46": "To date, most benchmark datasets are limited to small controlled domains, such as geography and navigation.", 
        "47": "While attempts have been made to do open-domain semantic parsing using larger, more complex datasets (Berant et al., 2013; Pasupat and Liang, 2015), such resources are still scarce.", 
        "48": "In Figure 3, we compare the details of one widely used dataset, Geoquery (Zelle andMooney, 1996), to our new datasets.", 
        "49": "Our new resources are on average much larger than geoquery in terms of the number of example pairs, and the size of the different language vocabularies.", 
        "50": "Most existing datasets are also primarily English-based, while we focus\non learning in a multilingual setting using several new moderately sized datasets.", 
        "51": "Within semantic parsing, there has also been work on situated or grounded learning, that involves learning in domains with weak supervision and indirect cues (Liang, 2016; Richardson and Kuhn, 2016).", 
        "52": "This has sometimes involved learning from automatically generated parallel data and representations (Chen and Mooney, 2008) of the type we consider in this paper.", 
        "53": "Here one can find work in technical domains, including learning to generate regular expressions (Manshadi et al., 2013; Kushman and Barzilay, 2013) and other types of source code (Quirk et al., 2015), which ultimately aim to solve the problem of natural language programming.", 
        "54": "We view our work as one small step in this general direction.", 
        "55": "Our work is also related to software components retrieval and builds on the approach of Deng and Chrupa\u0142a (2014).", 
        "56": "Robustly learning the translation from language to code representations can help to facilitate natural language querying of API collections (Lv et al., 2015).", 
        "57": "As part of this effort, recent work in machine learning has focused on the similar problem of learning code representations using resources such as StackOverflow and Github.", 
        "58": "These studies primarily focus on learning longer programs (Allamanis et al., 2015) as opposed to function representations, or focus narrowly on a single programming language such as Java (Gu et al., 2016) or on related tasks such as text generation (Iyer et al., 2016; Oda et al., 2015).", 
        "59": "To our knowledge, none of this work has been applied to languages other than English or such a wide variety of programming languages.", 
        "60": "3 Mapping Text to Representations  In this section, we formulate the basic problem of translating to representations in technical documentation.", 
        "61": "3.1 Problem Description  We use the term technical documentation to refer to two types of resources: textual descriptions inside of source code collections, and computer utility manuals.", 
        "62": "In this paper, the first type includes high-level descriptions of functions in standard library source code documentation.", 
        "63": "The second type includes a collection of Unix manuals, also known as man pages.", 
        "64": "Both types include pairs of text and code representations.", 
        "65": "We will refer to the target representations in these resources as API components, or components.", 
        "66": "In source code, components are formal representations of functions, or function signatures (Deng and Chrupa\u0142a, 2014).", 
        "67": "The form of a function signature varies depending on the resource, but in general gives a specification of how a function is named and structured.", 
        "68": "The example function signatures in Figure 3 all specify a function name, a list of arguments, and other optional information such as a return value and a namespace.", 
        "69": "Components in utility manuals are short executable code sequences intended to show an example use of a utility.", 
        "70": "We assume typed code sequences following Richardson and Kuhn (2014), where the constituent parts of the sequences are abstracted by type.", 
        "71": "Given a set of example text-component pairs, D = {(xi, zi)}ni=1, the goal is to learn how to generate correct, well-formed components z \u2208 C for each input x.", 
        "72": "Viewed as a semantic parsing problem, this treats the target components as a kind of formal meaning representation, analogous to a logical form.", 
        "73": "In our experiments, we assume that the complete set of output components are known.", 
        "74": "In the API documentation sets, this is because each standard library contains a finite number of func-\ntion representations, roughly corresponding to the number of pairs as shown in Figure 3.", 
        "75": "For a given input, therefore, the goal is to find the best candidate function translation within the space of the total API components C (Deng and Chrupa\u0142a, 2014).", 
        "76": "Given these constraints, our setup closely resembles that of Kushman et al.", 
        "77": "(2014), who learn to parse algebra word problems using a small set of equation templates.", 
        "78": "Their approach is inspired by template-based information extraction, where templates are recognized and instantiated by slotfilling.", 
        "79": "Our function signatures and code templates have a similar slot-like structure, consisting of slots such as return value, arguments, function name and namespace.", 
        "80": "3.2 Language Modeling Baselines  Existing approaches to semantic parsing formalize the mapping from language to logic using a variety of formalisms including CFGs (Bo\u0308rschinger et al., 2011), CCGs (Kwiatkowski et al., 2010), synchronous CFGs (Wong and Mooney, 2007b).", 
        "81": "Deciding to use one formalism over another is often motivated by the complexities of the target representations being learned.", 
        "82": "For example, recent interest in learning graph-based representations such as those in the AMR bank (Banarescu et al., 2013)\nrequires parsing models that can generate complex graph shaped derivations such as CCGs (Artzi et al., 2015) or HRGs (Peng et al., 2015).", 
        "83": "Given the simplicity of our API representations, we opt for a simple semantic parsing model that exploits the finiteness of our target representations.", 
        "84": "Following ((Deng and Chrupa\u0142a, 2014); henceforth DC), we treat the problem of component translation as a language modeling problem (Song and Croft, 1999).", 
        "85": "For a given query sequence or text x = wi, .., wI and component sequence z = uj , .., uJ , the probability of the component given the query is defined as follows using Bayes\u2019 theorem: p(z|x) \u221d p(x|z)p(z).", 
        "86": "By assuming a uniform prior over the probability of each component p(z), the problem reduces to computing p(x|z), which is where language modeling is used.", 
        "87": "Given each word wi in the query, a unigram model is defined as p(x|z) =\u220fI\ni=1 p(wi|z).", 
        "88": "Using this formulation, we can then define different models to estimate p(w|z).", 
        "89": "Term Matching As a baseline for p(w|z), DC define a term matching approach that exploits the fact that many queries in our English datasets share vocabulary with target component vocabulary.", 
        "90": "A smoothed version of this baseline is defined below, where f(w|z) is the frequency of matching terms in the target signature, f(w|C) is frequency of the term word in the overall documentation collection, and \u03bb is a smoothing parameter (for Jelinek-Mercer smoothing):\np(x|z) = \u220f\nw\u2208x (1\u2212 \u03bb)f(w|z) + \u03bbf(w|C)\nTranslation Model In order to account for the co-occurrence between non-matching words and component terms, DC employ a word-based translation model, which models the relation between natural language words wj and individual component terms uj .", 
        "91": "In this paper, we limit ourselves to sequence-based word alignment models (Och and Ney, 2003), which factor in the following manner:\np(x|z) = I\u220f\ni=1\nJ\u2211\nj=0\npt(wi|uj)pd(l(j)|i, I, J)\nHere each pt(wi|uj) defines an (unsmoothed) multinomial distribution over a given component term uj for all words wj .", 
        "92": "The function pd is a distortion parameter, and defines a dependency between the alignment positions and the lengths of\nAlgorithm 1 Rank Decoder Input: Query x, Components C of sizem, rank k, modelA,\nsort function K-BEST Output: Top k components ranked by A model score p 1: procedure RANKCOMPONENTS(x, C, k,A) 2: SCORES \u2190 [ ] \u25b7 Initialize score list 3: for each component c \u2208 C do 4: p\u2190 ALIGNA(x, c) \u25b7 Score using A 5: SCORES += (c, p) \u25b7 Add to list 6: return K-Best(SCORES,k) \u25b7 k best components\nboth input strings.", 
        "93": "This function, and the definition of l(j), assumes different forms according to the particular alignment model being used.", 
        "94": "We consider three different types of alignment models each defined in the following way:\npd(l(j)|...) =    1 J+1 (1) a(j|i, I, J) (2) a(t(j)|i, I, tlen(J)) (3)\nModels (1-2) are the classic IBM word-alignment models of Brown et al.", 
        "95": "(1993).", 
        "96": "IBM Model 1, for example, assumes a uniform distribution over all positions, and is the main model investigated in DC.", 
        "97": "For comparison, we also experiment with IBM Model 2, where each l(j) refers to the string position of j in the component input, and a(..) defines a multinomial distribution such that\u2211J\nj=0 a(j|i, I, J) = 1.0.", 
        "98": "We also define a new tree based alignment model (3) that takes into account the syntax associated with the function representations.", 
        "99": "Each l(j) is the relative tree position of the alignment point, shown as t(j), and tlen(J) is the length of the tree associated with z.", 
        "100": "This approach assumes a tree representation for each z.", 
        "101": "We generated these trees heuristically by preserving the information that is lost when components are converted to a linear sequence representation.", 
        "102": "An example structure for PHP is shown in Figure 4, where the red solid line indicates the types of potential errors avoided by this model.", 
        "103": "Learning is done by applying the standard EM training procedure of Brown et al.", 
        "104": "(1993).", 
        "105": "3.3 Ranking and Decoding  Algorithm 1 shows how to rank API components.", 
        "106": "For a text input x, we iterate through all known API components C and assign a score using a model A.", 
        "107": "We then rank the components by their scores using a K-BEST function.", 
        "108": "This method serves as a type of word-based decoding algorithm\nwhich is simplified by the finite nature of the target language.", 
        "109": "The complexity of the scoring procedure, lines 3-5, is linear over the number components m in C. In practice, we implement the K-BEST sorting function on line 6 as a binary insertion sort on line 5, resulting in an overall complexity of O(m log m).", 
        "110": "While iterating over m API components might not be feasible given more complicated formal languages with recursion, a more clever decoding algorithm could be applied, e.g., one based on the lattice decoding approach of (Dyer et al., 2008).", 
        "111": "Since we are interested in providing initial baseline results, we leave this for future work.", 
        "112": "4 Discriminative Approach  In this section, we introduce a newmodel that aims to improve on the previous baseline methods.", 
        "113": "While the previous models are restricted to word-level information, we extend this approach by using a discriminative reranking model that captures phrase information to see if this leads to an improvement.", 
        "114": "This model can also capture document-level information from the APIs, such as the additional textual descriptions of parameters, see also declarations or classes of related functions and syntax information.", 
        "115": "4.1 Modeling  Like in most semantic parsing approaches (Zettlemoyer and Collins, 2009; Liang et al., 2011), our model is defined as a conditional log-linear\nmodel over components z \u2208 C with parameters \u03b8 \u2208 Rb, and a set of feature functions \u03d5(x, z): p( z|x; \u03b8) \u221d e\u03b8\u00b7\u03d5(x,z).", 
        "116": "Formally, our training objective is to maximize the conditional log-likehood of the correct component output z for each input x: O(\u03b8) =\u2211n\ni=1 log p (zi |xi; \u03b8).", 
        "117": "4.2 Features  Our model uses word-level features, such as word match, word pairs, as well as information from the underlying aligner model such as Viterbi alignment information and model score.", 
        "118": "Two additional categories of non-word features are described below.", 
        "119": "An illustration of the feature extraction procedure is shown in Figure 5 1.", 
        "120": "Phrases Features We extract phrase features (e.g., (hyper.", 
        "121": "cosine,cosh) in Figure 5) from example text component pairs by training symmetric word aligners and applying standard word-level heuristics (Koehn et al., 2003).", 
        "122": "Additional features, such as phrase match/overlap, tree positions of phrases, are defined over the extracted phrases.", 
        "123": "We also extract hierarchical phrases (Chiang, 2007) using a variant of the SAMT method of Zollmann and Venugopal (2006) and the component syntax trees.", 
        "124": "Example rules are shown in Figure 4, where gaps (i.e., symbols in square brackets) are filled with smaller phrase-tree alignments.", 
        "125": "Document Level Features Document features are of two categories.", 
        "126": "The first includes additional textual descriptions of parameters, return values, and modules.", 
        "127": "One class of features is whether certain words under consideration appear in the @param and @return descriptions of the target components.", 
        "128": "For example, the arg token in\n1A more complete description of features is included as supplementary material, along with all source code.", 
        "129": "Algorithm 2 Online Rank Learner Input: DatasetD, components C, iterations T , rank k, learn-\ning rate \u03b1, model A, ranker function RANK Output: Weight vector \u03b8 1: procedure LEARNRERANKER(D, C, T, k, \u03b1,A,RANK) 2: \u03b8 \u2190 0 \u25b7 Initialize 3: for t \u2208 1..T do 4: for pairs (xi, zi) \u2208 D do 5: S = RANK(xi, C, k,A) \u25b7 Scored candidates 6: \u2206 = \u03d5(xi, zi)\u2212 Es\u2208S\u223cp(s|xi;\u03b8)[\u03d5(xi, s)] 7: \u03b8 = \u03b8 + \u03b1\u2206 \u25b7 Update online 8: return \u03b8\nFigure 5 appears in the textual description of the $arg parameter elsewhere in the documentation string.", 
        "130": "Other features relate to general information about abstract symbol categories, as specified in see-also assertions, or hyper-link pointers.", 
        "131": "By exploiting this information, we extract general classes of functions, for example the set of hyperbolic function (e.g., sinh, cosh, shown as c4 in Figure 5), and associate these classes with words and phrases (e.g., hyperbolic and hyperbolic cosine).", 
        "132": "4.3 Learning  To optimize our objective, we use Algorithm 2.", 
        "133": "We estimate the model parameters \u03b8 using a Kbest approximation of the standard stochastic gradient updates (lines 6-7), and a ranker function RANK.", 
        "134": "We note that while we use the ranker described in Algorithm 1, any suitable ranker or decoding method could be used here.", 
        "135": "5 Experimental Setup    5.1 Datasets  Source code documentation Our source code documentation collection consists of the standard library for nine programming languages, which are listed in Figure 3.", 
        "136": "We also use the translated version of the PHP collection for six additional languages, the details of which are shown in Figure 6.", 
        "137": "The Java dataset was first used in DC, while we extracted all other datasets for this work.", 
        "138": "The size of the different datasets are detailed in both figures.", 
        "139": "The number of pairs is the number of single sentences paired with function representations, which constitutes the core part of these datasets.", 
        "140": "The number of descriptions is the number of additional textual descriptions provided in the overall document, such as descriptions of parameters or return values.", 
        "141": "We also quantify the different datasets in terms of unique symbols in the target representations, shown as Symbols.", 
        "142": "All function representations and code sequences are linearized, and in some cases further tokenized, for example, by converting out of camel case or removing underscores.", 
        "143": "Man pages The collection of man pages is from Richardson and Kuhn (2014) and includes 921 text-code pairs that span 330 Unix utilities and man pages.", 
        "144": "Using information from the synopsis and parameter declarations, the target code representations are abstracted by type.", 
        "145": "The extra descriptions are extracted from parameter descriptions, as shown in the DESCRIPTION section in Figure 1, as well as from the NAME sections of each manual.", 
        "146": "5.2 Evaluation  For evaluation, we split our datasets into separate training, validation and test sets.", 
        "147": "For Java, we reserve 60% of the data for training and the remaining 40% for validation (20%) and testing (20%).", 
        "148": "For all other datasets, we use a 70%-30% split.", 
        "149": "From a retrieval perspective, these left out descriptions are meant to mimic unseen queries to our model.", 
        "150": "After training our models, we evaluate on these held out sets by ranking all known components in each resource using Algorithm 1.", 
        "151": "A predicted component is counted as correct if it matches exactly a gold component.", 
        "152": "Following DC, we report the accuracy of predicting the correct representation at the first position in the ranked list (Accuracy @1) and within the top 10 positions (Accuracy @10).", 
        "153": "We also report the mean reciprocal rank MRR, or the multiplicative inverse of the rank of the correct answer.", 
        "154": "Baselines For comparison, we trained a bag-ofwords classifier (the BoWModel in Table 1).", 
        "155": "This model uses the occurrence of word-component symbol pairs as binary features, and aims to see if word co-occurrence alone is sufficient to for ranking representations.", 
        "156": "Since our discriminative models use more data than the baseline models, which therefore make the results not directly comparable, we train a more comparable translation model, shown as M1 Descr.", 
        "157": "in Table 1, by adding the additional textual data (i.e.", 
        "158": "parameter and return or module descriptions) to the models\u2019 parallel training data.", 
        "159": "6 Results and Discussion  Test results are shown in Table 1.", 
        "160": "Among the baseline models, IBM Model 1 outperforms virtually all other models and is in general a strong baseline.", 
        "161": "Of particular note is the poor performance of the higher-order translation models based on Model 2 and the Tree Model.", 
        "162": "While Model 2 is known to outperform Model 1 on more conventional translation tasks (Och and Ney, 2003), it appears that such improvements are not reflected in this type of semantic translation context.", 
        "163": "The bag-of-words (BoW) and Term Match baselines are outperformed by all other models.", 
        "164": "This shows that translation in this context is more complicated than simple word matching.", 
        "165": "In some cases the term matching baseline is competitive with other models, suggesting that API collections differ in how language descriptions overlap with component names and naming conventions.", 
        "166": "It is clear, however, that this heuristic only works for English, as shown by results on the non-English PHP datasets in Table 1.", 
        "167": "We achieve improvements on many datasets by adding additional data to the translation model (M1 Descr.).", 
        "168": "We achieve further improvements on all datasets using the discriminative model (Reranker), with most increases in performance occurring at how the top ten items are ranked.", 
        "169": "This last result suggests that phrase-level and document-level features can help to improve the overall ranking and translation, though in some cases the improvement is rather modest.", 
        "170": "Despite the simplicity of our semantic parsing model and decoder, there is still much room for improvement, especially on achieving better Accuracy @1.", 
        "171": "While one might expect better results when moving from a word-based model to a model that exploits phrase and hierarchical phrase features, the sparsity of the component vocabulary is such that most phrase patterns in the training are not observed in the evaluation.", 
        "172": "In many benchmark semantic parsing datasets, such sparsity issues do not occur (Cimiano and Minock, 2009), suggesting that state-of-the-art methods will have similar problems when applied to our datasets.", 
        "173": "Recent approaches to open-domain semantic parsing have dealt with this problem by using paraphrasing techniques (Berant and Liang, 2014) or distant supervision (Reddy et al., 2014).", 
        "174": "We expect that these methods can be used to improve our models and results, especially given the wide availability of technical documentation, for example, distributed within the Opus project (Tiedemann, 2012).", 
        "175": "Model Errors We performed analysis on some of the incorrect predictions made by our models.", 
        "176": "For some documentation sets, such as those in the GNU documentation collection2, information is organized into a small and concrete set of categories/chapters, each corresponding to various features or modules in the language and related functions.", 
        "177": "Given this information, Figure\n2https://www.gnu.org/doc/doc.en.html\nAs so\nci at\nio ns\nDa ta\nty pe s En vi ro nm en ts Pr oc ed ur es OS IO Gr ap hi cs Er ro rs Wi nd ow s Ot he r Sc he me Eq ui v. Sp ec .", 
        "178": "Fo rm s Ch ar ac te rs Nu mb er s Li st s St ri ng s Bi t St ri ng s Ve ct or s\nVectors Bit Strings\nStrings Lists\nNumbers Characters\nSpec.", 
        "179": "Forms Equiv.", 
        "180": "Scheme Other\nWindows Errors\nGraphics IO OS\nProcedures Environments\nDatatypes Associations\nda sh se l Fi le s Ba ck up s Bu ff er s Wi nd ow s Co mm an dL oo p Ke ym ap s Mo de s Do cu me nt at io n Fr am es Po si ti on s St ri ng s Da ta ty pe s Ch ar ac te rs Nu mb er s Ha sh T ab le s Se qu en ce s Ev al ua ti on Sy mb ol s OS Ga rb ag e Co ll .", 
        "181": "Di st r. Fu nc ti on s Lo ad in g Cu st om iz at io n De bu g Mi ni bu ff er s No nAs ci i Te xt Ma rk er s Di sp la y Pr oc es se s Ab br ev s Sy nt ax T ab le s Se ar ch /M at ch Re ad /W ri te\nRead/Write Search/Match\nSyntax Tables Abbrevs\nProcesses Display Markers\nText Non-Ascii\nMinibuffers Debug\nCustomization Loading\nFunctions Distr.", 
        "182": "Garbage Coll.", 
        "183": "OS\nSymbols Evaluation Sequences\nHash Tables Numbers\nCharacters Datatypes\nStrings Positions\nFrames Documentation\nModes Keymaps\nCommandLoop Windows Buffers Backups\nFiles sel\ndash\nFigure 7: Function predictions by documentation category for Scheme (left) and Elisp (right).", 
        "184": "7 shows the confusion between predicting different categories of functions, where the rows show the categories of functions to be predicted and the columns show the different categories predicted.", 
        "185": "We built these plots by finding the categories of the top 50 non-gold (or erroneous) representations generated for each validation example.", 
        "186": "The step-like lines through the diagonal of both plots show that alternative predictions (shaded according to occurrence) are often of the same category, most strikingly for the corner categories.", 
        "187": "This trend seems stable across other datasets, even among datasets with large numbers of categories.", 
        "188": "Interestingly, many confusions appear to be between related categories.", 
        "189": "For example, when making predictions about Strings functions in Scheme, the model often generates function related to BitStrings, Characters and IO.", 
        "190": "Again, this trend seems to hold for other documentation sets, suggesting that the models are often making semantically sensible decisions.", 
        "191": "Looking at errors in other datasets, one common error involves generating functions with the same name and/or functionality.", 
        "192": "In large libraries, different modules sometimes implement that same core functions, such the genericpath or posixpath modules in Python.", 
        "193": "When generating a representation for the text return size of file, our model confuses the getsize(filename) function in one module with others.", 
        "194": "Similarly, other subtle distinctions that are not explicitly expressed in the text descriptions are not captured, such as the distinction in Haskell between safe and unsafe bit shifting functions.", 
        "195": "While many of these predictions might be correct, our evaluation fails to take into account these various equivalences, which is an issue that should\nbe investigated in future work.", 
        "196": "Future work will also look systematically at the effect that types (i.e., in statically typed versus dynamic languages) have on prediction.", 
        "197": "7 Future Work  We see two possible use cases for this data.", 
        "198": "First, for benchmarking semantic parsing models on the task of semantic translation.", 
        "199": "While there has been a trend towards learning executable semantic parsers (Berant et al., 2013; Liang, 2016), there has also been renewed interest in supervised learning of formal representations in the context of neural semantic parsing models (Dong and Lapata, 2016; Jia and Liang, 2016).", 
        "200": "We believe that good performance on our datasets should lead to better performance on more conventional semantic parsing tasks, and raise new challenges involving sparsity and multilingual learning.", 
        "201": "We also see these resources as useful for investigations into natural language programming.", 
        "202": "While our experiments look at learning rudimentary translational correspondences between text and code, a next step might be learning to synthesize executable programs via these translations, along the lines of (Desai et al., 2016; Raza et al., 2015).", 
        "203": "Other document-level features, such as example input-output pairs, unit tests, might be useful in this endeavor.", 
        "204": "Acknowledgements  This work was funded by the Deutsche Forschungsgemeinschaft (DFG) via SFB 732, project D2.", 
        "205": "Thanks also to our IMS colleagues, in particular Christian Scheible, for providing feedback on earlier drafts, as well as to Jonathan Berant for helpful discussions."
    }, 
    "document_id": "P17-1148.pdf.json"
}
