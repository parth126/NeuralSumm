{
    "abstract_sentences": {
        "1": "Transition-based dependency parsers often need sequences of local shift and reduce operations to produce certain attachments.", 
        "2": "Correct individual decisions hence require global information about the sentence context and mistakes cause error propagation.", 
        "3": "This paper proposes a novel transition system, arc-swift, that enables direct attachments between tokens farther apart with a single transition.", 
        "4": "This allows the parser to leverage lexical information more directly in transition decisions.", 
        "5": "Hence, arc-swift can achieve significantly better performance with a very small beam size.", 
        "6": "Our parsers reduce error by 3.7\u20137.6% relative to those using existing transition systems on the Penn Treebank dependency parsing task and English Universal Dependencies."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Short Papers), pages 110\u2013117 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-2018  1 Introduction  Dependency parsing is a longstanding natural language processing task, with its outputs crucial to various downstream tasks including relation extraction (Schmitz et al., 2012; Angeli et al., 2015), language modeling (Gubbins and Vlachos, 2013), and natural logic inference (Bowman et al., 2016).", 
        "2": "Attractive for their linear time complexity and amenability to conventional classification methods, transition-based dependency parsers have sparked much research interest recently.", 
        "3": "A transition-based parser makes sequential predictions of transitions between states under the restrictions of a transition system (Nivre, 2003).", 
        "4": "Transition-based parsers have been shown to excel at parsing shorter-range dependency structures, as well as languages where non-projective parses are less pervasive (McDonald and Nivre, 2007).", 
        "5": "However, the transition systems employed in state-of-the-art dependency parsers usually define very local transitions.", 
        "6": "At each step, only one or two words are affected, with very local attachments made.", 
        "7": "As a result, distant attachments require long and not immediately obvious transition sequences (e.g., ate\u2192chopsticks in Figure 1, which requires two transitions).", 
        "8": "This is further aggravated by the usually local lexical information leveraged to make transition predictions (Chen and Manning, 2014; Andor et al., 2016).", 
        "9": "In this paper, we introduce a novel transition system, arc-swift, which defines non-local transitions that directly induce attachments of distance up to n (n = the number of tokens in the sentence).", 
        "10": "Such an approach is connected to graph-based dependency parsing, in that it leverages pairwise scores between tokens in making parsing decisions (McDonald et al., 2005).", 
        "11": "We make two main contributions in this paper.", 
        "12": "Firstly, we introduce a novel transition system for dependency parsing, which alleviates the difficulty of distant attachments in previous systems by allowing direct attachments anywhere in the stack.", 
        "13": "Secondly, we compare parsers by the number of mistakes they make in common linguistic con-\n110\nstructions.", 
        "14": "We show that arc-swift parsers reduce errors in attaching prepositional phrases and conjunctions compared to parsers using existing transition systems.", 
        "15": "2 Transition-based Dependency Parsing  Transition-based dependency parsing is performed by predicting transitions between states (see Figure 1 for an example).", 
        "16": "Parser states are usually written as (\u03c3|i, j|\u03b2,A), where \u03c3|i denotes the stack with token i on the top, j|\u03b2 denotes the buffer with token j at its leftmost, and A the set of dependency arcs.", 
        "17": "Given a state, the goal of a dependency parser is to predict a transition to a new state that would lead to the correct parse.", 
        "18": "A transition system defines a set of transitions that are sound and complete for parsers, that is, every transition sequence would derive a well-formed parse tree, and every possible parse tree can also be derived from some transition sequence.1\nArc-standard (Nivre, 2004) is one of the first transition systems proposed for dependency parsing.", 
        "19": "It defines three transitions: shift, left arc (LArc), and right arc (RArc) (see Figure 2 for definitions, same for the following transition systems), where all arc-inducing transitions operate on the stack.", 
        "20": "This system builds the parse bottom-up, i.e., a constituent is only attached to its head after it has received all of its dependents.", 
        "21": "A potential drawback is that during parsing, it is difficult to predict if a constituent has consumed all of its right dependents.", 
        "22": "Arc-eager (Nivre, 2003) remedies this drawback by defining arc-inducing transitions that operate between the stack and the buffer.", 
        "23": "As a result, a constituent no longer needs to be complete\n1We only focus on projective parses for the scope of this paper.", 
        "24": "before it can be attached to its head to the left, as a right arc doesn\u2019t prevent the attached dependent from taking further dependents of its own.2 Kuhlmann et al.", 
        "25": "(2011) propose a hybrid system derived from a tabular parsing scheme, which they have shown both arc-standard and arc-eager can be derived from.", 
        "26": "Arc-hybrid combines LArc from arc-eager and RArc from arc-standard to build dependencies bottom-up.", 
        "27": "3 Non-local Transitions with arc-swift\nThe traditional transition systems discussed in Section 2 only allow very local transitions affecting one or two words, which makes long-distance dependencies difficult to predict.", 
        "28": "To illustrate the limitation of local transitions, consider parsing the following sentences:\nI ate fish with ketchup.", 
        "29": "I ate fish with chopsticks.", 
        "30": "The two sentences have almost identical structures, with the notable difference that the prepositional phrase is complementing the direct object in the first case, and the main verb in the second.", 
        "31": "For arc-standard and arc-hybrid, the parser would have to decide between Shift and RArc when the parser state is as shown in Figure 3a, where ?", 
        "32": "stands for either \u201cketchup\u201d or \u201cchopsticks\u201d.3 Similarly, an arc-eager parser would deal with the state shown in Figure 3b.", 
        "33": "Making the correct transition requires information about context words \u201cate\u201d and \u201cfish\u201d, as well as \u201c?\u201d.", 
        "34": "2A side-effect of arc-eager is that there is sometimes spurious ambiguity between Shift and Reduce transitions.", 
        "35": "For the example in Figure 1, the first Reduce can be inserted before the third Shift without changing the correctness of the resulting parse, i.e., both are feasible at that time.", 
        "36": "3For this example, we assume that the sentence is being parsed into Universal Dependencies.", 
        "37": "Parsers employing traditional transition systems would usually incorporate more features about the context in the transition decision, or employ beam search during parsing (Chen and Manning, 2014; Andor et al., 2016).", 
        "38": "In contrast, inspired by graph-based parsers, we propose arc-swift, which defines non-local transitions as shown in Figure 2.", 
        "39": "This allows direct comparison of different attachment points, and provides a direct solution to parsing the two example sentences.", 
        "40": "When the arc-swift parser encounters a state identical to Figure 3b, it could directly compare transitions RArc[1] and RArc[2] instead of evaluating between local transitions.", 
        "41": "This results in a direct attachment much like that in a graph-based parser, informed by lexical information about affinity of the pairs of words.", 
        "42": "Arc-swift also bears much resemblance to arceager.", 
        "43": "In fact, an LArc[k] transition can be viewed as k\u2212 1 Reduce operations followed by one LArc in arc-eager, and similarly for RArc[k].", 
        "44": "Reduce is no longer needed in arc-swift as it becomes part of LArc[k] and RArc[k], removing the ambiguity in derived transitions in arc-eager.", 
        "45": "arc-swift is also equivalent to arc-eager in terms of soundness and completeness.4 A caveat is that the worst-case time complexity of arc-swift is O(n2) instead of O(n), which existing transition-based parsers enjoy.", 
        "46": "However, in practice the runtime is nearly\n4This is easy to show because in arc-eager, all Reduce transitions can be viewed as preparing for a later LArc or RArc transition.", 
        "47": "We also note that similar to arc-eager transitions, arc-swift transitions must also satisfy certain pre-conditions.", 
        "48": "Specifically, an RArc[k] transition requires that the top k \u2212 1 elements in the stack are already attached; LArc[k] additionally requires that the k-th element is unattached, resulting in no more than one feasible LArc candidate for any parser state.", 
        "49": "linear, thanks to the usually small number of reducible tokens in the stack.", 
        "50": "4 Experiments    4.1 Data and Model  We use the Wall Street Journal portion of Penn Treebank with standard parsing splits (PTBSD), along with Universal Dependencies v1.3 (Nivre et al., 2016) (EN-UD).", 
        "51": "PTB-SD is converted to Stanford Dependencies (De Marneffe and Manning, 2008) with CoreNLP 3.3.0 (Manning et al., 2014) following previous work.", 
        "52": "We report labelled and unlabelled attachment scores (LAS/UAS), removing punctuation from all evaluations.", 
        "53": "Our model is very similar to that of (Kiperwasser and Goldberg, 2016), where features are extracted from tokens with bidirectional LSTMs, and concatenated for classification.", 
        "54": "For the three traditional transition systems, features of the top 3 tokens on the stack and the leftmost token in the buffer are concatenated as classifier input.", 
        "55": "For arc-swift, features of the head and dependent tokens for each arc-inducing transition are concatenated to compute scores for classification, and features of the leftmost buffer token is used for Shift.", 
        "56": "For other details we defer to Appendix A.", 
        "57": "The full specification of the model can also be found in our released code online at https://github.", 
        "58": "com/qipeng/arc-swift.", 
        "59": "4.2 Results  We use static oracles for all transition systems, and for arc-eager we implement oracles that always Shift/Reduce when ambiguity is present (arceager-S/R).", 
        "60": "We evaluate our parsers with greedy parsing (i.e., beam size 1).", 
        "61": "The results are shown in Table 1.5 Note that K&G 2016 is trained with a dynamic oracle (Goldberg and Nivre, 2012), Andor 2016 with a CRF-like loss, and both Andor 2016 and Weiss 2015 employed beam search (with sizes 32 and 8, respectively).", 
        "62": "For each pair of the systems we implemented, we studied the statistical significance of their difference by performing a paired test with 10,000 bootstrap samples on PTB-SD.", 
        "63": "The resulting pvalues are analyzed with a 10-group BonferroniHolm test, with results shown in Table 2.", 
        "64": "We note\n5In the interest of space, we abbreviate all transition systems (TS) as follows in tables: asw for arc-swift, asd for arcstandard, aeS/R for arc-eager-S/R, and ah for arc-hybrid.", 
        "65": "that with almost the same implementation, arcswift parsers significantly outperform those using traditional transition systems.", 
        "66": "We also analyzed the performance of parsers on attachments of different distances.", 
        "67": "As shown in Figure 4, arc-swift is equally accurate as existing systems for short dependencies, but is more robust for longer ones.", 
        "68": "While arc-swift introduces direct long-distance transitions, it also shortens the overall sequence necessary to induce the same parse.", 
        "69": "A parser could potentially benefit from both factors: direct attachments could make an easier classification task, and shorter sequences limit the effect of error propagation.", 
        "70": "However, since the two effects are correlated in a transition system, precise attribution of the gain is out of the scope of this paper.", 
        "71": "Computational efficiency.", 
        "72": "We study the computational efficiency of the arc-swift parser by\n6https://github.com/tensorflow/models/ blob/master/syntaxnet/g3doc/universal.md\ncomparing it to an arc-eager parser.", 
        "73": "On the PTBSD development set, the average transition sequence length per sentence of arc-swift is 77.5% of that of arc-eager.", 
        "74": "At each step of parsing, arc-swift needs to evaluate only about 1.24 times the number of transition candidates as arc-eager, which results in very similar runtime.", 
        "75": "In contrast, beam search with beam size 2 for arc-eager requires evaluating 4 times the number of transition candidates compared to greedy parsing, which results in a UAS 0.14% worse and LAS 0.22% worse for arc-eager compared to greedily decoded arcswift.", 
        "76": "4.3 Linguistic Analysis  We automatically extracted all labelled attachment errors by error type (incorrect attachment or relation), and categorized a few top parser errors by hand into linguistic constructions.", 
        "77": "Results on PTB-SD are shown in Table 3.7 We note that the arc-swift parser improves accuracy on prepositional phrase (PP) and conjunction attachments, while it remains comparable to other parsers on other common errors.", 
        "78": "Analysis on EN-UD shows a similar trend.", 
        "79": "As shown in the table, there are still many parser errors unaccounted for in our analysis.", 
        "80": "We leave this to future work.", 
        "81": "7We notice that for some examples the parsers predicted a ccomp (complement clause) attachment to verbs \u201csays\u201d and \u201csaid\u201d, where the CoreNLP output simply labelled the relation as dep (unspecified).", 
        "82": "For other examples the relation between the prepositions in \u201cout of\u201d is labelled as prep (preposition) instead of pcomp (prepositional complement).", 
        "83": "We suspect this is due to the converter\u2019s inability to handle certain corner cases, but further study is warranted.", 
        "84": "5 Related Work  Previous work has also explored augmenting transition systems to facilitate longer-range attachments.", 
        "85": "Attardi (2006) extended the arcstandard system for non-projective parsing, with arc-inducing transitions that are very similar to those in arc-swift.", 
        "86": "A notable difference is that their transitions retain tokens between the head and dependent.", 
        "87": "Ferna\u0301ndez-Gonza\u0301lez and Go\u0301mezRodr\u0131\u0301guez (2012) augmented the arc-eager system with transitions that operate on the buffer, which shorten the transition sequence by reducing the number of Shift transitions needed.", 
        "88": "However, limited by the sparse feature-based classifiers used, both of these parsers just mentioned only allow direct attachments of distance up to 3 and 2, respectively.", 
        "89": "More recently, Sartorio et al.", 
        "90": "(2013) extended arc-standard with transitions that directly attach to left and right \u201cspines\u201d of the top two nodes in the stack.", 
        "91": "While this work shares very similar motivations as arc-swift, it requires additional data structures to keep track of the left and right spines of nodes.", 
        "92": "This transition system also introduces spurious ambiguity where multiple transition sequences could lead to the same correct parse, which necessitates easy-first training to achieve a more noticeable improvement over arcstandard.", 
        "93": "In contrast, arc-swift can be easily implemented given the parser state alone, and does not give rise to spurious ambiguity.", 
        "94": "For a comprehensive study of transition systems for dependency parsing, we refer the reader to (Bohnet et al., 2016), which proposed a generalized framework that could derive all of the traditional transition systems we described by configuring the size of the active token set and the maximum arc length, among other control parameters.", 
        "95": "However, this framework does not cover\narc-swift in its original form, as the authors limit each of their transitions to reduce at most one token from the active token set (the buffer).", 
        "96": "On the other hand, the framework presented in (Go\u0301mezRodr\u0131\u0301guez and Nivre, 2013) does not explicitly make this constraint, and therefore generalizes to arc-swift.", 
        "97": "However, we note that arc-swift still falls out of the scope of existing discussions in that work, by introducing multiple Reduces in a single transition.", 
        "98": "6 Conclusion  In this paper, we introduced arc-swift, a novel transition system for dependency parsing.", 
        "99": "We also performed linguistic analyses on parser outputs and showed arc-swift parsers reduce errors in conjunction and adverbial attachments compared to parsers using traditional transition systems.", 
        "100": "Acknowledgments  We thank Timothy Dozat, Arun Chaganty, Danqi Chen, and the anonymous reviewers for helpful discussions.", 
        "101": "Stanford University gratefully acknowledges the support of the Defense Advanced Research Projects Agency (DARPA) Deep Exploration and Filtering of Text (DEFT) Program under Air Force Research Laboratory (AFRL) contract No.", 
        "102": "FA8750-13-2-0040.", 
        "103": "Any opinions, findings, and conclusion or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of the DARPA, AFRL, or the US government.", 
        "104": "A Model and Training Details  Our model setup is similar to that of (Kiperwasser and Goldberg, 2016) (See Figure 5).", 
        "105": "We employ two blocks of bidirectional long short-term memory (BiLSTM) networks (Hochreiter and Schmidhuber, 1997) that share very similar structures, one for part-of-speech (POS) tagging, the other for parsing.", 
        "106": "Both BiLSTMs have 400 hidden units in each direction, and the output of both are concatenated and fed into a dense layer of rectified linear units (ReLU) before 32-dimensional representations are derived as classification features.", 
        "107": "As the input to the tagger BiLSTM, we represent words with 100-dimensional word embeddings, initialized with GloVe vectors (Pennington et al., 2014).8 The output distribution of the tagger classifier is used to compute a weighted sum of 32- dimensional POS embeddings, which is then concatenated with the output of the tagger BiLSTM (800-dimensional per token) as the input to the parser BiLSTM.", 
        "108": "For the parser BiLSTM, we use two separate sets of dense layers to derive a \u201chead\u201d and a \u201cdependent\u201d representation for each token.", 
        "109": "These representations are later merged according to the parser state to make transition predictions.", 
        "110": "For traditional transition systems, we follow (Kiperwasser and Goldberg, 2016) by featurizing the top 3 tokens on the stack and the leftmost token in the buffer.", 
        "111": "To derive features for each token, we take its head representation vhead and dependent representation vdep, and perform the following biaffine combination\nvfeat,i = [f(vhead, vdep)]i\n= ReLU ( v>headWivdep + b > i vhead\n+ c>i vdep + di ) (1)\nwhere Wi \u2208 R32\u00d732, bi, ci \u2208 R32, and di is a scalar for i = 1, .", 
        "112": ".", 
        "113": ".", 
        "114": ", 32.", 
        "115": "The resulting 32- dimensional features are concatenated as the input\n8We also kept the vectors of the top 400k words trained on Wikipedia and English Gigaword for a broader coverage of unseen words.", 
        "116": "to a fixed-dimensional softmax classifier for transition decisions.", 
        "117": "For arc-swift, we featurize for each arcinducing transition with the same composition function in Equation (1) with vhead of the head token and vdep of the dependent token of the arc to be induced.", 
        "118": "For Shift, we simply combine vhead and vdep of the leftmost token in the buffer with the biaffine combination, and obtain its score by computing the inner-product of the feature and a vector.", 
        "119": "At each step, the scores of all feasible transitions are normalized to a probability distribution by a softmax function.", 
        "120": "In all of our experiments, the parsers are trained to maximize the log likelihood of the desired transition sequence, along with the tagger being trained to maximize the log likelihood of the correct POS tag for each token.", 
        "121": "To train the parsers, we use the ADAM optimizer (Kingma and Ba, 2014), with \u03b22 = 0.9, an initial learning rate of 0.001, and minibatches of size 32 sentences.", 
        "122": "Parsers are trained for 10 passes through the dataset on PTB-SD.", 
        "123": "We also find that annealing the learning rate by a factor of 0.5 for every pass after the 5th helped improve performance.", 
        "124": "For EN-UD, we train for 30 passes, and anneal the learning rate for every 3 passes after the 15th due to the smaller size of the dataset.", 
        "125": "For all of the biaffine combination layers and dense layers, we dropout their units with a small probability of 5%.", 
        "126": "Also during training time, we randomly replace 10% of the input words by an artificial \u3008UNK\u3009 token, which is then used to replace\nall unseen words in the development and test sets.", 
        "127": "Finally, we repeat each experiment with 3 independent random initializations, and use the average result for reporting and statistical significance tests.", 
        "128": "The code for the full specification of our models and aforementioned training details are available at https://github.com/qipeng/ arc-swift."
    }, 
    "document_id": "P17-2018.pdf.json"
}
