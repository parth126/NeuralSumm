{
    "abstract_sentences": {
        "1": "Recent work in semantic parsing for question answering has focused on long and complicated questions, many of which would seem unnatural if asked in a normal conversation between two humans.", 
        "2": "In an effort to explore a conversational QA setting, we present a more realistic task: answering sequences of simple but inter-related questions.", 
        "3": "We collect a dataset of 6,066 question sequences that inquire about semistructured tables from Wikipedia, with 17,553 question-answer pairs in total.", 
        "4": "To solve this sequential question answering task, we propose a novel dynamic neural semantic parsing framework trained using a weakly supervised reward-guided search.", 
        "5": "Our model effectively leverages the sequential context to outperform state-of-the-art QA systems that are designed to answer highly complex questions."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1821\u20131831 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1167  1 Introduction  Semantic parsing, which maps natural language text to meaning representations in formal logic, has emerged as a key technical component for building question answering systems (Liang, 2016).", 
        "2": "Once a natural language question has been mapped to a formal query, its answer can be retrieved by executing the query on a back-end structured database.", 
        "3": "One of the main focuses of semantic parsing research is how to address compositionality in language, and complicated questions have been specifically targeted in the design of a recently-released QA dataset (Pasupat and Liang, 2015).", 
        "4": "Take for example the following question: \u201cof those actresses who won a Tony after 1960, which one took the most amount of years after winning the Tony to\n\u2217Work done during an internship at Microsoft Research\nwin an Oscar?\u201d The corresponding logical form is highly compositional; in order to answer it, many sub-questions must be implicitly answered in the process (e.g., \u201cwho won a Tony after 1960?\u201d).", 
        "5": "While we agree that semantic parsers should be able to answer very complicated questions, in reality these questions are rarely issued by users.1 Because users can interact with a QA system repeatedly, there is no need to assume a single-turn QA setting where the exact question intent has to be captured with just one complex question.", 
        "6": "The same intent can be more naturally expressed through a sequence of simpler questions, as shown below:\n1.", 
        "7": "What actresses won a Tony after 1960?", 
        "8": "2.", 
        "9": "Of those, who later won an Oscar?", 
        "10": "3. Who had the biggest gap between their two\naward wins?", 
        "11": "Decomposing complicated intents into multiple related but simpler questions is arguably a more effective strategy to explore a topic of interest, and it reduces the cognitive burden on both the person who asks the question and the one who answers it.2\nIn this work, we study semantic parsing for answering sequences of simple related questions.", 
        "12": "We collect a dataset of question sequences called SequentialQA (SQA; Section 2)3 by asking crowdsourced workers to decompose complicated questions sampled from the WikiTableQuestions dataset (Pasupat and Liang, 2015) into multiple easier ones.", 
        "13": "SQA, which contains 6,066 question sequences with 17,553 total question-answer pairs, is to the best of our knowledge the first semantic parsing dataset for sequential question answering.", 
        "14": "Section 3 describes our novel dynamic neural semantic parsing framework (DynSP), a weakly su-\n1For instance, there are only 3.75% questions with more than 15 words in WikiAnswers (Fader et al., 2014).", 
        "15": "2Studies have shown increased sentence complexity links to longer reading times (Hale, 2006; Levy, 2008; Frank, 2013).", 
        "16": "3Available at http://aka.ms/sqa\n1821\npervised structured-output learning approach based on reward-guided search that is designed for solving sequential QA.", 
        "17": "We demonstrate in Section 4 that DynSP achieves higher accuracies than existing systems on SQA, and we offer a qualitative analysis of question types that our method answers effectively, as well as those on which it struggles.", 
        "18": "2 A Dataset of Question Sequences  We collect the SequentialQA (SQA) dataset via crowdsourcing by leveraging WikiTableQuestions (Pasupat and Liang, 2015, henceforth WTQ), which contains highly compositional questions associated with HTML tables from Wikipedia.", 
        "19": "Each crowdsourcing task contains a long, complex question originally from WTQ as the question intent.", 
        "20": "The workers are asked to compose a sequence of simpler questions that lead to the final intent; an example of this process is shown in Figure 1.", 
        "21": "To simplify the task for workers, we only use questions from WTQ whose answers are cells in the table, which excludes those involving arithmetic and counting.", 
        "22": "We likewise also restrict the questions our workers can write to those answerable by only table cells.", 
        "23": "These restrictions speed the annotation process because workers can just click on the table to answer their question.", 
        "24": "They also allow us to collect answer coordinates (row and column in the table) as opposed to answer text, which removes many normalization issues for answer string matching in evaluation.", 
        "25": "Finally, we only use long questions that contain nine or more words as intents; shorter questions tend to be simpler and are thus less amenable to decomposition.", 
        "26": "2.1 Properties of SQA  In total, we used 2,022 question intents from the train and test folds of the WTQ for decomposition.", 
        "27": "We had three workers decompose each intent, resulting in 6,066 unique questions sequences containing 17,553 total question-answer pairs (for an average of 2.9 questions per sequence).", 
        "28": "We divide the dataset into train and test using the original WTQ folds, resulting in an 83/17 train/test split.", 
        "29": "Importantly, just like in WTQ, none of the tables in the test set are seen in the training set.", 
        "30": "We identify three frequently-occurring question classes: column selection, subset selection, and row selection.4 In column selection questions, the answer is an entire column of the table; these questions account for 23% of all questions in SQA.", 
        "31": "Subset and row selection are more complicated than column selection, as they usually contain coreferences to the previous question\u2019s answer.", 
        "32": "In subset selections, the answer is a subset of the previous question\u2019s answer; similarly, the answers to row selections occur in the same row(s) as the previous answer but in a different column.", 
        "33": "Subset selections make up 27% of SQA, while row selections are an additional 19%.", 
        "34": "The remaining 31% contains more complex combinations of these three types.", 
        "35": "We also observe dramatic differences in the types of questions that are asked at each position of the sequence.", 
        "36": "For example, 51% of the first questions in the sequences are column selections (e.g., \u201cwhat are all of the teams?\u201d).", 
        "37": "This number dwindles to just 18% when we look at the second question of each sequence, which indicates that the collected sequences start with general questions and progress to more specific ones.", 
        "38": "3 Dynamic Neural Semantic Parsing  The unique setting of SQA provides both opportunities and challenges.", 
        "39": "On the one hand, it contains short questions with less compositionality, which in theory should reduce the difficulty of the semantic parsing problem; on the other hand, the additional contextual dependencies of the preceding questions and their answers increase modeling complexity.", 
        "40": "These observations lead us to propose a dynamic neural semantic parsing framework (DynSP) trained using a reward-guided search pro-\n4In the example sequence \u201cwhat are all of the tournaments?", 
        "41": "in which one did he score the least points?", 
        "42": "on what date was that?\u201d, the first question is a column selection, the second is a subset selection, and the last one is a row selection.", 
        "43": "cedure for solving SQA.", 
        "44": "Given a question (optionally along with previous questions and answers) and a table, DynSP formulates the semantic parsing problem as a state\u2013action search problem.", 
        "45": "Each state represents a complete or partial parse, while each action corresponds to an operation to extend a parse.", 
        "46": "The goal during inference is to find an end state with the highest score as the predicted parse.", 
        "47": "The quality of the induced semantic parse obviously depends on the scoring function.", 
        "48": "In our design, the score of a state is determined by the scores of actions taken from the initial state to the target state, which are predicted by different neural network modules based on action type.", 
        "49": "By leveraging a margin-based objective function, the model learning procedure resembles several structured-output learning algorithms such as structured SVMs (Tsochantaridis et al., 2005), but can take either strong or weak supervision seamlessly.", 
        "50": "DynSP is inspired by STAGG, a search-based semantic parser (Yih et al., 2015), as well as the dynamic neural module network (DNMN) of Andreas et al.", 
        "51": "(2016).", 
        "52": "Much like STAGG, DynSP chains together different modules as search progresses; however, these modules are implemented as neural networks, which enables end-to-end training as in DNMN.", 
        "53": "The key difference between DynSP and DNMN is that in DynSP the network structure of an example is not predetermined.", 
        "54": "Instead, different network structures are constructed dynamically as our learning procedure explores the state space.", 
        "55": "It is straightforward to answer sequential questions using our framework: we allow the model to take the previous question and its answers as input, with a slightly modified action space to reflect a dependent semantic parse.", 
        "56": "The same search / learning procedure is then able to effortlessly adapt to the new setting.", 
        "57": "In this section, we first describe the formal language underlying DynSP, followed by the model formulation and learning algorithm.", 
        "58": "3.1 Semantic parse language  Because tables are used as the data source to answer questions in SQA, we decide to form our semantic parses in an SQL-like language5.", 
        "59": "Our parses consist of two parts: a select statement and conjunctions of zero or more conditions.", 
        "60": "5Our framework is not restricted to the formal language we use in this work.", 
        "61": "In addition, the structured query can be straightforwardly represented in other formal languages, such as the lambda DCS logic used in (Pasupat and Liang, 2015).", 
        "62": "A select statement is associated with a column name, which is referred to as the answer column.", 
        "63": "Conditions enforce additional constraints on which cells in the answer column can be chosen; a select statement without any conditions indicates that an entire column of the table is the answer to the question.", 
        "64": "In particular, each condition contains a column name as the condition column and an operator with zero or more arguments.", 
        "65": "The operators in this work include: =, 6=, >,\u2265, <,\u2264, argmin, argmax.", 
        "66": "A cell in the answer column is only a legitimate answer if the cell of the corresponding row in the condition column satisfies the constraint defined by the operator and its arguments.", 
        "67": "As a concrete example, suppose the data source is the same table in Fig.", 
        "68": "1.", 
        "69": "The semantic parse of the question \u201cWhich super heroes came from Earth and first appeared after 2009?\u201d is \u201cSelect Character Where {Home World = Earth} \u2227 {First Appeared > 2009}\u201d and the answers are {Dragonwing, Harmonia}.", 
        "70": "In order to handle the sequential aspect of SQA, we extend the semantic parse language by adding a preamble statement subsequent.", 
        "71": "A subsequent statement contains only conditions, as it essentially adds constraints to the semantic parse of the previous question.", 
        "72": "For instance, if the follow-up question is \u201cWhich of them breathes fire?\u201d, then the corresponding semantic parse is \u201cSubsequent Where {Powers = Fire breath}\u201d.", 
        "73": "The answer to this question is {Dragonwing}, a subset of the previous answer.", 
        "74": "3.2 Model formulation  We start introducing our model design by first defining the state and action space.", 
        "75": "Let S be the set of states and A the set of all actions.", 
        "76": "A state s \u2208 S is simply a sequence of variable length of actions {a1, a2, a3, \u00b7 \u00b7 \u00b7 , at}, where ai \u2208 A.", 
        "77": "An empty sequence, s0 = \u03c6, is a special state used as the starting point of search.", 
        "78": "As mentioned earlier, a state represents a (partial) semantic parse of one question.", 
        "79": "Each action is thus a legitimate operation that can be added to grow the semantic parse.", 
        "80": "Our action space design is tied closely to the statements defined by our parse language; in particular, an action instance is either a complete or partial statement, and action instances are grouped by type.", 
        "81": "For example, select and subsequent operations are two action types.", 
        "82": "A condition statement is formed by two different action types:\n(1) selection of the condition column, and (2) the comparison operator.", 
        "83": "The instances of each action type differ in their arguments (e.g., column names, or specific cells in a column).", 
        "84": "Because conditions in a subsequent parse rely on previous questions and answers, they belong to different action types from regular conditions.", 
        "85": "Table 1 summarizes the action space defined in this work.", 
        "86": "Any state that represents a complete and legitimate parse is an end state.", 
        "87": "Notice that search does not necessarily need to stop at an end state, because adding more actions (e.g., condition statements) can lead to another end state.", 
        "88": "Take the same example question from before: \u201cWhich super heroes came from Earth and first appeared after 2009?\u201d.", 
        "89": "One action sequence that represents the parse is {(A1) select-column Character, (A2) cond-column Home World, (A3) op-equal Earth, (A2) cond-column First Appeared, (A5) op-gt 2009}.", 
        "90": "Notice that many states represent semantically equivalent parses (e.g., those with the same actions ordered differently, or states with repeated conditions).", 
        "91": "To prune the search space, we introduce the function Act(s) \u2282 A, which defines the actions that can be taken when given a state s. Borrowing the idea of staged state generation in (Yih et al., 2015), we choose a default ordering of actions based on their types, dictating that a select action must be picked first and that a condition-\ncolumn needs to be determined before the operator is chosen.", 
        "92": "The full transition diagram is presented in Fig.", 
        "93": "2.", 
        "94": "Note that to implement this transition order, we only need to check the last action in the state.", 
        "95": "In addition, we also disallow adding duplicates of actions that already exist in the state.", 
        "96": "We use beam search to find an end state with the highest score for inference.", 
        "97": "Let st be a state consisting of a sequence of actions a1, a2, \u00b7 \u00b7 \u00b7 , at.", 
        "98": "The state value function V is defined recursively as V (st) = V (st\u22121) + \u03c0(st\u22121, at), V (s0) = 0, where the policy function \u03c0(s, a) scores an action a \u2208 Act(s) given the current state.", 
        "99": "3.3 Policy function  The intuition behind the policy function can be summarized as follows.", 
        "100": "Halfway through the construction of a semantic parse, the policy function measures the quality of an immediate action that can be taken next given the current state (i.e., the question and actions that have previously been chosen).", 
        "101": "To enable integrated, end-to-end learning, the policy function in our framework is parameterized using neural networks.", 
        "102": "Because each action type has very different semantics, we design different network structures (i.e., modules) accordingly.", 
        "103": "Most of our network structures encourage learning semantic matching functions between the words in the question and table (either the column names or cells).", 
        "104": "Here we illustrate the design using the select-column action type (A1).", 
        "105": "Conceptually, the corresponding module is a combination of various matching scores.", 
        "106": "Let WQ be the embeddings of words in the question and WC be the embeddings of words in the target column name.", 
        "107": "The component matching functions are:\nfmax = 1 |WC | \u2211\nwc\u2208WC\nmax wq\u2208WQ\nwTq wc\nfavg =   1 |WC | \u2211\nwc\u2208WC\nwc\n  T   1 |WQ| \u2211\nwq\u2208WQ\nwq\n \nEssentially, for each word in the column name, fmax finds the highest matching question word and outputs the average score.", 
        "108": "Conversely, favg simply uses the average word vectors of the question and column name and returns their inner product.", 
        "109": "In another variant of favg, we replace the question representation with the output of a bi-directional LSTM model.", 
        "110": "These matching component functions are combined by a 2-layer feed-forward neural network, which outputs a scalar value as the action score.", 
        "111": "Details of the neural module design for other action types can be found in Appendix A.", 
        "112": "3.4 Model learning  Because the state value function V is defined recursively as the sum of scores of actions in the sequence, the goal of model optimization is to learn the parameters in the neural networks behind the policy function.", 
        "113": "Let \u03b8 be the collection of all the model parameters.", 
        "114": "Then the state value function can be written as: V\u03b8(st) = \u2211t i=1 \u03c0\u03b8(si\u22121, ai).", 
        "115": "In a fully supervised setting where the correct semantic parse of each question is available, learning the policy function can be reduced to a sequence prediction problem.", 
        "116": "However, while having full supervision leads to a better semantic parser, collecting the correct parses requires a much more sophisticated UI design (Yih et al., 2016).", 
        "117": "In many scenarios, such as the one in the SQA dataset, it is often the case that only the answers to the questions are available.", 
        "118": "Adapting a learning algorithm to this weakly supervised setting is thus critical.", 
        "119": "Generally speaking, weakly supervised semantic parsers operate on one assumption \u2014 a candidate semantic parse is treated as a correct one if it results in answers that are identical to the gold answers.", 
        "120": "Therefore, a straightforward modification of existing structured learning algorithms in our setting is to use any semantic parse found to evaluate to the correct answers during beam search as a reference parse, and then update the model parameters accordingly.", 
        "121": "In practice, however, this approach is often problematic: the search space can grow enormously, and when coupled with poor model performance early during training, this leads to beams that contain no parses evaluating to the correct answer.", 
        "122": "As a result, learning becomes inefficient and takes a long time to converge.", 
        "123": "In this work, we propose a conceptually simple learning algorithm for weakly supervised training that sidesteps the inefficient learning problem.", 
        "124": "Our\nkey insight is to conduct inference using a beam search procedure guided by an approximate reward function.", 
        "125": "The search procedure is executed twice for each training example, one for finding the best possible reference semantic parse and the other for finding the predicted semantic parse to update the model.", 
        "126": "Our framework is suitable for learning from either implicit or explicit supervision, and is detailed in a companion paper (Peng et al., 2017).", 
        "127": "Below we describe how we adapt it to the semantic parsing problem in this work.", 
        "128": "Approximate reward Let A(s) be the answers retrieved by executing the semantic parse represented by state s, and let A\u2217 be the set of gold answers of a given question.", 
        "129": "We define the reward R(s;A\u2217) = 1[A(s) = A\u2217], or the accuracy of the retrieved answers.", 
        "130": "We use R(s) as the abbreviation for R(s;A\u2217).", 
        "131": "A state s with R(s) = 1 is called a goal state.", 
        "132": "Directly using this reward function in search of goal states can be difficult, as rewards of most states are 0.", 
        "133": "However, even when the answers from a semantic parse are not completely correct, some overlap with the gold answers can still hint that the state is close to a goal state, thus providing useful information to guide search.", 
        "134": "To formalize this idea, we define an approximated reward R\u0303(s) in this work using the Jaccard coefficient (R\u0303(s) = |A(s) \u2229 A\u2217|/|A(s) \u222a A\u2217|).", 
        "135": "If s is a goal state, then obviously R\u0303(s) = R(s) = 1.", 
        "136": "Also because our actions effectively add additional constraints to exclude some table cells, any succeeding states of s\u2032 with R\u0303(s\u2032) = 0 will also have 0 approximate reward and can be pruned from search immediately.", 
        "137": "We use the approximate reward R\u0303 to guide our beam search to find the reference parses (i.e., goal states).", 
        "138": "Some variations of the approximate reward can be used to make learning more efficient.", 
        "139": "For instance, we use the model score for tie-breaking, effectively making the approximate reward function depend on the model parameters:\nR\u0303\u03b8(s) = |A(s)\u2229A\u2217|/|A(s)\u222aA\u2217|+ V\u03b8(s), (1) where is a small constant.", 
        "140": "When a goal state is not found, the state with the highest approximate reward can still be used as a surrogate reference.", 
        "141": "Updating parameters The model parameters are updated by first finding the most violated state s\u0302 and then comparing s\u0302 with a reference state s\u2217 to compute a loss.", 
        "142": "The idea of finding the most violated state comes from Taskar et al.", 
        "143": "(2004), with the\nAlgorithm 1 Model parameter updates 1: for pick a labeled data (x,A\u2217) do 2: s\u2217 \u2190 argmax\ns\u2208E(x) R\u0303(s;A\u2217)\n3: s\u0302\u2190 argmax s\u2208E(x) V\u03b8(s)\u2212 R\u0303(s;A\u2217) 4: update \u03b8 by minimizing max(L(s), 0) 5: end for\nintuition that the learning algorithm should make the state value function behave similarly to the reward.", 
        "144": "Formally, for every state s, we would like the value function to satisfy the following constraint:\nV\u03b8(s \u2217)\u2212 V\u03b8(s) \u2265 R(s\u2217)\u2212R(s) (2)\nR(s\u2217) \u2212 R(s) is thus the margin.", 
        "145": "As discussed above, we use approximate reward function R\u0303\u03b8 instead of the true reward.", 
        "146": "We want to update the model parameters \u03b8 to make sure that the constraint is satisfied.", 
        "147": "When the constraint is violated, the degree of violation can be written as:\nL(s) = V\u03b8(s)\u2212 V\u03b8(s\u2217)\u2212 R\u0303\u03b8(s) + R\u0303\u03b8(s\u2217) (3)\nIn the algorithm, we want to find the state such that the corresponding constraint is most violated.", 
        "148": "Finding the most violated state is then equivalent to finding the state with the highest value of V\u03b8(s)\u2212 R\u0303\u03b8(s) as the other two terms are constant.", 
        "149": "Algorithm 1 sketches the key steps of our method in each iteration.", 
        "150": "It first picks a training instance (x and y), where x represents the table and the question, and y is the gold answer set.", 
        "151": "The approximate reward function R\u0303 is defined by y, while E(x) is the set of end states for this instance.", 
        "152": "Line 2 finds the best reference and Line 3 finds the most violated state, both relying on beam search for approximate inference.", 
        "153": "Line 4 computes the gradient of the loss in Eq.", 
        "154": "(3), which is then used in backpropagation to update the model parameters.", 
        "155": "4 Experiments  Since the questions in SQA are decomposed from those in WTQ, we compare our method, DynSP, to two existing semantic parsers designed for WTQ: (1) the floating parser (FP) of Pasupat and Liang (2015), and (2) the neural programmer (NP) of Neelakantan et al.", 
        "156": "(2017).", 
        "157": "We describe below each system\u2019s configurations in more detail and qualitatively compare and contrast their performance on SQA.", 
        "158": "Floating parser: The floating parser (Pasupat and Liang, 2015) maps questions to logical forms and then executes them on the table to retrieve the answers.", 
        "159": "It was designed specifically for the WTQ task (achieving 37.0% accuracy on the WTQ test set) and differs from other semantic parsers by not anchoring predicates to tokens in the question, relying instead on typing constraints to reduce the search space.", 
        "160": "Using FP as-is results in poor performance on SQA because the system is configured for questions with single answers, while SQA contains many questions with multiple-cell answers.", 
        "161": "We address this issue by removing a pruning hyperparameter (tooManyValues) and features that add bias on the denotation size.", 
        "162": "Neural programmer: The neural programmer proposed by Neelakantan et al.", 
        "163": "(2017) has shown promising results on WTQ, achieving accuracies on par with those of FP.", 
        "164": "Similar to our method, NP contains specialized neural modules that perform discrete operations such as argmax and argmin, and it is able to chain together multiple modules to answer a single question.", 
        "165": "However, module selection in NP is computed via soft attention (Cho et al., 2014), and information is propagated from one module to the next using a recurrent neural network.", 
        "166": "Since module selection is not tied to a pre-defined parse language like DynSP, NP simply runs for a fixed number of recurrent timesteps per question rather than growing a parse until it is complete.", 
        "167": "Comparing the baseline systems: FP and NP exemplify two very different paradigms for designing a semantic parsing system to answer questions using structured data.", 
        "168": "FP is a feature-rich system that aims to output the correct semantic parse (in a logical parse language) for a given question.", 
        "169": "On the other hand, the end-to-end neural network of NP relies on its modular architectures to output a probability distribution over cells in a table given a question.", 
        "170": "While NP can learn more powerful neural matching functions between questions and tables than FP\u2019s simpler feature-based matching, NP cannot produce a complete, discrete semantic parse, which means that its actions can only be interpreted coarsely by looking at the order of the modules selected at each timestep.6 Furthermore, FP\u2019s design theoretically allows it to operate on partial tables\n6Since NP uses a fixed number of timesteps for each question, the module order is not guaranteed to correspond to a complete parse.", 
        "171": "indirectly through an API, which is necessary if tables are large and stored in a backend database, while NP requires upfront access to the full tables to facilitate end-to-end model differentiability.7\nEven though FP and NP are powerful systems designed for the more difficult, compositional questions in WTQ, our method outperforms both systems on SQA when we consider all questions within a sequence independently of each other (a fair comparison), demonstrating the power of our search-based semantic parsing framework.", 
        "172": "More interestingly, when we leverage the sequential information by including the subsequent action, our method improves almost 3% in absolute accuracy.", 
        "173": "DynSP combines the best parts of both FP and NP.", 
        "174": "Given a question, we try to generate its correct semantic parse in a formal language that can be predefined by the choice of structured data source (e.g., SQL).", 
        "175": "However, we push the burden of feature engineering to neural networks as in NP.", 
        "176": "Our framework is easier to extend to the sequential setting of SQA than either baseline system, requiring just the additional subsequent action.", 
        "177": "FP\u2019s reliance on a hand-designed grammar necessitates extra rules that operate over partial tables from the previous question, which if added would blow up the search space.", 
        "178": "Meanwhile, modifying NP to handle sequential QA is non-trivial due to soft module and answer selection; it is not immediately clear how to constrain predictions for one question based on the probability distribution over table cells from the previous question in the sequence.", 
        "179": "To more fairly compare DynSP to the baseline systems, we also experiment with a \u201cconcatenated questions\u201d setting, which allows the baselines to access sequential context.", 
        "180": "Here, we treat concatenated question prefixes of a sequence as additional training examples, where a question prefix includes all questions prior to the current question in the sequence.", 
        "181": "For example, suppose the question sequence is: 1. what are all of the teams?", 
        "182": "2. of those, which won championships?", 
        "183": "For the second question, in addition to the original question\u2013answer pair, we add the concatenated question sequence \u201cwhat are all of the teams?", 
        "184": "of those, which won championships?\u201d paired with the second question\u2019s answer.", 
        "185": "We refer to these concatenated question baselines as FP+ and NP+.", 
        "186": "7In fact, NP is restricted during training to only questions whose associated tables have fewer than a certain threshold of rows and columns due to computational constraints.", 
        "187": "4.1 DynSP implementation details\nUnlike previous dynamic neural network frameworks (Andreas et al., 2016; Looks et al., 2017), where each example can have different but predetermined structure, DynSP needs to dynamically explores and constructs different neural network structures for each question.", 
        "188": "Therefore, we choose DyNet (Neubig et al., 2017) as our implementation platform for its flexibility in composing computation graphs.", 
        "189": "We optimize our model parameters using standard stochastic gradient descent.", 
        "190": "The word embeddings are initialized with 100-d pretrained GloVe vectors (Pennington et al., 2014) and fine-tuned during training with dropout rate 0.5.", 
        "191": "For follow-up questions, we choose uniformly at random to use either gold answers to the previous question or the model\u2019s previous predictions.8 We constrain the maximum length of actions to 3 for computational efficiency and set the beam size to 15 in our reported models, as accuracy gains are negligible with larger beam sizes.", 
        "192": "We train our model for 30 epochs, although the best model on the validation set is usually found within the first 20 epochs.", 
        "193": "Only CPU is used in model training, and each epoch in the beam size 15 setting takes about 30 minutes to complete.", 
        "194": "4.2 Results & Analysis  Table 2 shows the results of the baseline systems as well as our method on SQA\u2019s test set.", 
        "195": "For each system, we show both the overall accuracy, the sequence accuracy (the percentage of sequences for which every question was answered correctly), and the accuracy at each position in the sequence.", 
        "196": "Our method without any sequential information (DynSP) outperforms the standard baselines, and when the subsequent action is added (DynSP\u2217), we improve both overall and sequence accuracy over the concatenated-question baselines.", 
        "197": "With that said, all of the systems struggle to answer all questions within a sequence correctly, despite the fact that each individual question is simpler on average than those in WTQ.", 
        "198": "Most of the errors made by our system are due to either semantic matching challenges or limitations of the underlying parse language.", 
        "199": "In the middle example of Figure 3, the first question asks for a list of super heroes; from the model\u2019s point of view, Real name is a more relevant column than Character, although the latter is correct.", 
        "200": "The second question also con-\n8Only predicted answers are used at test time.", 
        "201": "tains a challenging matching problem where the unlisted home worlds referred to in the question are marked as Unknown in the table.", 
        "202": "Many of these matching issues are resolved by humans using common sense, which for computers requires far more data than is available in SQA to learn.", 
        "203": "Even when there are no tricky discrepancies between question and table text, questions are often complex enough that their semantic parses cannot be expressed in our parse language.", 
        "204": "Although trivial on the surface, the final question in the bottom sequence of Figure 3 is one such example; the correct semantic parse requires access to the answers of both the first and second question, actions that we have not currently implemented in our language due to concerns with the search space size.", 
        "205": "Increasing the number of complex actions requires designing smarter optimization procedures, which we leave to future work.", 
        "206": "5 Related Work  Previous work on conversational QA has focused on small, single-domain datasets.", 
        "207": "Perhaps most related to our task is the context-dependent sentence analysis described in (Zettlemoyer and Collins, 2009), where conversations between customers and travel agents are mapped to logical forms after resolving referential expressions.", 
        "208": "Another dataset of travel booking conversations is used by Artzi and Zettlemoyer (2011) to learn a semantic parser for complicated queries given user clarifications.", 
        "209": "More recently, Long et al.", 
        "210": "(2016) collect three contextual semantic parsing datasets (from synthetic domains) that contain coreferences to entities and\nactions.", 
        "211": "We differentiate ourselves from these prior works in two significant ways: first, our dataset is not restricted to a particular domain, and second, a major goal of our work is to analyze the different types of sequence progressions people create when they are trying to express a complicated intent.", 
        "212": "Complex, interactive QA tasks have also been proposed in the information retrieval community, where the data source is a corpus of newswire text (Kelly and Lin, 2007).", 
        "213": "We also build on aspects of some existing interactive question-answering systems.", 
        "214": "For example, the system of Harabagiu et al.", 
        "215": "(2005) includes a module that predicts what a user will ask next given their current question.", 
        "216": "Other than FP and NP, the work of Neural Symbolic Machines (NSM) (Liang et al., 2017) is perhaps the closest to ours.", 
        "217": "NSM aims to generate formal semantic parses of questions that can be executed on Freebase to retrieve answers, and is trained using the REINFORCE algorithm (Williams, 1992) augmented with approximate gold parses found in a separate curriculum learning stage.", 
        "218": "In comparison, finding reference parses is an integral part of our algorithm.", 
        "219": "Our non-\nprobabilistic, margin-based objective function also helps avoid the need for empirical tricks to handle normalization and proper sampling, which are crucial when applying REINFORCE in practice.", 
        "220": "6 Conclusion & Future Work  In this work we move towards a conversational, multi-turn QA scenario in which systems must rely on prior context to answer the user\u2019s current question.", 
        "221": "To this end, we introduce SQA, a dataset that consists of 6,066 unique sequences of inter-related questions about Wikipedia tables, with 17,553 questions-answer pairs in total.", 
        "222": "To the best of our knowledge, SQA is the first semantic parsing dataset that addresses sequential question answering.", 
        "223": "We propose DynSP, a dynamic neural semantic parsing framework, for solving SQA.", 
        "224": "By formulating semantic parsing as a state\u2013action search problem, our method learns modular neural network models through reward-guided search.", 
        "225": "DynSP outperforms existing state-of-the-art systems designed for answering complex questions when applied to SQA, and increases the gain after incorporating the subsequent actions.", 
        "226": "In the future, we plan to investigate several interesting research questions triggered by this work.", 
        "227": "For instance, although our current formal language design covers most question types in SQA, it is nevertheless important to extend it further to make the semantic parser more robust (e.g., by including UNION or allowing comparison of multiple previous answers).", 
        "228": "Practically, allowing a more complicated semantic parse structure\u2014either by increasing the number of primitive statements or the length of the parse\u2014poses serious computational challenges in both model learning and inference.", 
        "229": "Because of the dynamic nature of our framework, it is not trivial to leverage the computational capabilities of GPUs using minibatched training; we plan to investigate ways to take full advantage of modern computing machinery in the near future.", 
        "230": "Finally, better resolution of semantic matching errors is a top priority, and unsupervised learning from large external corpora is one way to make progress in this direction.", 
        "231": "Acknowledgments  We thank the anonymous reviewers for their insightful comments.", 
        "232": "We are also grateful to Panupong Pasupat for his help in configuring the floating parser baseline, and to Arvind Neelakantan for his help\nwith the neural programmer model.", 
        "233": "A Action Neural Module Design  We describe here the neural module design for each action.", 
        "234": "As most actions try to match question text to column names or table entries, the neural network architectures are essentially various kinds of semantic similarity matching functions.", 
        "235": "A1 Select-column Conceptually, the corresponding module is a combination of various matching scores.", 
        "236": "Let WQ be the embeddings of words in the question and WC be the embeddings of words in the target column name.", 
        "237": "The component matching functions are:\nfmax = 1 |WC | \u2211\nwc\u2208WC\nmax wq\u2208WQ\nwTq wc\nfavg =   1 |WC | \u2211\nwc\u2208WC\nwc\n  T   1 |WQ| \u2211\nwq\u2208WQ\nwq\n \nEssentially, for each word in the column name, fmax finds the highest matching question word and outputs the average score.", 
        "238": "Conversely, favg simply uses the average word vectors of the question and column name and returns their inner product.", 
        "239": "In another variant of favg, we replace the question representation with the output of a bidirectional LSTM model.", 
        "240": "These matching component functions are combined by a 2-layer feed-forward neural network, which outputs a scalar value as the action score.", 
        "241": "A2 Cond-column Because this action also tries to find the correct column (but for conditions), we use the same matching scoring functions as in A1 module.", 
        "242": "However, a different 2-layer feed-forward neural network is used to combine the scores, as well as two binary features that indicate whether all the cells in this column are numeric values or not.", 
        "243": "A3 Op-Equal This action checks whether a particular column value matches the question text.", 
        "244": "Suppose the average of the word vectors of the particular cell is wx and the question word vectors are WQ.", 
        "245": "Here the matching function is:\nfmax = max wq\u2208WQ\nwTq wx\nA4 Op-NotEqual The neural module for this action extends the design for A3.", 
        "246": "It first uses a max function similar to fmax in A3 to compare the vector of the negation word \u201cnot\u201d, and the question words.", 
        "247": "This score is combined with the fmax score in A3 using a 2-layer feed-forward neural network as the final module score.", 
        "248": "A5-A8 Op-GT, Op-GE, Op-LT, Op-LE The arguments of these comparison operations are extracted from question in advance.", 
        "249": "Therefore, the action modules just need to decide whether such relations are indeed used in the question.", 
        "250": "We take a simple strategy by initialing a special word vector that tries to capture the semantics of the relation.", 
        "251": "Take op-gt, greater than, for example.", 
        "252": "We use the average of the vectors of words like more, greater and larger to initialize the special word vector, denoted as wgt.", 
        "253": "Let warg be the averaged vectors of words within a [\u22122,+2] window centered at the argument in the question.", 
        "254": "The inner product of wgt and warg is then used as the scoring function.", 
        "255": "A9-A10 Op-ArgMin, Op-ArgMax We handle ArgMin and ArgMax similarly to the comparison operations.", 
        "256": "The difference is that we compare the special word vector to the averaged vector of all the question words, instead of a short subsequence of words.", 
        "257": "Subsequent actions The modules in subsequent actions use basically the same design as their counterparts in the independent question setting.", 
        "258": "The main difference is that we extend the question representation to words from not just the target question, but also the question that immediately precedes it."
    }, 
    "document_id": "P17-1167.pdf.json"
}
