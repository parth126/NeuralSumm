{
    "abstract_sentences": {
        "1": "Harnessing the statistical power of neural networks to perform language understanding and symbolic reasoning is difficult, when it requires executing efficient discrete operations against a large knowledge-base.", 
        "2": "In this work, we introduce a Neural Symbolic Machine (NSM), which contains (a) a neural \u201cprogrammer\u201d, i.e., a sequence-to-sequence model that maps language utterances to programs and utilizes a key-variable memory to handle compositionality (b) a symbolic \u201ccomputer\u201d, i.e., a Lisp interpreter that performs program execution, and helps find good programs by pruning the search space.", 
        "3": "We apply REINFORCE to directly optimize the task reward of this structured prediction problem.", 
        "4": "To train with weak supervision and improve the stability of REINFORCE we augment it with an iterative maximum-likelihood training process.", 
        "5": "NSM outperforms the state-of-theart on the WEBQUESTIONSSP dataset when trained from question-answer pairs only, without requiring any feature engineering or domain-specific knowledge."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 23\u201333 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1003  1 Introduction  Deep neural networks have achieved impressive performance in supervised classification and structured prediction tasks such as speech recognition (Hinton et al., 2012), machine translation (Bahdanau et al., 2014; Wu et al., 2016) and more.", 
        "2": "However, training neural networks for semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011) or program induction, where language is mapped to a sym-\n\u21e4Work done while the author was interning at Google \u2020 Work done while the author was visiting Google\nbolic representation that is executed by an executor, through weak supervision remains challenging.", 
        "3": "This is because the model must interact with a symbolic executor through non-differentiable operations to search over a large program space.", 
        "4": "In semantic parsing, recent work handled this (Dong and Lapata, 2016; Jia and Liang, 2016) by training from manually annotated programs and avoiding program execution at training time.", 
        "5": "However, annotating programs is known to be expensive and scales poorly.", 
        "6": "In program induction, attempts to address this problem (Graves et al., 2014; Reed and de Freitas, 2016; Kaiser and Sutskever, 2015; Graves et al., 2016b; Andreas et al., 2016) either utilized low-level memory (Zaremba and Sutskever, 2015), or required memory to be differentiable (Neelakantan et al., 2015; Yin et al., 2015) so that the model can be trained with backpropagation.", 
        "7": "This makes it difficult to use the efficient discrete operations and memory of a traditional computer, and limited the application to synthetic or small knowledge bases.", 
        "8": "In this paper, we propose to utilize the memory and discrete operations of a traditional com-\n23\nputer in a novel Manager-Programmer-Computer (MPC) framework for neural program induction, which integrates three components:\n1.", 
        "9": "A \u201cmanager\u201d that provides weak supervision (e.g., \u2018NYC\u2019 in Figure 1) through a reward indicating how well a task is accomplished.", 
        "10": "Unlike full supervision, weak supervision is easy to obtain at scale (Section 3.1).", 
        "11": "2.", 
        "12": "A \u201cprogrammer\u201d that takes natural language as input and generates a program that is a sequence of tokens (Figure 2).", 
        "13": "The programmer learns from the reward and must overcome the hard search problem of finding correct programs (Section 2.2).", 
        "14": "3.", 
        "15": "A \u201ccomputer\u201d that executes programs in a high level programming language.", 
        "16": "Its nondifferentiable memory enables abstract, scalable and precise operations, but makes training more challenging (Section 2.3).", 
        "17": "To help the \u201cprogrammer\u201d prune the search space, it provides a friendly neural computer interface, which detects and eliminates invalid choices (Section 2.1).", 
        "18": "Within this framework, we introduce the Neural Symbolic Machine (NSM) and apply it to semantic parsing.", 
        "19": "NSM contains a neural sequenceto-sequence (seq2seq) \u201cprogrammer\u201d (Sutskever et al., 2014) and a symbolic non-differentiable Lisp interpreter (\u201ccomputer\u201d) that executes programs against a large knowledge-base (KB).", 
        "20": "Our technical contribution in this work is threefold.", 
        "21": "First, to support language compositionality, we augment the standard seq2seq model with a key-variable memory to save and reuse intermediate execution results (Figure 1).", 
        "22": "This is a novel application of pointer networks (Vinyals et al., 2015) to compositional semantics.", 
        "23": "Second, to alleviate the search problem of finding correct programs when training from questionanswer pairs,we use the computer to execute partial programs and prune the programmer\u2019s search space by checking the syntax and semantics of generated programs.", 
        "24": "This generalizes the weakly supervised semantic parsing framework (Liang et al., 2011; Berant et al., 2013) by leveraging semantic denotations during structural search.", 
        "25": "Third, to train from weak supervision and directly maximize the expected reward we turn to the REINFORCE (Williams, 1992) algorithm.", 
        "26": "Since learning from scratch is difficult for REINFORCE, we combine it with an iterative max-\nimum likelihood (ML) training process, where beam search is used to find pseudo-gold programs, which are then used to augment the objective of REINFORCE.", 
        "27": "On the WEBQUESTIONSSP dataset (Yih et al., 2016), NSM achieves new state-of-the-art results with weak supervision, significantly closing the gap between weak and full supervision for this task.", 
        "28": "Unlike prior works, it is trained end-toend, and does not require feature engineering or domain-specific knowledge.", 
        "29": "2 Neural Symbolic Machines  We now introduce NSM by first describing the \u201ccomputer\u201d, a non-differentiable Lisp interpreter that executes programs against a large KB and provides code assistance (Section 2.1).", 
        "30": "We then propose a seq2seq model (\u201cprogrammer\u201d) that supports compositionality using a key-variable memory to save and reuse intermediate results (Section 2.2).", 
        "31": "Finally, we describe a training procedure that is based on REINFORCE, but is augmented with pseudo-gold programs found by an iterative ML training procedure (Section 2.3).", 
        "32": "Before diving into details, we define the semantic parsing task: given a knowledge base K, and a question x = (w1, w2, ..., wm), produce a program or logical form z that when executed against K generates the right answer y.", 
        "33": "Let E denote a set of entities (e.g., ABELINCOLN),1 and let P denote a set of properties (e.g., PLACEOFBIRTH).", 
        "34": "A knowledge base K is a set of assertions or triples (e1, p, e2) 2 E \u21e5 P \u21e5 E , such as (ABELINCOLN, PLACEOFBIRTH, HODGENVILLE).", 
        "35": "2.1 Computer: Lisp Interpreter with Code Assistance  Semantic parsing typically requires using a set of operations to query the knowledge base and process the results.", 
        "36": "Operations learned with neural networks such as addition and sorting do not perfectly generalize to inputs that are larger than the ones observed in the training data (Graves et al., 2014; Reed and de Freitas, 2016).", 
        "37": "In contrast, operations implemented in high level programming languages are abstract, scalable, and precise, thus generalizes perfectly to inputs of arbitrary size.", 
        "38": "Based on this observation, we implement operations necessary for semantic parsing with an or-\n1We also consider numbers (e.g., \u201c1.33\u201d) and date-times (e.g., \u201c1999-1-1\u201d) as entities.", 
        "39": "dinary programming language instead of trying to learn them with a neural network.", 
        "40": "We adopt a Lisp interpreter as the \u201ccomputer\u201d.", 
        "41": "A program C is a list of expressions (c1...cN ), where each expression is either a special token \u201cReturn\u201d indicating the end of the program, or a list of tokens enclosed by parentheses \u201c(FA1...AK)\u201d.", 
        "42": "F is a function, which takes as input K arguments of specific types.", 
        "43": "Table 1 defines the semantics of each function and the types of its arguments (either a property p or a variable r).", 
        "44": "When a function is executed, it returns an entity list that is the expression\u2019s denotation in K, and save it to a new variable.", 
        "45": "By introducing variables that save the intermediate results of execution, the program naturally models language compositionality and describes from left to right a bottom-up derivation of the full meaning of the natural language input, which is convenient in a seq2seq model (Figure 1).", 
        "46": "This is reminiscent of the floating parser (Wang et al., 2015; Pasupat and Liang, 2015), where a derivation tree that is not grounded in the input is incrementally constructed.", 
        "47": "The set of programs defined by our functions is equivalent to the subset of -calculus presented in (Yih et al., 2015).", 
        "48": "We did not use full Lisp programming language here, because constructs like control flow and loops are unnecessary for most current semantic parsing tasks, and it is simple to add more functions to the model when necessary.", 
        "49": "To create a friendly neural computer interface, the interpreter provides code assistance to the programmer by producing a list of valid tokens at each step.", 
        "50": "First, a valid token should not cause a syntax error: e.g., if the previous token is \u201c(\u201d, the next token must be a function name, and if the previous token is \u201cHop\u201d, the next token must be a variable.", 
        "51": "More importantly, a valid token should not cause a semantic (run-time) error: this is detected using the denotation saved in the variables.", 
        "52": "For example, if the previously generated tokens were \u201c( Hop r\u201d, the next available token is restricted to properties {p | 9e, e0 : e 2 r, (e, p, e0) 2 K} that are reachable from entities in r in the KB.", 
        "53": "These checks are enabled by the variables and can be derived from the definition of the functions in Table 1.", 
        "54": "The interpreter prunes the \u201cprogrammer\u201d\u2019s search space by orders of magnitude, and enables learning from weak supervision on a large KB.", 
        "55": "2.2 Programmer: Seq2seq Model with Key-Variable Memory  Given the \u201ccomputer\u201d, the \u201cprogrammer\u201d needs to map natural language into a program, which is a sequence of tokens that reference operations and values in the \u201ccomputer\u201d.", 
        "56": "We base our programmer on a standard seq2seq model with attention, but extend it with a key-variable memory that allows the model to learn to represent and refer to program variables (Figure 2).", 
        "57": "Sequence-to-sequence models consist of two RNNs, an encoder and a decoder.", 
        "58": "We used a 1-layer GRU (Cho et al., 2014) for both the encoder and decoder.", 
        "59": "Given a sequence of words w1, w2...wm, each word wt is mapped to an embedding qt (embedding details are in Section 3).", 
        "60": "Then, the encoder reads these embeddings and updates its hidden state step by step using ht+1 = GRU(ht, qt, \u2713Encoder), where \u2713Encoder are the GRU parameters.", 
        "61": "The decoder updates its hidden states ut by ut+1 = GRU(ut, ct 1, \u2713Decoder), where ct 1 is the embedding of last step\u2019s output token at 1, and \u2713Decoder are the GRU parameters.", 
        "62": "The last hidden state of the encoder hT is used as the decoder\u2019s initial state.", 
        "63": "We also adopt a dot-product attention similar to Dong and Lapata (2016).", 
        "64": "The tokens of the program a1, a2...an are generated one by one using a softmax over the vocabulary of valid tokens at each step, as provided by the \u201ccomputer\u201d (Section 2.1).", 
        "65": "To achieve compositionality, the decoder must learn to represent and refer to intermediate variables whose value was saved in the \u201ccomputer\u201d after execution.", 
        "66": "Therefore, we augment the model with a key-variable memory, where each entry has two components: a continuous embedding key vi, and a corresponding variable token Ri referencing the value in the \u201ccomputer\u201d (see Figure 2).", 
        "67": "During encoding, we use an entity linker to link text spans (e.g., \u201cUS\u201d) to KB entities.", 
        "68": "For each linked entity we add a memory entry where the key is the average of GRU hidden states over the entity span, and the variable token (R1) is the name of a variable in the computer holding the linked entity (m.USA) as its value.", 
        "69": "During decoding, when a full expression is generated (i.e., the decoder generates \u201c)\u201d), it gets executed, and the result is stored as the value of a new variable in the \u201ccomputer\u201d.", 
        "70": "This variable is keyed by the GRU hidden state at that step.", 
        "71": "When a new variable R1 with key embedding v1 is added into the key-variable memory,\nthe token R1 is added into the decoder vocabulary with v1 as its embedding.", 
        "72": "The final answer returned by the \u201cprogrammer\u201d is the value of the last computed variable.", 
        "73": "Similar to pointer networks (Vinyals et al., 2015), the key embeddings for variables are dynamically generated for each example.", 
        "74": "During training, the model learns to represent variables by backpropagating gradients from a time step where a variable is selected by the decoder, through the key-variable memory, to an earlier time step when the key embedding was computed.", 
        "75": "Thus, the encoder/decoder learns to generate representations for variables such that they can be used at the right time to construct the correct program.", 
        "76": "While the key embeddings are differentiable, the values referenced by the variables (lists of entities), stored in the \u201ccomputer\u201d, are symbolic and non-differentiable.", 
        "77": "This distinguishes the keyvariable memory from other memory-augmented neural networks that use continuous differentiable embeddings as the values of memory entries (Weston et al., 2014; Graves et al., 2016a).", 
        "78": "2.3 Training NSM with Weak Supervision  NSM executes non-differentiable operations against a KB, and thus end-to-end backpropagation is not possible.", 
        "79": "Therefore, we base our training procedure on REINFORCE (Williams, 1992; Norouzi et al., 2016).", 
        "80": "When the reward signal is sparse and the search space is large, it is common to utilize some full supervision to pre-train REINFORCE (Silver et al., 2016).", 
        "81": "To train from weak supervision, we suggest an iterative ML procedure for finding pseudo-gold programs that will bootstrap REINFORCE.", 
        "82": "REINFORCE We can formulate training as a reinforcement learning problem: given a question x, the state, action and reward at each time step t 2 {0, 1, ..., T} are (st, at, rt).", 
        "83": "Since the environment is deterministic, the state is defined by the question x and the action sequence: st = (x, a0:t 1), where a0:t 1 = (a0, ..., at 1) is the history of actions at time t. A valid action at time t is at 2 A(st), where A(st) is the set of valid tokens given by the \u201ccomputer\u201d.", 
        "84": "Since each action corresponds to a token, the full history a0:T corresponds to a program.", 
        "85": "The reward rt = I[t = T ] \u00b7 F1(x, a0:T ) is non-zero only at the last step of decoding, and is the F1 score computed comparing the gold answer and the answer generated by executing the program a0:T .", 
        "86": "Thus, the cumulative reward of a program a0:T is\nR(x, a0:T ) = X\nt\nrt = F1(x, a0:T ).", 
        "87": "The agent\u2019s decision making procedure at each time is defined by a policy, \u21e1\u2713(s, a) = P\u2713(at = a|x, a0:t 1), where \u2713 are the model parameters.", 
        "88": "Since the environment is deterministic, the probability of generating a program a0:T is\nP\u2713(a0:T |x) = Y\nt\nP\u2713(at | x, a0:t 1).", 
        "89": "We can define our objective to be the expected cumulative reward and use policy gradient meth-\nods such as REINFORCE for training.", 
        "90": "The objective and gradient are:\nJRL(\u2713) = X\nx\nEP\u2713(a0:T |x)[R(x, a0:T )],\nr\u2713JRL(\u2713) = X\nx\nX\na0:T\nP\u2713(a0:T | x) \u00b7 [R(x, a0:T )\nB(x)] \u00b7r\u2713 log P\u2713(a0:T | x),\nwhere B(x) = P\na0:T P\u2713(a0:T | x)R(x, a0:T ) is\na baseline that reduces the variance of the gradient estimation without introducing bias.", 
        "91": "Having a separate network to predict the baseline is an interesting future direction.", 
        "92": "While REINFORCE assumes a stochastic policy, we use beam search for gradient estimation.", 
        "93": "Thus, in contrast with common practice of approximating the gradient by sampling from the model, we use the top-k action sequences (programs) in the beam with normalized probabilities.", 
        "94": "This allows training to focus on sequences with high probability, which are on the decision boundaries, and reduces the variance of the gradient.", 
        "95": "Empirically (and in line with prior work), REINFORCE converged slowly and often got stuck in local optima (see Section 3).", 
        "96": "The difficulty of training resulted from the sparse reward signal in the large search space, which caused model probabilities for programs with non-zero reward to be very small at the beginning.", 
        "97": "If the beam size k is small, good programs fall off the beam, leading to zero gradients for all programs in the beam.", 
        "98": "If the beam size k is large, training is very slow, and the normalized probabilities of good programs when the model is untrained are still very small, leading to (1) near zero baselines, thus near zero gradients on \u201cbad\u201d programs (2) near zero gradients on good programs due to the low probability P\u2713(a0:T | x).", 
        "99": "To combat this, we present an alternative training strategy based on maximum-likelihood.", 
        "100": "Iterative ML If we had gold programs, we could directly optimize their likelihood.", 
        "101": "Since we do not have gold programs, we can perform an iterative procedure (similar to hard ExpectationMaximization (EM)), where we search for good programs given fixed parameters, and then optimize the probability of the best program found so far.", 
        "102": "We do decoding on an example with a large beam size and declare abest0:T (x) to be the pseudogold program, which achieved highest reward with shortest length among the programs decoded on x\nin all previous iterations.", 
        "103": "Then, we can optimize the ML objective:\nJML(\u2713) = X\nx\nlog P\u2713(a best 0:T (x) | x) (1)\nA question x is not included if we did not find any program with positive reward.", 
        "104": "Training with iterative ML is fast because there is at most one program per example and the gradient is not weighted by model probability.", 
        "105": "while decoding with a large beam size is slow, we could train for multiple epochs after each decoding.", 
        "106": "This iterative process has a bootstrapping effect that a better model leads to a better program abest0:T (x) through decoding, and a better program abest0:T (x) leads to a better model through training.", 
        "107": "Even with a large beam size, some programs are hard to find because of the large search space.", 
        "108": "A common solution to this problem is to use curriculum learning (Zaremba and Sutskever, 2015; Reed and de Freitas, 2016).", 
        "109": "The size of the search space is controlled by both the set of functions used in the program and the program length.", 
        "110": "We apply curriculum learning by gradually increasing both these quantities (see details in Section 3) when performing iterative ML.", 
        "111": "Nevertheless, iterative ML uses only pseudogold programs and does not directly optimize the objective we truly care about.", 
        "112": "This has two adverse effects: (1) The best program abest0:T (x) could be a spurious program that accidentally produces the correct answer (e.g., using the property PLACEOFBIRTH instead of PLACEOFDEATH when the two places are the same), and thus does not generalize to other questions.", 
        "113": "(2) Because training does not observe full negative programs, the model often fails to distinguish between tokens that are related to one another.", 
        "114": "For example, differentiating PARENTSOF vs. SIBLINGSOF vs. CHILDRENOF can be challenging.", 
        "115": "We now present learning where we combine iterative ML with REINFORCE.", 
        "116": "Augmented REINFORCE To bootstrap REINFORCE, we can use iterative ML to find pseudogold programs, and then add these programs to the beam with a reasonably large probability.", 
        "117": "This is similar to methods from imitation learning (Ross et al., 2011; Jiang et al., 2012) that define a proposal distribution by linearly interpolating the model distribution and an oracle.", 
        "118": "Algorithm 1 IML-REINFORCE Input: question-answer pairs D = {(xi, yi)}, mix ratio \u21b5, reward function R(\u00b7), training iterations NML, NRL, and beam sizes BML, BRL.", 
        "119": "Procedure: Initialize C\u21e4x = ; the best program so far for x Initialize model \u2713 randomly .", 
        "120": "Iterative ML for n = 1 to NML do\nfor (x, y) in D do C Decode BML programs given x for j in 1...|C| do if Rx,y(Cj) > Rx,y(C\u21e4x) then C\u21e4x Cj \u2713 ML training with DML = {(x, C\u21e4x)}\nInitialize model \u2713 randomly .", 
        "121": "REINFORCE for n = 1 to NRL do\nDRL ; is the RL training set for (x, y) in D do\nC Decode BRL programs from x for j in 1...|C| do\nif Rx,y(Cj) > Rx,y(C\u21e4x) then C\u21e4x Cj C C [ {C\u21e4x} for j in 1...|C| do\np\u0302j (1 \u21b5)\u00b7 pjP j0 pj0 where pj = P\u2713(Cj | x) if Cj = C\u21e4x then p\u0302j p\u0302j + \u21b5 DRL DRL [ {(x, Cj , p\u0302j)}\n\u2713 REINFORCE training with DRL\nAlgorithm 1 describes our overall training procedure.", 
        "122": "We first run iterative ML for NML iterations and record the best program found for every example xi.", 
        "123": "Then, we run REINFORCE, where we normalize the probabilities of the programs in beam to sum to (1 \u21b5) and add \u21b5 to the probability of the best found program C\u21e4(xi).", 
        "124": "Consequently, the model always puts a reasonable amount of probability on a program with high reward during training.", 
        "125": "Note that we randomly initialized the parameters for REINFORCE, since initializing from the final ML parameters seems to get stuck in a local optimum and produced worse results.", 
        "126": "On top of imitation learning, our approach is related to the common practice in reinforcement learning (Schaul et al., 2016) to replay rare successful experiences to reduce the training variance and improve training efficiency.", 
        "127": "This is also similar to recent developments (Wu et al., 2016) in machine translation, where ML and RL objectives are linearly combined, because anchoring the model to some high-reward outputs stabilizes training.", 
        "128": "3 Experiments and Analysis  We now empirically show that NSM can learn a semantic parser from weak supervision over a large KB.", 
        "129": "We evaluate on WEBQUESTIONSSP, a challenging semantic parsing dataset with strong baselines.", 
        "130": "Experiments show that NSM achieves\nnew state-of-the-art performance on WEBQUESTIONSSP with weak supervision, and significantly closes the gap between weak and full supervisions for this task.", 
        "131": "3.1 The WEBQUESTIONSSP dataset  The WEBQUESTIONSSP dataset (Yih et al., 2016) contains full semantic parses for a subset of the questions from WEBQUESTIONS (Berant et al., 2013), because 18.5% of the original dataset were found to be \u201cnot answerable\u201d.", 
        "132": "It consists of 3,098 question-answer pairs for training and 1,639 for testing, which were collected using Google Suggest API, and the answers were originally obtained using Amazon Mechanical Turk workers.", 
        "133": "They were updated in (Yih et al., 2016) by annotators who were familiar with the design of Freebase and added semantic parses.", 
        "134": "We further separated out 620 questions from the training set as a validation set.", 
        "135": "For query pre-processing we used an in-house named entity linking system to find the entities in a question.", 
        "136": "The quality of the entity linker is similar to that of (Yih et al., 2015) at 94% of the gold root entities being included.", 
        "137": "Similar to Dong and Lapata (2016), we replaced named entity tokens with a special token \u201cENT\u201d.", 
        "138": "For example, the question \u201cwho plays meg in family guy\u201d is changed to \u201cwho plays ENT in ENT ENT\u201d.", 
        "139": "This helps reduce overfitting, because instead of memorizing the correct program for a specific entity, the model has to focus on other context words in the sentence, which improves generalization.", 
        "140": "Following (Yih et al., 2015) we used the last publicly available snapshot of Freebase (Bollacker et al., 2008).", 
        "141": "Since NSM training requires random access to Freebase during decoding, we preprocessed Freebase by removing predicates that are not related to world knowledge (starting with \u201c/common/\u201d, \u201c/type/\u201d, \u201c/freebase/\u201d),2 and removing all text valued predicates, which are rarely the answer.", 
        "142": "Out of all 27K relations, 434 relations are removed during preprocessing.", 
        "143": "This results in a graph that fits in memory with 23K relations, 82M nodes, and 417M edges.", 
        "144": "3.2 Model Details  For pre-trained word embeddings, we used the 300 dimension GloVe word embeddings trained on 840B tokens (Pennington et al., 2014).", 
        "145": "On the encoder side, we added a projection matrix to\n2We kept \u201c/common/topic/notable types\u201d.", 
        "146": "transform the embeddings into 50 dimensions.", 
        "147": "On the decoder side, we used the same GloVe embeddings to construct an embedding for each property using its Freebase id, and also added a projection matrix to transform this embedding to 50 dimensions.", 
        "148": "A Freebase id contains three parts: domain, type, and property.", 
        "149": "For example, the Freebase id for PARENTSOF is \u201c/people/person/parents\u201d.", 
        "150": "\u201cpeople\u201d is the domain, \u201cperson\u201d is the type and \u201cparents\u201d is the property.", 
        "151": "The embedding is constructed by concatenating the average of word embeddings in the domain and type name to the average of word embeddings in the property name.", 
        "152": "For example, if the embedding dimension is 300, the embedding dimension for \u201c/people/person/parents\u201d will be 600.", 
        "153": "The first 300 dimensions will be the average of the embeddings for \u201cpeople\u201d and \u201cperson\u201d, and the second 300 dimensions will be the embedding for \u201cparents\u201d.", 
        "154": "The dimension of encoder hidden state, decoder hidden state and key embeddings are all 50.", 
        "155": "The embeddings for the functions and special tokens (e.g., \u201cUNK\u201d, \u201cGO\u201d) are randomly initialized by a truncated normal distribution with mean=0.0 and stddev=0.1.", 
        "156": "All the weight matrices are initialized with a uniform distribution in [ p 3 d , p 3 d ] where d is the input dimension.", 
        "157": "Dropout rate is set to 0.5, and we see a clear tendency for larger dropout rate to produce better performance, indicating overfitting is a major problem for learning.", 
        "158": "3.3 Training Details  In iterative ML training, the decoder uses a beam of size k = 100 to update the pseudo-gold programs and the model is trained for 20 epochs after each decoding step.", 
        "159": "We use the Adam optimizer (Kingma and Ba, 2014) with initial learning rate 0.001.", 
        "160": "In our experiment, this process usually converges after a few (5-8) iterations.", 
        "161": "For REINFORCE training, the best hyperparameters are chosen using the validation set.", 
        "162": "We use a beam of size k = 5 for decoding, and \u21b5 is set to 0.1.", 
        "163": "Because the dataset is small and some relations are only used once in the whole training set, we train the model on the entire training set for 200 iterations with the best hyperparameters.", 
        "164": "Then we train the model with learning rate decay until convergence.", 
        "165": "Learning rate is decayed as gt = g0\u21e5 max(0,t ts) m , where g0 = 0.001, = 0.5 m = 1000, and ts is the number of training steps at the end of iteration 200.", 
        "166": "Since decoding needs to query the knowledge base (KB) constantly, the speed bottleneck for training is decoding.", 
        "167": "We address this problem in our implementation by partitioning the dataset, and using multiple decoders in parallel to handle each partition.", 
        "168": "We use 100 decoders, which queries 50 KG servers, and one trainer.", 
        "169": "The neural network model is implemented in TensorFlow.", 
        "170": "Since the model is small, we didn\u2019t see a significant speedup by using GPU, so all the decoders and the trainer are using CPU only.", 
        "171": "Inspired by the staged generation process in Yih et al.", 
        "172": "(2015), curriculum learning includes two steps.", 
        "173": "We first run iterative ML for 10 iterations with programs constrained to only use the \u201cHop\u201d function and the maximum number of expressions is 2.", 
        "174": "Then, we run iterative ML again, but use both \u201cHop\u201d and \u201cFilter\u201d.", 
        "175": "The maximum number of expressions is 3, and the relations used by \u201cHop\u201d are restricted to those that appeared in abest0:T (q) in the first step.", 
        "176": "3.4 Results and discussion  We evaluate performance using the offical evaluation script for WEBQUESTIONSSP.", 
        "177": "Because the answer to a question may contain multiple entities or values, precision, recall and F1 are computed based on the output of each individual question, and average F1 is reported as the main evaluation metric.", 
        "178": "Accuracy measures the proportion of questions that are answered exactly.", 
        "179": "A comparison to STAGG, the previous state-ofthe-art model (Yih et al., 2016, 2015), is shown in Table 2.", 
        "180": "Our model beats STAGG with weak supervision by a significant margin on all metrics, while relying on no feature engineering or handcrafted rules.", 
        "181": "When STAGG is trained with strong supervision it obtains an F1 of 71.7, and thus NSM closes half the gap between training with weak and full supervision.", 
        "182": "Four key ingredients lead to the final performance of NSM.", 
        "183": "The first one is the neural computer interface that provides code assistance by checking for syntax and semantic errors.", 
        "184": "We find\nthat semantic checks are very effective for opendomain KBs with a large number of properties.", 
        "185": "For our task, the average number of choices is reduced from 23K per step (all properties) to less than 100 (the average number of properties connected to an entity).", 
        "186": "The second ingredient is augmented REINFORCE training.", 
        "187": "Table 3 compares augmented REINFORCE, REINFORCE, and iterative ML on the validation set.", 
        "188": "REINFORCE gets stuck in local optimum and performs poorly.", 
        "189": "Iterative ML training is not directly optimizing the F1 measure, and achieves sub-optimal results.", 
        "190": "In contrast, augmented REINFORCE is able to bootstrap using pseudo-gold programs found by iterative ML and achieves the best performance on both the training and validation set.", 
        "191": "The third ingredient is curriculum learning during iterative ML.", 
        "192": "We compare the performance of the best programs found with and without curriculum learning in Table 4.", 
        "193": "We find that the best programs found with curriculum learning are substantially better than those found without curriculum learning by a large margin on every metric.", 
        "194": "The last important ingredient is reducing overfitting.", 
        "195": "Given the small size of the dataset, overfitting is a major problem for training neural network models.", 
        "196": "We show the contributions of different techniques for controlling overfitting in Table 5.", 
        "197": "Note that after all the techniques have been applied, the model is still overfitting with training F1@1=83.0% and validation F1@1=67.2%.", 
        "198": "Among the programs generated by the model, a significant portion (36.7%) uses more than one expression.", 
        "199": "From Table 6, we can see that the performance doesn\u2019t decrease much as the composi-\ntional depth increases, indicating that the model is effective at capturing compositionality.", 
        "200": "We observe that programs with three expressions use a more limited set of properties, mainly focusing on answering a few types of questions such as \u201cwho plays meg in family guy\u201d, \u201cwhat college did jeff corwin go to\u201d and \u201cwhich countries does russia border\u201d.", 
        "201": "In contrast, programs with two expressions use a more diverse set of properties, which could explain the lower performance compared to programs with three expressions.", 
        "202": "Error analysis Error analysis on the validation set shows two main sources of errors:\n1.", 
        "203": "Search failure: Programs with high reward are not found during search for pseudo-gold programs, either because the beam size is not large enough, or because the set of functions implemented by the interpreter is insufficient.", 
        "204": "The 89.5% F1 score in Table 4 indicates that at least 10% of the questions are of this kind.", 
        "205": "2.", 
        "206": "Ranking failure: Programs with high reward exist in the beam, but are not ranked at the top during decoding.", 
        "207": "Because the training error is low, this is largely due to overfitting or spurious programs.", 
        "208": "The 67.2% F1 score in Table 3 indicates that about 20% of the questions are of this kind.", 
        "209": "4 Related work  Among deep learning models for program induction, Reinforcement Learning Neural Turing Machines (RL-NTMs) (Zaremba and Sutskever, 2015) are the most similar to NSM, as a nondifferentiable machine is controlled by a sequence\nmodel.", 
        "210": "Therefore, both models rely on REINFORCE for training.", 
        "211": "The main difference between the two is the abstraction level of the programming language.", 
        "212": "RL-NTM uses lower level operations such as memory address manipulation and byte reading/writing, while NSM uses a high level programming language over a large knowledge base that includes operations such as following properties from entities, or sorting based on a property, which is more suitable for representing semantics.", 
        "213": "Earlier works such as OOPS (Schmidhuber, 2004) has desirable characteristics, for example, the ability to define new functions.", 
        "214": "These remain to be future improvements for NSM.", 
        "215": "We formulate NSM training as an instance of reinforcement learning (Sutton and Barto, 1998) in order to directly optimize the task reward of the structured prediction problem (Norouzi et al., 2016; Li et al., 2016; Yu et al., 2017).", 
        "216": "Compared to imitation learning methods (Daume et al., 2009; Ross et al., 2011) that interpolate a model distribution with an oracle, NSM needs to solve a challenging search problem of training from weak supervisions in a large search space.", 
        "217": "Our solution employs two techniques (a) a symbolic \u201ccomputer\u201d helps find good programs by pruning the search space (b) an iterative ML training process, where beam search is used to find pseudogold programs.", 
        "218": "Wiseman and Rush (Wiseman and Rush, 2016) proposed a max-margin approach to train a sequence-to-sequence scorer.", 
        "219": "However, their training procedure is more involved, and we did not implement it in this work.", 
        "220": "MIXER (Ranzato et al., 2015) also proposed to combine ML training and REINFORCE, but they only considered tasks with full supervisions.", 
        "221": "Berant and Liang (Berant and Liang, 2015) applied imitation learning to semantic parsing, but still requires hand crafted grammars and features.", 
        "222": "NSM is similar to Neural Programmer (Neelakantan et al., 2015) and Dynamic Neural Module Network (Andreas et al., 2016) in that they all solve the problem of semantic parsing from structured data, and generate programs using similar semantics.", 
        "223": "The main difference between these approaches is how an intermediate result (the memory) is represented.", 
        "224": "Neural Programmer and Dynamic-NMN chose to represent results as vectors of weights (row selectors and attention vectors), which enables backpropagation and search through all possible programs in parallel.", 
        "225": "How-\never, their strategy is not applicable to a large KB such as Freebase, which contains about 100M entities, and more than 20k properties.", 
        "226": "Instead, NSM chooses a more scalable approach, where the \u201ccomputer\u201d saves intermediate results, and the neural network only refers to them with variable names (e.g., \u201cR1\u201d for all cities in the US).", 
        "227": "NSM is similar to the Path Ranking Algorithm (PRA) (Lao et al., 2011) in that semantics is encoded as a sequence of actions, and denotations are used to prune the search space during learning.", 
        "228": "NSM is more powerful than PRA by 1) allowing more complex semantics to be composed through the use of a key-variable memory; 2) controlling the search procedure with a trained neural network, while PRA only samples actions uniformly; 3) allowing input questions to express complex relations, and then dynamically generating action sequences.", 
        "229": "PRA can combine multiple semantic representations to produce the final prediction, which remains to be future work for NSM.", 
        "230": "5 Conclusion  We propose the Manager-Programmer-Computer framework for neural program induction.", 
        "231": "It integrates neural networks with a symbolic nondifferentiable computer to support abstract, scalable and precise operations through a friendly neural computer interface.", 
        "232": "Within this framework, we introduce the Neural Symbolic Machine, which integrates a neural sequence-to-sequence \u201cprogrammer\u201d with key-variable memory, and a symbolic Lisp interpreter with code assistance.", 
        "233": "Because the interpreter is non-differentiable and to directly optimize the task reward, we apply REINFORCE and use pseudo-gold programs found by an iterative ML training process to bootstrap training.", 
        "234": "NSM achieves new state-of-the-art results on a challenging semantic parsing dataset with weak supervision, and significantly closes the gap between weak and full supervision.", 
        "235": "It is trained endto-end, and does not require any feature engineering or domain-specific knowledge.", 
        "236": "Acknowledgements  We thank for discussions and help from Arvind Neelakantan, Mohammad Norouzi, Tom Kwiatkowski, Eugene Brevdo, Lukasz Kaizer, Thomas Strohmann, Yonghui Wu, Zhifeng Chen, Alexandre Lacoste, and John Blitzer.", 
        "237": "The second author is partially supported by the Israel Science Foundation, grant 942/16."
    }, 
    "document_id": "P17-1003.pdf.json"
}
