{
    "abstract_sentences": {
        "1": "We model a dependency graph as a book, a particular kind of topological space, for semantic dependency parsing.", 
        "2": "The spine of the book is made up of a sequence of words, and each page contains a subset of noncrossing arcs.", 
        "3": "To build a semantic graph for a given sentence, we design new Maximum Subgraph algorithms to generate noncrossing graphs on each page, and a Lagrangian Relaxation-based algorithm to combine pages into a book.", 
        "4": "Experiments demonstrate the effectiveness of the book embedding framework across a wide range of conditions.", 
        "5": "Our parser obtains comparable results with a state-of-the-art transition-based parser."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 828\u2013838 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1077  1 Introduction  Dependency analysis provides a lightweight and effective way to encode syntactic and semantic information of natural language sentences.", 
        "2": "One of its branches, syntactic dependency parsing (Ku\u0308bler et al., 2009) has been an extremely active research area, with high-performance parsers being built and applied for practical use of NLP.", 
        "3": "Semantic dependency parsing, however, has only been addressed in the literature recently (Oepen et al., 2014, 2015; Du et al., 2015; Zhang et al., 2016; Cao et al., 2017).", 
        "4": "Semantic dependency parsing employs a graphstructured semantic representation.", 
        "5": "On the one hand, it is flexible enough to provide analysis for various semantic phenomena (Ivanova et al., 2012).", 
        "6": "This very flexibility, on the other hand, brings along new challenges for designing parsing algorithms.", 
        "7": "For graph-based parsing, no previously defined Maximum Subgraph algorithm has simultaneously a high coverage and a polynomial\ncomplexity to low degrees.", 
        "8": "For transition-based parsing, no principled decoding algorithms, e.g.", 
        "9": "dynamic programming (DP), has been developed for existing transition systems.", 
        "10": "In this paper, we borrow the idea of book embedding from graph theory, and propose a novel framework to build parsers for flexible dependency representations.", 
        "11": "In graph theory, a book is a kind of topological space that consists of a spine and a collection of one or more half-planes.", 
        "12": "In our \u201cbook model\u201d of semantic dependency graph, the spine is made up of a sequence of words, and each half-plane contains a subset of dependency arcs.", 
        "13": "In particular, the arcs on each page compose a noncrossing dependency graph, a.k.a.", 
        "14": "planar graph.", 
        "15": "Though a dependency graph in general is very flexible, its subgraph on each page is rather regular.", 
        "16": "Under the new perspective, semantic dependency parsing can be cast as a two-step task: Each page is first analyzed separately, and then all the pages are bound coherently.", 
        "17": "Our work is motivated by the extant low-degree polynomial time algorithm for first-order Maximum Subgraph parsing for noncrossing dependency graphs (Kuhlmann and Jonsson, 2015).", 
        "18": "We enhance existing work with new exact second- and approximate higher-order algorithms.", 
        "19": "Our algorithms facilitate building with high accuracy the partial semantic dependency graphs on each page.", 
        "20": "To produce a full semantic analysis, we also need to integrate partial graphs on all pages into one coherent book.", 
        "21": "To this end, we formulate the problem as a combinatorial optimization problem, and propose a Lagrangian Relaxation-based algorithm for solutions.", 
        "22": "We implement a practical parser in the new framework with a statistical disambiguation model.", 
        "23": "We evaluate this parser on four data sets: those used in SemEval 2014 Task 8 (Oepen et al., 2014), and the dependency graphs extracted from\n828\nCCGbank (Hockenmaier and Steedman, 2007).", 
        "24": "On all data sets, we find that our higher-order parsing models are more accurate than the first-order baseline.", 
        "25": "Experiments also demonstrate the effectiveness of our page binding algorithm.", 
        "26": "Our new parser can be taken as a graph-based parser extended for more general dependency graphs.", 
        "27": "It parallels the state-of-the-art transition-based system of Zhang et al.", 
        "28": "(2016) in performance.", 
        "29": "The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.", 
        "30": "2 Background    2.1 Semantic Dependency Graphs  A dependency graph G = (V,A) is a labeled directed graph for a sentence s = w1, .", 
        "31": ".", 
        "32": ".", 
        "33": ", wn.", 
        "34": "The vertex set V consists of n vertices, each of which corresponds to a word and is indexed by an integer.", 
        "35": "The arc set A represents the labeled dependency relations of the particular analysis G. Specifically, an arc, viz.", 
        "36": "a(i,j,l), represents a dependency relation l from head wi to dependent wj .", 
        "37": "Semantic dependency parsing is the task of mapping a natural language sentence into a formal meaning representation in the form of a dependency graph.", 
        "38": "Figure 1 shows a graph fragment of a noun phrase.", 
        "39": "This semantic graph is grounded on Combinatory Categorial Grammar (CCG; Steedman, 2000), and can be taken as a proxy for predicate\u2013argument structure.", 
        "40": "The graph includes most semantically relevant non-anaphoric local (e.g.", 
        "41": "from \u201cwants\u201d to \u201cMark\u201d) and long-distance (e.g.", 
        "42": "from \u201cbuy\u201d to \u201ccompany\u201d) dependencies.", 
        "43": "2.2 Maximum Subgraph Parsing  Usually, syntactic dependency analysis employs tree-shaped representations.", 
        "44": "Dependency parsing, thus, can be formulated as the search for a maximum spanning tree (MST) of an arc-weighted graph.", 
        "45": "For semantic dependency parsing, where the target representations are not necessarily trees,\nKuhlmann and Jonsson (2015) proposed to generalize the MST model to other types of subgraphs.", 
        "46": "In general, dependency parsing is formulated as the search for Maximum Subgraph for graph class G: Given a graph G = (V,A), find a subset A\u2032 \u2286 A with maximum total weight such that the induced subgraphG\u2032 = (V,A\u2032) belongs to G. Formally, we have the following optimization problem:\nG\u2032(s) = arg max H\u2208G(s,G)\n\u2211 p\u2208H SCOREPART(s, p)\nHere, G(s,G) is the set of all graphs that belong to G and are compatible with s and G. For parsing, G is usually a complete graph.", 
        "47": "SCOREPART(s, p) evaluates the event that a small subgraph p of a candidate graphH is good.", 
        "48": "We define the order of a part according to the number of dependencies it contains, in analogy with tree parsing in terminology.", 
        "49": "Previous work only discussed the first-order case for Maximum Subgraph parsing (Kuhlmann and Jonsson, 2015).", 
        "50": "In this paper, we are also interested in higher-order parsing, with a special focus on factorizations utilizing the following parts:\n.", 
        "51": "dependency single-side neighbors both-side neighbors\nboth-side tri-neighbors\nIf G is the set of projective trees or noncrossing graphs the first-order Maximum Subgraph problem can be solved in cubic-time (Eisner, 1996; Kuhlmann and Jonsson, 2015).", 
        "52": "Unfortunately, these two graph classes are not expressive enough to encode semantic dependency graphs.", 
        "53": "Moreover, this problem for several wellmotivated graph classes, including acyclic or 2- planar graphs, is NP-hard, even if one only considers first-order factorization.", 
        "54": "The lack of appropriate decoding algorithms results in one major challenge for semantic dependency parsing.", 
        "55": "2.3 Book Embedding  This section introduces the basic idea about book embedding from a graph theoretical point of view.", 
        "56": "Definition 1.", 
        "57": "A book is a kind of topological space that consists of a line, called the spine, together with a collection of one or more halfplanes, called the pages, each having the spine as its boundary.", 
        "58": "Definition 2.", 
        "59": "A book embedding of a finite graph G onto a bookB satisfies the following conditions.", 
        "60": "1.", 
        "61": "Every vertex of G is depicted as a point on the spine of B.", 
        "62": "2.", 
        "63": "Every edge of G is depicted as a curve that lies within a single page of B.", 
        "64": "3.", 
        "65": "Every page of B does not have any edge crossings.", 
        "66": "A book embedding separates a graph into several subgraphs, each of which contains all vertices, but only a subset of arcs that are not crossed with each other.", 
        "67": "This kind of graph is named noncrossing dependency graph by Kuhlmann and Jonsson (2015) and planar by Titov et al.", 
        "68": "(2009), Go\u0301mezRodr\u0131\u0301guez and Nivre (2010) and many others.", 
        "69": "We can formalize a semantic dependency graph as a book.", 
        "70": "Take the graph in Figure 1 for example.", 
        "71": "We can separate the edges into two sets and take each set as a single page, as shown in Figure 2.", 
        "72": "Empirically, a semantic dependency graph is sparse enough that it can be that it can be usually embedded onto a very thin book.", 
        "73": "To measure the thickness, we can use pagenumber that is defined as follows.", 
        "74": "Definition 3.", 
        "75": "The book pagenumber of G is the minimum number of pages required for a book embedding of G. We look into the pagenumber of graphs on four linguistic graph banks (as defined in Section 5).", 
        "76": "These corpora are also used for training and evaluating our data-driven parsers.", 
        "77": "The pagenumbers are calculated using sentences in the training sets.", 
        "78": "Table 1 lists the percentages of complete graphs that can be accounted with books of different thickness.", 
        "79": "The percentages of noncrossing graphs, i.e.", 
        "80": "graphs that have pagenumber 1, vary between 48.23% and 78.26%.", 
        "81": "The practical usefulness of the algorithms for computing maximum noncrossing graphs will be limited by the relatively low coverage.", 
        "82": "The class of graphs with pagenumber no more than two has a considerably satisfactory coverage.", 
        "83": "It can account for more than 98% of the graphs and sometimes close to 100% in each data set.", 
        "84": "Unfortunately, the power of Maximum Subgraph parsing is limited given that finding the maximum acyclic subgraph when pagenumber is at most k is NP-hard for k \u2265 2 (Kuhlmann and Jonsson, 2015).", 
        "85": "As an alternative, we propose to model a semantic graph as a book, in which the spine is made up of a sequence of words, and each halfplane contains a subset of dependency arcs.", 
        "86": "To build a semantic graph for a given sentence, we design new parsing algorithms to generate noncrossing graphs on each page (Section 3), and a Lagrangian Relaxation-based algorithm to integrate pages into a book (Section 4).", 
        "87": "3 Maximum Subgraph for Noncrossing Graphs  We introduce several DP algorithms for calculating the maximum noncrossing dependency graphs.", 
        "88": "Each algorithm visits all the spans from bottom to top, finding the best combination of smaller structures to form a new structure, according to the scores of first- or higher-order features.", 
        "89": "For sake of conciseness, we focus on undirected graphs and treat direction of linguistic dependencies as edge labels1.", 
        "90": "We will use e(i,j,l)(i < j) or simply e(i,j) to indicate an edge in either direction\n1 The single-head property does not hold.", 
        "91": "We currently do not consider other constraints of directions.", 
        "92": "So prediction of the direction of one edge does not affect prediction of other edges as well as their directions.", 
        "93": "The directions can be assigned locally, and our parser builds directed rather than undirected graphs in this way.", 
        "94": "Undirected graphs are only used to conveniently illustrate our algorithms.", 
        "95": "All experimental results in Section 5 consider directed dependencies in a standard way.", 
        "96": "We use the official evaluation tool provided by SDP2014 shared task.", 
        "97": "The numberic results reported in this paper are directly comparable to results in other papers.", 
        "98": "between i and j.", 
        "99": "For sake of formal concision, we introduce the algorithm of which the goal is to calculate the maximum score of a subgraph.", 
        "100": "Extracting corresponding optimal graphs can be done in a number of ways.", 
        "101": "For example, we can maintain an auxiliary arc table which is populated parallel to the procedure of obtaining maximum scores.", 
        "102": "We define two score functions: (1) sfst(s, e, l) assigns a score to an individual edge e(s,e,l) and (2) sscd(s, e1, e2, l1, l2) assigns a score to a pair of neighboring edges e(s,e1,l1) and e(s,e2,l2).", 
        "103": "3.1 First-Order Factorization  Given a sentence, we define two DP tables, namely O[s, e] and C[s, e, l] which represents the value of the highest scoring noncrossing graphs that spans sequences of words of a sentence.", 
        "104": "The two tables are related to two sub-problems, as graphically shown in Figure 3.", 
        "105": "The following is their explaination.", 
        "106": "Open O[s, e] is intended to represent the highest weighted subgraph spanning ws to we.", 
        "107": "The subgraphs related to O[s, e] may or may not contain e(s,e).", 
        "108": "Closed C[s, e, l] represents the highest weighted subgraph spanning ws to we too.", 
        "109": "But the subgraphs related to C[s, e, l] must contain e(s,e,l).", 
        "110": "O[s, e] can be obtained by one of the following combinations:\n\u2022 C[s, e, l](l \u2208 L), if there is an edge between s and e with label l.\n\u2022 C[s, k, l] + O[k, e](l \u2208 L, s < k < e), if e(s,e) does not exist and there is an edge with\nlabel l between s and some node in this span.", 
        "111": "k is the farthest node linked to s.\n\u2022 O[s + 1, e], if e(s,e) does not exist and there is no edge to its right in this span.", 
        "112": "C[s, e, l] can be obtained by one of the following combinations:\n\u2022 O[s + 1, e] + sfst(s, e, l), if s has no edge to its right;\n\u2022 C[s, k, l\u2032] +O[k, e] + sfst(s, e, l)(l\u2032 \u2208 L, s < k < e), if there is an edge from s to some node in the span.", 
        "113": "For each edge, there are two directions for the edge, we encode the directions into the label l, and treat it as undirected edge.", 
        "114": "We need to search for a best split and a best label for every span, so the time complexity of the algorithm is O(n3|L|) where n is the length of the sentence and L is the set of labels.", 
        "115": "3.2 Second-Order Single Side Factorization  We propose a new algorithm concerning singleside second-order factorization.", 
        "116": "The DP tables, as well as the decomposition for the open problem, are the same as in the first order factorization.", 
        "117": "The decomposition of C[s, e, l] is very different.", 
        "118": "In order to score second-order features from adjacent edges in the same side, which is similar to sibling features for tree parsing (McDonald and Pereira,\n2006), we need to find the rightmost node adjacent to s, denoted as rs, and the leftmost node adjacent to e, denoted as le, and here we have s < rs \u2264 le < e. And, sometimes, we split C[s, e, l] into three parts to capture the neighbor factors on both endpoints.", 
        "119": "In summary, C[s, e, l] can be obtained by one of the following combination (as graphically shown in Figure 4):\n\u2022 O[s + 1, e \u2212 1] + sfst(s, e, l) + sscd(s, nil, e, nil, l) + sscd(e, nil, s, nil, l), if there is no edge from s/e to any node in the span.", 
        "120": "\u2022 C[s, rs, l\u2032] + O[rs, e \u2212 1] + sfst(s, e, l) + sscd(s, rs, e, l\u2032, l) + sscd(e, nil, s, nil, l) (s < rs < e), if there is no edge from e to any node in the span.", 
        "121": "\u2022 O[s + 1, le] + C[le, e, l\u2032] + sfst(s, e, l) + sscd(e, le, s, l\u2032, l) + sscd(s, nil, e, nil, l) (s < le < e), if there is no edge from s to any node in the span.", 
        "122": "\u2022 C[s, rs, l\u2032] + O[rs, le] + C[le, e, l\u2032\u2032] + sfst(s, e, l) + sscd(s, rs, e, l\u2032, l) + sscd(e, le, s, l\u2032\u2032, l) (s < rs \u2264 le < e), otherwise.", 
        "123": "For the last combination, we need to search for two best separating words, namely sr and le, and two best labels, namely l\u2032 and l\u2032, so the time complexity of this second-order algorithm is O(n4|L|2).", 
        "124": "3.3 Generalized Higher-Order Parsing  Both of the above two algorithms are exact decoding algorithms.", 
        "125": "Solutions allow for exact decoding with higher-order features typically at a high cost in terms of efficiency.", 
        "126": "A trade-off between rich features and exact decoding benefit tree parsing (McDonald and Nivre, 2011).", 
        "127": "In particular, Zhang and McDonald (2012) proposed a generalized higher-order model that abandons exact search in graph-based parsing in favor of freedom in feature scope.", 
        "128": "They kept intact Eisner\u2019s algorithm for first-order parsing problems, while enhanced the scoring function in an approximate way by introducing higher-order features.", 
        "129": "We borrow Zhang and McDonald\u2019s idea and develop a generalized parsing model for noncrossing dependency representations.", 
        "130": "The sub-problems and their decomposition are much like the firstorder algorithm.", 
        "131": "The difference is that we expand\nthe signature of each structure to include all the larger context required to compute higher-order features.", 
        "132": "For example, we can record the leftmost and the rightmost edges in the open structure to get the tri-neighbor features.", 
        "133": "The time complexity is thus always O(n3B2), no matter how complicatedly higher-order features are incorporated.", 
        "134": "We focus on five factors introduced in Section 2.2.", 
        "135": "Still consider single-side second-order factorization.", 
        "136": "We keep the closed structure the same but modify the open one to O[s, e; rs, le, ls,rs , lle,e].", 
        "137": "During parsing, we only record the top-B combinations of label concerning e(s,e) and related rs, le, ls,rs and lle,e.", 
        "138": "The split of a structure is similar to the first-order algorithm, shown in Figure 5.", 
        "139": "Note that rs may be e and le may be s. In this way, we know exactly whether or not there is an edge from s to e in a refined open structure.", 
        "140": "This is different from the intuition of the design of the open structure when we consider first-order factorization.", 
        "141": "4 Finding and Binding Pages  Statistics presented in Table 1 indicate that the coverage of noncrossing dependency graphs is relatively low.", 
        "142": "If we treat semantic dependency parsing as Maximum Subgraph parsing, the practical usefulness of the algorithms introduced above is rather limited accordingly.", 
        "143": "To deal with this problem, we model a semantic graph as a book, and view semantic dependency parsing as finding a book with coherent optimal pages.", 
        "144": "Given the considerably high coverage of pagenumber at most 2, we only consider 2-page books.", 
        "145": "..The .company .that .Mark .wants .to .buy\narg1 arg1 arg2 arg2arg2\narg2\narg1\narg1 arg1 arg1 arg1\narg2\narg1\nFigure 6: Every non-crossing arc is repeatedly assigned to every page.", 
        "146": "4.1 Finding Pages via Coloring  In general, finding the pagenumber of a graph is NP-hard (Go\u0301mez-Rodr\u0131\u0301guez and Nivre, 2010).", 
        "147": "However, it is easy to figure out that the problem is solvable if the pagenumber is at most 2.", 
        "148": "Fortunately, a semantic dependency graph is not so dense that it can be usually embedded onto a very thin book with only 2 pages.", 
        "149": "For a structured prediction problem, the structural information of the output produced by a parser is very important.", 
        "150": "The density of semantic dependency graphs therefore results in a defect: The output\u2019s structural information is limited because only a half of arcs on average are included in one page.", 
        "151": "To enrich the structural information, we put into each page the arcs that do not cross with any other arcs.", 
        "152": "See Figure 6 for example.", 
        "153": "We utilize an algorithm based on coloring to decompose a graph G = (V,A) into two noncrossing subgraphsGA = (V,AB) andGB = (V,AB).", 
        "154": "A detailed description is included in the supplementary note.", 
        "155": "The key idea of our algorithm is to color each crossing arc in two colors using depthfirst search.", 
        "156": "When we color an arc ex, we examine all arcs crossing with ex.", 
        "157": "If one of them, say ey, has not been examined and can be colored in the other color (no crossing arc of ey has the same color with ey), we color ey and then recursively process ey.", 
        "158": "Otherwise, ey is marked as a bad arc and dropped from both AA and AB .", 
        "159": "After coloring all the crossing arcs, we add every arc in different color to different subgraphs.", 
        "160": "Specially, all noncrossing arcs are assigned to both AA and AB .", 
        "161": "4.2 Binding Pages via Lagrangian Relaxation  Applying the above algorithm, we can obtain two corpora to train two noncrossing dependency parsing models.", 
        "162": "In other words, we can learn two score functions fA and fB to score noncrossing\ndependency graphs.", 
        "163": "Given the trained models and a sentence, we can find two optimal noncrossing graphs, i.e.", 
        "164": "find the solutions for arg maxg fA(g) and arg maxg fB(g), respectively.", 
        "165": "We can put all the arcs contained in gA = arg maxg fA(g) and gB = arg maxg fB(g) together as our parse for the sentence.", 
        "166": "This naive combination always gives a graph with a recall much higher than the precision.", 
        "167": "The problem is that a naive combination does not take the agreements of the graphs on the two pages into consideration, and thus loses some information.", 
        "168": "To combine the two pages in a principled way, we must do joint decoding to find two graphs gA and gB to maximize the score fA(gA) + fB(gB), under the following constraints.", 
        "169": "gA(i, j) \u2264 \u2211\ncross((i,j),(i\u2032,j\u2032))\ngB(i \u2032, j\u2032) + gB(i, j)\ngB(i, j) \u2264 \u2211\ncross((i,j),(i\u2032,j\u2032))\ngA(i \u2032, j\u2032) + gA(i, j)\n\u2200i, j The functionality of cross is to figure out whether e(i,j) and e(i\u2032,j\u2032) cross.", 
        "170": "The meaning of the first constraint is: When there is an arc e(i,j) in the first graph, e(i,j) is also in the second graph, or there is an arc e(i\u2032,j\u2032) in the second graph which cross with e(i,j).", 
        "171": "So is the second one.", 
        "172": "All constraints are linear and can be written in a simplified way as,\nAgA +BgB \u2264 0 where A and B are matrices that can be constructed by checking all possible crossing arc pairs.", 
        "173": "In summary, we have the following constrained optimization problem,\nmin.", 
        "174": "\u2212fA(gA)\u2212 fB(gB) s.t.", 
        "175": "gA, gB are noncrossing graphs\nAgA +BgB \u2264 0 The Lagrangian of the optimization problem is\nL(gA, gB;u) = \u2212fg(gA)\u2212 ft(gB) + u\u22a4(AgA +BgB)\nwhere u is the Lagrangian multiplier.", 
        "176": "Then the dual is\nL(u) = min gA,gB L(gA, gB;u)\n= max gA\n(fg(gA)\u2212 u\u22a4AgA)\n+max gB\n(fy(gB)\u2212 u\u22a4BgB)\nWe instead try to find the solution for maxu L(u).", 
        "177": "By using a subgradient method to calculate maxu L(u), we have an algorithm for joint decoding (see Figure 7).", 
        "178": "L(u) is divided into two optimization problems which can be decoded easily.", 
        "179": "Each sub-problem is still a parsing problem for noncrossing graphs.", 
        "180": "Only the scores of factors are modified (see Line 3 and 4).", 
        "181": "Specifically, to modify the first order weights of edges, we take a subtraction of u\u22a4A in the first model and a substraction of u\u22a4B in the second one.", 
        "182": "In each iteration, after obtaining two new parsing results, we check whether the constraints are satisfied.", 
        "183": "If the answer is \u201cyes,\u201d we stop and return the merged graph.", 
        "184": "Otherwise, we update u in a way to increase L(u) (see Line 8).", 
        "185": "5 Experiments    5.1 Data Sets  To evaluate the effectiveness of book embedding in practice, we conduct experiments on unlabeled parsing using four corpora: CCGBank (Hockenmaier and Steedman, 2007), DeepBank (Flickinger et al., 2012), Enju HPSGBank (EnjuBank; Miyao et al., 2004) and Prague Dependency TreeBank (PCEDT; Hajic et al., 2012), We use \u201cstandard\u201d training, validation, and test splits to facilitate comparisons.", 
        "186": "Following previous experimental setup for CCG parsing, we use section 02-21 as training data, section 00 as the development data, and section 23 for testing.", 
        "187": "The other three data sets are from SemEval 2014 Task 8 (Oepen et al., 2014), and the data splitting policy follows the shared task.", 
        "188": "All the four data sets are publicly available from LDC (Oepen et al., 2016).", 
        "189": "Experiments for CCG analysis were performed using automatically assigned POS-tags generated by a symbol-refined HMM tagger (Huang et al.,\n2010).", 
        "190": "For the other three data sets we use POStags provided by the shared task.", 
        "191": "We also use features extracted from trees.", 
        "192": "We consider two types of trees: (1) syntactic trees provided as a companion analysis by the shared task and CCGBank, (2) pseudo trees (Zhang et al., 2016) automatically extracted from semantic dependency annotations.", 
        "193": "We utilize the Mate parser (Bohnet, 2010) to generate pseudo trees for all data sets and also syntactic trees for CCG analysis, and use the companion syntactic analysis provided by the shared task for the other three data sets.", 
        "194": "5.2 Statistical Disambiguation  Our parsing algorithms can be applied to scores originated from any source, but in our experiments we chose to use the framework of global linear models, deriving our scores as:\nSCOREPART(s, p) = w\u22a4\u03d5(s, p)\n\u03d5 is a feature-vector mapping and w is a parameter vector.", 
        "195": "p may refer to a single arc, a pair of neighboring arcs, or a general tuple of arcs, according to the definition of a parsing model.", 
        "196": "For details we refer to the source code.", 
        "197": "We chose the averaged structured perceptron (Collins, 2002) for parameter estimation.", 
        "198": "5.3 Results of Practical Parsing  We evaluate five decoding algorithms:\nM1 first-order exact algorithm,\nM2 second-order exact algorithm with singleside factorization,\nM3 second-order approximate algorithm2 with single-side factorization,\nM4 second-order approximate algorithm with single- and both-side factorization,\nM5 third-order approximate algorithm with single- and both-side factorization.", 
        "199": "5.3.1 Effectiveness of Higher-Order Features  Table 2 lists the accuracy of Maximum Subgraph parsing.", 
        "200": "The output of our parser was evaluated against each dependency in the corpus.", 
        "201": "We report unlabeled precision (UP), recall (UR) and f-score (UF).", 
        "202": "We can see that the first-order model obtains a considerably good precision, with rich features.", 
        "203": "2The beam size is set to 4 for all approximate algorithms.", 
        "204": "But due to the low coverage of the noncrossing dependency graphs, a set of dependencies can not be built.", 
        "205": "This property has a great impact on recall.", 
        "206": "Furthermore, we can see that the introduction of higher-order features improves parsing substantially for all data sets, as expected.", 
        "207": "When pseudo trees are utilized, the improvement is marginal.", 
        "208": "We think the reason is that we have already included many higher-order features at the stage of pseudo tree parsing.", 
        "209": "5.3.2 Effectiveness of Approximate Parsing  Perhaps surprisingly approximate parsing with single-side second order features and cube pruning is even slightly better than exact parsing.", 
        "210": "This result demonstrates the effectiveness of generalized dependency parsing.", 
        "211": "Further including third-order features does not improve parsing accuracy.", 
        "212": "5.3.3 Effectiveness of Page Binding  When arcs are assigned to two sets, we can separately train two parsers for producing two types of noncrossing dependency graphs.", 
        "213": "These two parsers can be integrated using a naive merger or a LR-based merger.", 
        "214": "Table 2 also shows the accuracy obtained by the second-order model M4.", 
        "215": "The effectivenss of the Lagrangian Relaxation-based algorithm for binding pages is confirmed.", 
        "216": "5.3.4 Termination Rate of Page Binding  Figure 8 presents the termination rate with respective to the number of iterations.", 
        "217": "Here we apply M4 with syntax and pseudo tree features.", 
        "218": "In practice the Lagrangian Relaxation-based algorithm finds solutions in a few iterations for a majority of sentences.", 
        "219": "This suggests that even though the joint decoding is an iterative procedure, satisfactory efficiency is still available.", 
        "220": "5.4 Comparison with Other Parsers  We show the parsing results on the test data together with some relevant results from related work.", 
        "221": "We compare our parser with two other systems: (1) ZDSW (Zhang et al., 2016) is a transition-based system that obtains state-of-theart accuracy; we present the results of their best single parsing model; (2) Peking (Du et al., 2014) is the best-performing system in the shared task; it is a hybrid system that integrate more than ten submodels to achieve high accuracy.", 
        "222": "Our parser can be taken as a graph-based parser.", 
        "223": "It reaches stateof-the-art performance produced by the transitionbased system.", 
        "224": "On DeepBank and EnjuBank, the accuracy of our parser is equivalent to ZDSW, while on CCGBank, our parser is significantly better.", 
        "225": "There is still a gap between our single parsing model and Peking hybrid model.", 
        "226": "For a majority of NLP tasks, e.g.", 
        "227": "parsing (Surdeanu and Manning, 2010), semantic role labeling (Koomen et al., 2005), hybrid systems that combines complementary strength of heterogeneous models perform better.", 
        "228": "But good individual system is the cornerstone of hybrid systems.", 
        "229": "Better design of single system almost always benefits system ensemble.", 
        "230": "6 Conclusion  We propose a new data-driven parsing framework, namely book embedding, for semantic dependency analysis, viz.", 
        "231": "mapping from natural language sentences to bilexical semantic dependency graphs.", 
        "232": "Our work includes two contributions:\n1. new algorithms for maximum noncrossing dependency parsing.", 
        "233": "2. a Lagrangian Relaxation based algorithm to combine noncrossing dependency subgraphs.", 
        "234": "Experiments demonstrate the effectiveness of the book embedding framework across a wide range of conditions.", 
        "235": "Our graph-based parser obtains state-of-the-art accuracy.", 
        "236": "Acknowledgments  This work was supported by 863 Program of China (2015AA015403), NSFC (61331011), and Key Laboratory of Science, Technology and Standard in Press Industry (Key Laboratory of Intelligent Press Media Technology).", 
        "237": "XiaojunWan is the corresponding author."
    }, 
    "document_id": "P17-1077.pdf.json"
}
