{
    "abstract_sentences": {
        "1": "We present a simple encoding for unlabeled noncrossing graphs and show how its latent counterpart helps us to represent several families of directed and undirected graphs used in syntactic and semantic parsing of natural language as contextfree languages.", 
        "2": "The families are separated purely on the basis of forbidden patterns in latent encoding, eliminating the need to differentiate the families of non-crossing graphs in inference algorithms: one algorithm works for all when the search space can be controlled in parser input."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1745\u20131755 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1160  1 Introduction  Dependency parsing has received wide attention in recent years, as accurate and efficient dependency parsers have appeared that are applicable to many languages.", 
        "2": "Traditionally, dependency parsers have produced syntactic analyses in tree form, including exact inference algorithms that search for maximum projective trees (Eisner and Satta, 1999) and maximum spanning trees (McDonald et al., 2005) in weighted digraphs, as well as greedy and beamsearch approaches that forgo exact search for extra efficiency (Zhang and Nivre, 2011).", 
        "3": "Recently, there has been growing interest in providing a richer analysis of natural language by going beyond trees.", 
        "4": "In semantic dependency parsing (Oepen et al., 2015; Kuhlmann and Oepen, 2016), the desired syntactic representations can have indegree greater than 1 (re-entrancy), suggesting the search for maximum acyclic subgraphs (Schluter, 2014, 2015).", 
        "5": "As this inference task is intractable (Guruswami et al., 2011), noncrossing digraphs have been studied instead, e.g.", 
        "6": "by Kuhlmann and Johnsson (2015) who provide a O(n3) parser for maximum noncrossing acyclic subgraphs.", 
        "7": "Yli-Jyra\u0308 (2005) studied how to axiomatize dependency trees as a special case of noncrossing digraphs.", 
        "8": "This gave rise to a new homomorphic representation of context-free languages that proves the classical Chomsky and Schu\u0308tzenberger theorem using a quite different internal language.", 
        "9": "In this language, the brackets indicate arcs in a dependency tree in a way that is reminiscent to encoding schemes used earlier by Greibach (1973) and Oflazer (2003).", 
        "10": "Cubic-time parsing algorithms that are incidentally or intentionally applicable to this kind of homomorphic representations have been considered, e.g., by Nederhof and Satta (2003), Hulden (2011), and Yli-Jyra\u0308 (2012).", 
        "11": "Extending these insights to arbitrary noncrossing digraphs, or to relevant families of them, is far from obvious.", 
        "12": "In this paper, we develop (1) a linear encoding supporting general noncrossing digraphs, and (2) show that the encoded noncrossing digraphs form a context-free language.", 
        "13": "We then give it (3) two homomorphic, nonderivative representations and use the latent local features of the latter to characterize various families of digraphs.", 
        "14": "Apart from the obvious relevance to the theory of context-free languages, this contribution has the practical potential to enable (4) generic contextfree parsers that produce different families of noncrossing graphs with the same set of inference rules while the search space in each case is restricted with lexical features and the grammar.", 
        "15": "Outline After some background on graphs and parsing as inference (Section 2), we use an ontology of digraphs to illustrate natural families of noncrossing digraphs in Section 3.", 
        "16": "We then develop, in Section 4, the first latent contextfree representation for the set of noncrossing digraphs, then extended in Section 5 with additional latent states supporting our finite-state axiomatization of digraph properties, and allowing us to\n1745\ncontrol the search space using the lexicon.", 
        "17": "The experiments in Section 6 cross-validate our axioms and sample the growth of the constrained search spaces.", 
        "18": "Section 7 outlines the applications for practical parsing, and Section 8 concludes.", 
        "19": "2 Background  Graphs and Digraphs A graph is a pair (V,E) where V is a finite set of vertices and E \u2286 {{u,v} \u2286 V} is a set of edges.", 
        "20": "A sequence of edges of the form {v0,v1}, {v1,v2}, ..., {vm\u22121,vm}, with no repetitions in v1, ...,vm, is a path between vertices v0 and vm and empty if m = 0.", 
        "21": "A graph is a forest if no vertex has a non-empty path to itself and connected if all pairs of vertices have a path.", 
        "22": "A tree is a connected forest.", 
        "23": "A digraph is a pair (V,A) where A \u2286 V \u00d7V is a set of arcs u\u2192 v, thus a directed graph.", 
        "24": "Its underlying graph, (V,EA), has edges EA = {{u,v} | (u,v) \u2208 A}.", 
        "25": "A sequence of arcs v0 \u2192 v1,v1 \u2192 v2, ...,vm\u22121\u2192 vm, with no repetitions in v1, .", 
        "26": ".", 
        "27": ".", 
        "28": ",vm, is a directed path, and empty if m = 0.", 
        "29": "A digraph without self-loops v\u2192 v is loop-free (property DIGRAPHLF).", 
        "30": "We will focus on loopfree digraphs unless otherwise specified, and denote them just by DIGRAPH for brevity.", 
        "31": "A digraph is d-acyclic (ACYCD), aka a dag if no vertex has a non-empty directed path to itself, uacyclic (ACYCU) aka a m(ixed)-forest if its underlying graph is a forest, and weakly connected (w.c., CONNW) if its underlying graph is connected.", 
        "32": "Dependency Parsing The complete digraph GS(V,A) of a sentence S = x1...xn consists of vertices V = {1, ...,n} and all possible arcs A = V \u00d7 V \u2212{(i, i)}.", 
        "33": "The vertex i \u2208 V corresponds to the word xi and the arc i \u2192 j \u2208 A corresponds to a possible dependency between the words xi and x j.", 
        "34": "The task of dependency parsing is to find a constrained subgraph G\u2032S(V,A\n\u2032) of the complete digraph GS of the sentence.", 
        "35": "The standard solution is a rooted directed tree called a dependency tree or a dag called a dependency graph.", 
        "36": "Constrained Inference In arc-factored parsing (McDonald et al., 2005), each possible arc i\u2192 j is equipped with a positive weight wi j, usually computed as a weighted sum wi j = w \u00b7\u03a6(S, i \u2192 j) where w is a weight vector and \u03a6(x, i\u2192 j) a feature vector extracted from the sentence x, considering the dependency relation from word xi to word x j. Parsing then consists in finding an arc\nsubset A\u2032 \u2286 A that gives us a constrained subgraph (V,A\u2032) \u2208 Constrained(V,A) of the complete digraph (V,A) with maximum sum of arc weights:\n(V,A\u2032) = argmax (V,A\u2032) \u2208 Constrained(V,A) \u2211 i\u2192 j\u2208A\u2032 wi, j.", 
        "37": "The complexity of this inference task depends on the constraints imposed on the subgraph.", 
        "38": "Under no constraints, we simply set A\u2032 = A.", 
        "39": "Inference over dags is intractable (Guruswami et al., 2011).", 
        "40": "Efficient solutions are known for projective trees (Eisner, 1996), various classes of mildly nonprojective trees (Go\u0301mez-Rodr\u0131\u0301guez, 2016), unrestricted spanning trees (McDonald et al., 2005), and both unrestricted and weakly connected noncrossing dags (Kuhlmann and Johnsson, 2015).", 
        "41": "Parsimony Semantic parsers must be able to produce more than projective trees because the share of projective trees is pretty low (under 3%) in semantic graph banks (Kuhlmann and Johnsson, 2015).", 
        "42": "However, if we know that the parses have some restrictions, it is better to use them to restrict the search space as much as possible.", 
        "43": "There are two strategies for reducing the search space.", 
        "44": "One is to develop a specialized inference algorithm for a particular natural language or family of dags, such as weakly connected graphs (Kuhlmann and Johnsson, 2015).", 
        "45": "The other strategy is to control the local complexity of digraphs through lexical categories (Baldridge and Kruijff, 2003) or equivalent mechanisms.", 
        "46": "This strategy produces a more sensitive model of the language, but requires a principled insight on how the complexity of digraphs can be characterized.", 
        "47": "3 Constraints on the Search Space  We will now present a classification of digraphs on the basis of their formal properties.", 
        "48": "The Noncrossing Property For convenience, graphs and digraphs may be ordered like in a complete digraph of a sentence.", 
        "49": "Two edges {i, j}, {k, l} in an ordered graph or arcs i \u2192 j,k \u2192 l in an ordered digraph are said to be crossing if min{i, j} < min{k, l} < max{i, j} < max{k, l}.", 
        "50": "A graph or digraph is noncrossing if it has no crossing edges or arcs.", 
        "51": "Noncrossing (di)graphs (NC-(DI)GRAPH) are the largest possible (di)graphs that can be drawn on a circle without crossing arcs.", 
        "52": "In the following, we assume that all digraphs and graphs are noncrossing.", 
        "53": "An arc x\u2192 y is (properly) covered by an arc z\u2192 t if ({x,y} 6= {z, t}) and min{z, t} \u2264 min{x,y} \u2264 max{x,y} \u2264max{z, t}.", 
        "54": "Ontology Fig.", 
        "55": "1 presents an ontology of such families of loop-free noncrossing digraphs that can be distinguished by digraphs with 5 vertices.", 
        "56": "In the digraph ontology, a multitree aka mangrove is a dag with the property of being strongly unambiguous (UNAMBS), which asserts that, given two distinct vertices, there is at most one repeat-free path between them (Lange, 1997).1 A polytree (Rebane and Pearl, 1987) is a multitree whose underlying graph is a tree.", 
        "57": "The out property (OUT) of a digraph (V,E) means that no vertex i \u2208V has two incoming arcs { j,k}\u2192 i s.t.", 
        "58": "j 6= k.\nNC-DIGRAPH +5460\nCONNW +43571 UNAMBS +80 ORIENTED +140\nACYCU +1200 OUT +10 w.c.unamb.", 
        "59": "+600\nw.c.or.", 
        "60": "+1160 unamb.or.", 
        "61": "+80 ACYCD +840\nout oriented +130 out m-forest +435 mixed tree +3355\nmultitree +10 w.c.dag +2960 w.c.unamb.or.", 
        "62": "+370\nout mixed tree +220\nw.c. out oriented +132\nw.c.multitree +50 or.forest +300\npolytree +605 out or.forest +481\nout or.tree +275\nFigure 1: Basic properties split the set of 62464 noncrossing digraphs for 5 vertices into 23 classes\nAn ordered digraph is weakly projective (PROJW) if for all vertices i, j and k, if k\u2192 j\u2192 i, then either {i, j}< k or {i, j}> k. In other words, the constraint, aka the outside-to-inside constraint (Yli-Jyra\u0308, 2005), states that no outgoing arc of a vertex properly covers an incoming arc.", 
        "63": "This is implied by a stronger constraint known as Harper, Hays, Lecerf and Ihm projectivity (Marcus, 1967).", 
        "64": "We can embed the ontology of graphs (unrestricted, connected, forests and trees) into the ontology of digraphs by viewing an undirected graph (V,E) as an inverse digraph (V,{(i, j),( j, i) | {i, j} \u2208 E}).", 
        "65": "This kind of digraph has an inverse property (INV).", 
        "66": "Its opposite is an oriented (or.)", 
        "67": "digraph (V,A) where i\u2192 j \u2208 A implies j \u2192 i /\u2208 A (defines the property ORIENTED).", 
        "68": "Out forests and trees are, by convention, oriented digraphs with an underlying forest or tree, respectively.", 
        "69": "1A different definition forbids diamonds as minors.", 
        "70": "Distinctive Properties A few important properties of digraphs are local and can be verified by inspecting each vertex separately with its incident arcs.", 
        "71": "These include (i) the out property (OUT), (ii) the nonstandard projectivity property (PROJW), (iii) the inverse property (INV) and (iv) the orientedness (or.)", 
        "72": "property.", 
        "73": "Properties UNAMBS, ACYCD, CONNW, and ACYCU are nonlocal properties of digraphs and cannot be generally verified locally, through finite spheres of vertices (Gra\u0308del et al., 2005).", 
        "74": "The following proposition covers the configurations that we have to detect in order to decide the nonlocal properties of noncrossing digraphs.", 
        "75": "Proposition 1.", 
        "76": "Let G = (V,E) be a noncrossing digraph.", 
        "77": "\u2022 If G /\u2208 UNAMBS, then the digraph contains one of the following four configurations or their reversals:\nu v y u v y u v y u v x y\n\u2022 If G /\u2208 ACYCD, then the graph contains one of the configurations\nu v y u v y u v\n\u2022 If G /\u2208 ACYCU, then the underlying graph contains the following configuration:\nu v y\n\u2022 If G /\u2208 CONNW, then the underlying graph contains one of the following configurations:\n... v y ...\nno arc no arc\n... v ...\nno arc no arc\nProposition 1 gives us a means to implement the property tests in practice.", 
        "78": "It tells us intuitively that although the paths can be arbitrarily long, any underlying cycle containing more than 2 arcs consists of one covering arc and a linear chain of edges between its end points.", 
        "79": "4 The Set of Digraphs as a Language  In this section, we show that the set of noncrossing digraphs is isomorphic to an unambiguous context-free language over a bracket alphabet.", 
        "80": "4.1 Basic Encoding  Any noncrossing ordered graph ([1, ...,n],E), even with self-loops, can be encoded as a string of brackets using the algorithm enc in Fig.", 
        "81": "2.", 
        "82": "For example, the output for the ordered graph\nfunc enc(n,E): func dec(stdin): for i in [1,...,n]: n = 1; E = {}; s = []\nfor j in [i-1,...,2,1]: while c in stdin: if {j,i} in E: if c == \"[\": print \"]\" s.push(n) for j in [n,n-1,...,i+1]: if c == \"]\":\nif {i,j} in E: i = s.pop() print \"[\" E.insert((i,n))\nif {i,i} in E: if c == \"{\": print \"[]\" n = n + 1 if i<n: print \"{}\" return (n,E)\nis the string [[{}][[]{}{}]].", 
        "83": "Intuitively, pairs of brackets of the form {} can be interpreted as spaces between vertices, and then each set of matching brackets [...] encodes an arc that covers the spaces represented inside the brackets.", 
        "84": "Any noncrossing ordered digraph ([1, .", 
        "85": ".", 
        "86": ".", 
        "87": ",n],A) can be encoded with slight modifications to the algorithm.", 
        "88": "Instead of printing [ ] for an edge {i, j} \u2208 EA, i\u2264 j, the algorithm should now print\n/ > if (i, j) \u2208 A,( j, i) 6\u2208 A; < / if (i, j) /\u2208 A,( j, i) \u2208 A; [ ] if (i, j),( j, i) \u2208 A.", 
        "89": "In this way, we can simply encode the digraph ({1,2,3,4},{(1,2),(2,2),(4,1),(4,2)}) as the string </{}><[]{}{}//.", 
        "90": "Proposition 2.", 
        "91": "The encoding respects concatenation where the adjacent nonempty operands have a common vertex.", 
        "92": "Context-Freeness Arbitrary strings with balanced brackets form a context-free language that is known, generically, as a Dyck language.", 
        "93": "It is easy to see that the graphs NC-GRAPH are encoded with strings that belong to the Dyck language D2 generated by the context-free grammar: S\u2192 [S]S | {S}S | \u03b5 .", 
        "94": "The encoded graphs, LNC-GRAPH, are, however, generated exactly by the context-free grammar S \u2192 [S\u2032] S | {} S | \u03b5 , S\u2032\u2192 [S\u2032] T | {} S, T \u2192 [S\u2032] S | {} S. This language is an unambiguous context-free language.", 
        "95": "Proposition 3.", 
        "96": "The encoded graphs, LNC-GRAPH, make an unambiguous context-free language.", 
        "97": "The practical significance of Proposition 3 is that there is a bijection between LNC-GRAPH and the derivation trees of a context-free grammar.", 
        "98": "4.2 Bracketing Beyond the Encoding  Non-Derivational Representation A nonderivational representation for any context-free\nlanguage L has been given by Chomsky and Schu\u0308tzenberger (1963).", 
        "99": "This replaces the stack with a Dyck language D and the grammar rules with co-occurrence patterns specified by a regular language Reg.", 
        "100": "To hide the internal alphabet from the strings of the represented language, there is a homomorphism that cleans the internal strings of Reg and D from internal markup to get actual strings of the target language:\nLNC-GRAPH = h(D\u2229Reg).", 
        "101": "To make this concrete, replace the previous context free grammar by S\u2032\u2032 \u2192 [\u2032S\u2032]\u2032 S | {} S | \u03b5 , S\u2192 [S\u2032] S | {} S | \u03b5 , S\u2032\u2192 [\u2032S\u2032]\u2032 T | {} S, T \u2192 [S\u2032] S | {} S. The homomorphism h (Fig.", 
        "102": "3a) would now relate this language to the original language, mapping the string [\u2032[\u2032{}]\u2032[[\u2032{}]\u2032{}]]\u2032 to the string [[{}][[{}]{}]], for example.", 
        "103": "The Dyck language D = D3 checks that the internal brackets are balanced, and the regular component Reg (Fig.", 
        "104": "3b) checks that the new brackets are used correctly.", 
        "105": "A similar representation for the language LNC-DIGRAPH of encoded digraphs can be obtained with straightforward extensions.", 
        "106": "The representation L = h(D \u2229 Reg) is unambiguous if, for every word w \u2208 L, the preimage h\u22121(w)\u2229D\u2229Reg is a single string.", 
        "107": "This implies that L is an unambiguous context-free language.", 
        "108": "Proposition 4.", 
        "109": "The set of encoded digraphs, LNC-DIGRAPH, has an unambiguous representation.", 
        "110": "Proposition 5.", 
        "111": "Let Li = h(D\u2229 Ri), i \u2208 {0,1,2} be unambiguous representations with R1,R2 \u2286 R0.", 
        "112": "Then L3 = h(D\u2229 (R1 \u2229 R2)) is an unambiguous context-free language and the same as L1\u2229L2.", 
        "113": "Proof.", 
        "114": "It is immediate that L3 \u2286 L1\u2229L2 and L3 is an unambiguous context-free language.", 
        "115": "To show that L1 \u2229 L2 \u2286 L3, take an arbitrary s \u2208 L1 \u2229 L2.", 
        "116": "Since R1,R2 \u2286 R0 there is a unique s\u2032 \u2208 h\u22121(s) such that s\u2032 \u2208 D\u2229 (R1\u2229R2).", 
        "117": "Thus s \u2208 L3.", 
        "118": "5 Latent Bracketing  In this section, we extend the internal strings of the non-derivational representation of LNC-DIGRAPH in\nsuch a way that the configurations given in Proposition 1 can be detected locally from these.", 
        "119": "Classification of Underlying Chains A maximal linear chain is a maximally long sequence of one or more edges that correspond to an underlying left-to-right path in the underlying graph in such a way that no edge in this chain is properly covered by an edge that does not properly cover all the edges in the chain.", 
        "120": "For example, the graph\n[\u2032[\u2032{}]\u2032[[\u2032{}]\u2032[{}]][[\u2032{}]\u2032{}[{}]]]\u2032[{}[{ }]{}]\nI\nII III\nII III\nII I\nIV V VI\ncontains six maximal linear chains, indicated with their Roman numbers on each arc.", 
        "121": "We decide nonlocal properties of noncrossing digraphs by recognizing maximal linear chains as parts of configurations presented in Proposition 1.", 
        "122": "Every loose chain (like V and VI) starts with a bracket that is adjacent to a }-bracket.", 
        "123": "Such a chain can contribute only a covering edge to an underlying cycle.", 
        "124": "In contrast, a bracket with an apostrophe marks the beginning of a non-loose chain that can either start at the first vertex, or share starting point with a covering chain.", 
        "125": "When a nonloose chain is covered, it can be touched twice by a covering edge.", 
        "126": "The prefixes of chains are classified incrementally, from left to right, with a finite automaton (Figure 4).", 
        "127": "All states of the automaton are final and correspond to distinct classes of the chains.", 
        "128": "These classes are encoded to an extended set of brackets.", 
        "129": "The automaton is symmetric: states with uppercase names are symmetrically related with\ncorresponding lowercase states.", 
        "130": "Thus, it suffices to define the initial and uppercase-named states:\n0 the initial state for a non-loose chain; I a bidirectional chain: u\u2194 (v\u2194)y; A a primarily bidirectional forward chain: u\u2194 v\u2192 y; F a forward chain: u\u2192 v\u2192 y; Q a primarily forward chain: u\u2192 v\u2194 (\u00b7 \u00b7 \u00b7 \u2192)y; C a primarily forward 1-turn chain: u\u2192 v\u2190 y; E a primarily forward 2-turn chain: u\u2192 v\u2190 x\u2192 y; Z a 3-turn chain; 1 the initial (and only) state for a loose chain;\nRecognition of ambiguous paths in configurations u \u2212\u2212\u2212\u2212\u2212\u2192\u2190\u2212\u2212\u2192\u2192v\u2190y and u\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192\u2190\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2190 v\u2192 x\u2190\u2190y involves three chain levels.", 
        "131": "To support the recognition, subtypes of edges are defined according to the chains they cover.", 
        "132": "The brackets >I\u2019, \\I\u2019, >I, \\I, \\A, >a, \\Q, >Q, >q,\\q, >C, \\c, \\E, >e indicate edges that constitute a cycle with the chain they cover.", 
        "133": "The brackets >V\u2019, \\v\u2019, >V, \\v indicate edges that cover 2-turn chains.", 
        "134": "Not all states make these distinctions.", 
        "135": "Extended Representation The extended brackets encode the latent structure of digraphs: the orientation and the subtype of the edge and the class of the chain.", 
        "136": "The total alphabet \u03a3 of the strings now contains the boundary brackets {} and 54 pairs of brackets (Figure 4) for edges from which we obtain a new Dyck language, D55, and an extended homomorphism hlat.", 
        "137": "The Reg component of the language representation is replaced with Reglat, that is, an intersection of (1) an inverse homomorphic image of Reg to strings over the extended alphabet, (2) a local language that constrains adjacent edges according to Figure 4, (3) a local language specifying how the chains start, and (4) a local language that distinguishes pure oriented edges from those that cover a cycle or a 2-turn chain.", 
        "138": "The new component requires only 24 states as a deterministic automaton.", 
        "139": "Proposition 6. hlat(D55\u2229Reglat) is an unambiguous representation for LNC-DIGRAPH.", 
        "140": "The internal language LNC-DIGRAPHlat = D55 \u2229 Reglat is called the set of latent encoded digraphs.", 
        "141": "Example Here is a digraph with its latent encoding:\n<f\u2032 [I\u2032\ufe38 \ufe37\ufe37 \ufe38 1 {}]I\u2032 /0 /F\u2032\ufe38 \ufe37\ufe37 \ufe38 2 {} >F\u2032\ufe38\ufe37\ufe37\ufe38 3 {} <.\ufe38\ufe37\ufe37\ufe38 4 {} /.\ufe38\ufe37\ufe37\ufe38 5 {} >.\ufe38\ufe37\ufe37\ufe38 6 {}/.", 
        "142": ">0 /f\u2032\ufe38 \ufe37\ufe37 \ufe38 7 The brackets in the extended representation contain information that helps us recognize, through local patterns, that this graph has a directed cycle\n(directed path 1\u2192 2\u2192 7\u2192 1), is strongly ambiguous (two directed paths 2\u2192 1 and 2\u2192 7\u2192 1) and is not weakly connected (vertices 5 and 6 are not connected to the rest of the digraph).", 
        "143": "Expressing Properties via Forbidden Patterns We now demonstrate that all the mentioned nonlocal properties of graphs have become local in the extended internal representation of the code strings LNC-DIGRAPH for noncrossing digraphs.", 
        "144": "These distinctive properties of graph families reduce to forbidden patterns in bracket strings and then compile into regular constraint languages.", 
        "145": "These are presented in Table 1.", 
        "146": "To keep the patterns simple, subsets of brackets are defined:\nL/ [-,/-brackets L< [-,<-brackets R> ]-,>-brackets R/ ]-,\\-brackets B {, } R R>\u222aR\\ Rloose }, >., /., ].", 
        "147": "Rloose R\u2212Rloose Rright R reaching F,Q,I,A Rleft R reaching f,q,i,a Rright2 >P, >2, >E, \\E, ]E Rleft2 \\p, \\2, \\e, >e, ]e \u03a3in L<\u222aR> B \u03a3\u2212B Rvergent non-\u2019 R reaching I,Q,q,A,a,C,c \u03a3or all brackets for oriented edges \u03a3inv all brackets for inverted edges  6 Validation Experiments  The current experiments were designed (1) to help in developing the components of Reglat and the constraint languages of axiomatic properties, (2) to validate the representation, the constraint languages and their unambiguity, (3) to learn about the ontology and (4) to sample the integer sequences associated with the cardinality of each\nfamily in the ontology.", 
        "148": "Finding the Components Representations of Reglat were built with scripts written using a finitestate toolkit (Hulden, 2009) that supports rapid exploration with regular languages and transducers.", 
        "149": "Validation of Languages Our scripts presented alternative approaches to compute languages of encoded digraphs with n vertices up to n = 9.", 
        "150": "We also implemented a Python script that enumerated elements of families of graphs up to n = 6.", 
        "151": "The solutions were used to cross-validate one another.", 
        "152": "The constraint Gn = B \u2217 ({}B\u2217)n\u22121 ensures nvertices in encoded digraphs.", 
        "153": "The finite set of encoded acyclic 5-vertex digraphs was computed with a finite-state approach (Yli-Jyra\u0308 et al., 2012) that takes the input projection of the composition\nId(Reglat\u2229AD\u2229G5)\u25e6T55\u25e6T55\u25e6T55\u25e6T55\u25e6T55\u25e6 Id(\u03b5)\nwhere Id defines an identity relation and transducer T55 eliminates matching adjacent brackets.", 
        "154": "This composition differs from the typical use where the purpose is to construct a regular relation (Kaplan and Kay, 1994) or its output projection (Roche, 1996; Oflazer, 2003).", 
        "155": "For digraphs with a lot of vertices, we had an option to employ a dynamic programming scheme (Yli-Jyra\u0308, 2012) that uses weighted transducers.", 
        "156": "Building the Ontology To build the ontology in Figure 1 we first found out which combinations of digraph properties co-occur to define distinguishable families of digraphs.", 
        "157": "After the nodes of the\nlattice were found, we were able to see the partial order between these.", 
        "158": "Integer Sequences We sampled, for important families of digraphs, the prefixes of their related integer sequences.", 
        "159": "We found out that each family of graphs is pretty much described by its cardinality, see Table 2.", 
        "160": "In many cases, the number sequence was already well documented (OEIS Foundation Inc., 2017).", 
        "161": "7 The Formal Basis of Practical Parsing  While presenting a practical parser implementation is outside of the scope of this paper, which focuses in the theory, we outline in this section the aspects to take into account when applying our representation to build practical natural language parsers.", 
        "162": "Positioned Brackets In order to do inference in arc-factored parsing, we incorporate weights to the representation.", 
        "163": "For each vertex in Gn, the brackets are decorated with the respective position number.", 
        "164": "Then, we define an input-specific grammar representation where each pair of brackets in D gets an arc-factored weight given the directions and the vertex numbers associated with the brackets.", 
        "165": "Grammar Intersection We associate, to each Gn, a quadratic-size context-free grammar that generates all noncrossing digraphs with n vertices.", 
        "166": "This grammar is obtained by computing (or even precomputing) the intersection D55 \u2229 Reglat \u2229Gn in any order, exploiting the closure of contextfree languages under intersection with regular languages (Bar-Hillel et al., 1961).", 
        "167": "The introduction of the position numbers and weights in the Dyck language gives us, instead, a weighted grammar and its intersection (Lang, 1994).", 
        "168": "This grammar is a compact representation for a finite set of weighted latent encoded digraphs.", 
        "169": "Additional constraints during the intersection tailors the grammar to different families of digraphs.", 
        "170": "Dynamic Programming The heaviest digraph is found with a dynamic programming algorithm that computes, for each nonterminal in the grammar, the weight of the heaviest subtree.", 
        "171": "A careful reader may notice some connections to Eisner algorithm (Eisner and Satta, 1999), context-free parsing through intersection (Nederhof and Satta, 2003), and a dynamic programming scheme that\nuses contracting transducers and factorized composition (Yli-Jyra\u0308, 2012).", 
        "172": "Unfortunately, space does not permit discussing the connections here.", 
        "173": "Lexicalized Search Space In practical parsing, we want the parser behavior and the dependency structure to be sensitive to the lexical entries or features of each word.", 
        "174": "We can replace the generic vertex description B\u2217 in Gn with subsets that depend on respective lexical entries.", 
        "175": "Graphical constraints can be applied to some vertices but relaxed for others.", 
        "176": "This application of current results gives a principled, graphically motivated solution to lexicalized control over the search space.", 
        "177": "8 Conclusion  We have investigated the search space of parsers that produce noncrossing digraphs.", 
        "178": "Parsers that can be adapted to different needs are less dependent on artificial assumptions on the search space.", 
        "179": "Adaptivity gives us freedom to model how the properties of digraphs are actually distributed in linguistic data.", 
        "180": "As the adaptive data analysis deserves to be treated in its own right, the current work focuses on the separation of the parsing algorithm from the properties of the search space.", 
        "181": "This paper makes four significant contributions.", 
        "182": "Contribution 1: Digraph Encoding The paper introduces, for noncrossing digraphs, an encoding that uses brackets to indicate edges.", 
        "183": "Bracketed trees are widely used in generative syntax, treebanks and structured document formats.", 
        "184": "There are established conversions between phrase structure and projective dependency trees, but the currently advocated edge bracketing is expressive and captures more than just projective dependency trees.", 
        "185": "This capacity is welcome as syntactic and semantic analysis with dependency graphs is a steadily growing field.", 
        "186": "The edge bracketing creates new avenues for the study of connections between noncrossing graphs and context-free languages, as well as their recognizable properties.", 
        "187": "By demonstrating that digraphs can be treated as strings, we suggest that practical parsing to these structures could be implemented with existing methods that restrict context-free grammars to a regular yield language.", 
        "188": "Contribution 2: Context-Free Properties Acyclicity and other important properties of noncrossing digraphs are expressible as unambiguous context-free sets of encoded noncrossing\nTable 2: Characterizations for some noncrossing families of digraphs and graphs\nName Sequence prefix for n = 2,3, ...", 
        "189": "Example Name Sequence prefix for n = 2,3, ...", 
        "190": "Example digraph (KJ): 4,64,1792,62464,2437120,101859328\nhlat(D55 \u2229Gn \u2229Reglat) 1 2 3 4 5 weakly projective digraph 4,36,480,7744,138880,2661376 hlat(D55 \u2229Gn \u2229Reglat \u2229PW ) 1 2 3 4 5\nw.c.digraph 3,54,1539,53298,2051406,84339468 hlat(D55 \u2229Gn \u2229Reglat \u2229CW ) 1 2 3 4 5\nw.p.", 
        "191": "w.c.digraph 3,26,339,5278,90686,1658772 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229CW ) 1 2 3 4 5\nunamb.digr.", 
        "192": "4,39,529,8333,142995,2594378 hlat(D55 \u2229Gn \u2229Reglat \u2229US) 1 2 3 4 5\nw.p.", 
        "193": "unamb.digr.", 
        "194": "4,29,275,3008,35884,453489 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229US) 1 2 3 4 5\nm-forest 4,37,469,6871,109369,1837396,32062711 hlat(D55 \u2229Gn \u2229Reglat \u2229AU ) 1 2 3 4 5\nw.p.", 
        "195": "m-forest 4,29,273,2939,34273,421336 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229AU ) 1 2 3 4 5\nout digraph 4,27,207,1683,14229,123840,1102365 hlat(D55 \u2229Gn \u2229Reglat \u2229Out) 1 2 3 4 5\nw.p.", 
        "196": "out digraph 4,21,129,867,6177,45840,350379 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229Out) 1 2 3 4 5\nor.", 
        "197": "digraph 3,27,405,7533,156735,3492639,77539113 hlat(D55 \u2229Gn \u2229Reglat \u2229O) 1 2 3 4 5\nw.p.", 
        "198": "or.digraph see w.p.dag hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229O) see w.p.dag\ndags (A246756): 3,25,335,5521,101551 hlat(D55 \u2229Gn \u2229Reglat \u2229AD) 1 2 3 4 5\nw.p.", 
        "199": "dag 3,21,219,2757,38523, 574725, 8967675 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229AD) 1 2 3 4 5\nw.c. dag (KJ): 2,18,242,3890,69074,1306466 hlat(D55 \u2229Gn \u2229Reglat \u2229AD \u2229CW ) 1 2 3 4 5\nw.p.", 
        "200": "w.c. dag 2,14,142,1706,22554,316998,4480592 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229AD \u2229CW ) 1 2 3 4 5\nmultitree 3,19,167,1721,19447,233283,2917843 hlat(D55 \u2229Gn \u2229Reglat \u2229AD \u2229US)\nsee oriented forest or w.c. multitree w.p.", 
        "201": "multitree 3,17,129,1139,11005,112797,1203595 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229AD \u2229US) 1 2 3 4 5\nor.forest 3,19,165,1661,18191,210407,2528777 hlat(D55 \u2229Gn \u2229Reglat \u2229AD \u222aAU ) 1 2 3 4 5\nw.p.", 
        "202": "or.forest 3,17,127,1089,10127,99329,1010189 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229AD \u222aAU ) 1 2 3 4 5\nw.c. multitree 2,12,98,930,9638,105798,1201062 hlat(D55 \u2229Gn \u2229Reglat \u2229AD \u2229US \u2229CW ) 1 2 3 4 5\nw.p.", 
        "203": "w.c. multitree 2,10,68,538,4650,42572,404354 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229AD \u2229US \u2229CW ) 1 2 3 4 5\nout or.forest 3,16,105,756,5738,45088,363221 hlat(D55 \u2229Gn \u2229Reglat \u2229AD \u2229Out) 1 2 3 4 5\nw.p.", 
        "204": "out or.forest (A003169): 3,14,79,494,3294,22952 hlat(D55 \u2229Gn \u2229Reglat \u2229PW \u2229AD \u2229Out) 1 2 3 4 5\npolytree (A153231): 2,12,96,880,8736,91392 hlat(D55 \u2229Gn \u2229Reglat \u2229AD \u2229CW \u2229AU ) 1 2 3 4 5\nw.p.", 
        "205": "polytree (A027307):2,10,66,498,4066,34970 hlat(D55\u2229Gn\u2229Reglat\u2229PW \u2229AD\u2229CW \u2229AU ) 1 2 3 4 5\nout or.tree (A174687): 2,9,48,275,1638,9996 hlat(D55 \u2229Gn \u2229Reglat \u2229AD \u2229CW \u2229Out) 1 2 3 4 5\nprojective out or.tree\n(A006013): 2,7,30,143,728,3876,21318 hlat(D55\u2229Gn\u2229Reglat\u2229PW \u2229AD\u2229CW \u2229Out) 1 2 3 4 5\ngraph (A054726): 2,8,48,352,2880,25216 hlat(D55 \u2229Gn \u2229Reglat \u2229 I) 1 2 3 4 5\nconnected graph (A007297): 1,4,23,156,1162,9192 hlat(D55 \u2229Gn \u2229Reglat \u2229 I\u2229CW ) 1 2 3 4 5\nforest (A054727): 2,7,33,181,1083,6854 hlat(D55 \u2229Gn \u2229Reglat \u2229 I\u2229AU ) 1 2 3 4 5\ntree (A001764,YJ): 1,3,12,55,273,1428,7752 hlat(D55 \u2229Gn \u2229Reglat \u2229 I\u2229AU \u2229CW ) 1 2 3 4 5\nA = (OEIS Foundation Inc., 2017), KJ = Kuhlmann (2015) or Kuhlmann and Johnsson (2015), YJ = Yli-Jyra\u0308 (2012)\ndigraphs.", 
        "206": "This facilitates the incorporation of property testing to dynamic programming algorithms that implement exact inference.", 
        "207": "Descriptive complexity helps us understand to which degree various graphical properties are local and could be incorporated into efficient dynamic programming during exact inference.", 
        "208": "It is well known that acyclicity and connecticity are not definable in first-order logic (FO) while they can be defined easily in monadic second order logic (MSO) (Courcelle, 1997).", 
        "209": "MSO involves set-valued variables whose use in dynamic programming algorithms and tabular parsing is inefficient.", 
        "210": "MSO queries have a brute force transformation to first-order (FO) logic, but this does not generally help either as it is well known that MSO can express intractable problems.", 
        "211": "The interesting observation of the current work is that some MSO definable properties of digraphs become local in our extended encoding.", 
        "212": "This encoding is linear compared to the size of digraphs: each string over the extended bracket alphabet encodes a fixed assignment of MSO variables.", 
        "213": "The properties of noncrossing digraphs now reduce to properties of bracketed trees with linear amount of\nfunc noncrossing_ACYCU(n,E): for {u,y} in E and u < y: # covering edge\n[v,p] = [u,u] while p != -1: # chain continues\n[v,p] = [p,-1] for vv in [v+1,...,y]: # next vertex\nif {v,vv} in E and {v,vv} != {u,y}: if vv == y:\nreturn False # found cycle uvy p = vv # find longest edge\nreturn True # acyclic\nFigure 5: Testing ACYCU in logarithmic space\nlatent information that is fixed for each digraph.", 
        "214": "A deeper explanation for our observation comes from the fact that the treewidth of noncrossing and other outerplanar graphs is bounded to 2.", 
        "215": "When the treewidth is bounded, all MSO definable properties, including the intractable ones, become linear time decidable for individual structures (Courcelle, 1990).", 
        "216": "They can also be decided in a logarithmic amount of writable space (Elberfeld et al., 2010), e.g.", 
        "217": "with element indices instead of sets.", 
        "218": "By combining this insight with Proposition 1, we obtain a logspace solution for testing acyclicity of a noncrossing graph (Figure 5).", 
        "219": "Although bounded treewidth is a weaker constraint than so-called bounded treedepth that would immediately guarantee first-order definabil-\nity (Elberfeld et al., 2016), it can sometimes turn intractable search problems to dynamic programming algorithms (Akutsu and Tamura, 2012).", 
        "220": "In our case, Proposition 1 gave rise to unambiguous context-free subsets of LNC-DIGRAPH.", 
        "221": "These can be recognized with dynamic programming and used in efficient constrained inference when we add vertex indices to the brackets and weights to the grammar of the corresponding Dyck language.", 
        "222": "Contribution 3: Digraph Ontology The context-free properties of encoded digraphs have elegant nonderivative language representations and they generate a semi-lattice under language intersection.", 
        "223": "Although context-free languages are not generally closed under intersection, all combinations of the properties in this lattice are context-free and define natural families of digraphs.", 
        "224": "The nonderivative representations for our axiomatic properties share the same Dyck language D55 and homomorphism, but differ in terms of forbidden patterns.", 
        "225": "As a consequence, also any conjunctive combination of these two properties shares these components and thus define a context-free language.", 
        "226": "The obtained semilattice is an ontology of families of noncrossing digraphs.", 
        "227": "Our ontology contains important families of noncrossing digraphs used in syntactic and semantic dependency parsing: out trees, dags, and weakly connected digraphs.", 
        "228": "It shows the entailment between the properties and proves the existence of less known families of noncrossing digraphs such as strongly unambiguous digraphs and oriented graphs, multitrees, oriented forests and polytrees.", 
        "229": "These are generalizations of out oriented trees.", 
        "230": "However, these families can still be weakly projective.", 
        "231": "Table 2 shows integer sequences obtained by enumerating digraphs in each family.", 
        "232": "At least twelve of these sequences are previously known, which indicates that the families are natural.", 
        "233": "We used a finite-state toolkit to build the components of the nongenerative language representation for latent encoded digraphs and the axioms.2\nContribution 4: Generic Parsing The fourth contribution of this paper is to show that parsing algorithms can be separated from the formal properties of their search space.", 
        "234": "2The finite-state toolkit scripts and a Python-based graph enumerator are available at https://github.com/amikael/ncdigraphs .", 
        "235": "All the presented families of digraphs can be treated by parsers and other algorithms (e.g.", 
        "236": "enumeration algorithms) in a uniform manner.", 
        "237": "The parser\u2019s inference rules can stay constant and the choice of the search space is made by altering the regular component of the language representation.", 
        "238": "The ontology of the search space can be combined with a constraint relaxation strategy, for example, when an out tree is a preferred analysis, but a dag is also possible as an analysis when no tree is strong enough.", 
        "239": "The flexibility applies also to dynamic programming algorithms that complement with the encoding and allow inference of best dependency graphs in a family simply by intersection with a weighted CFG grammar for a Dyck language that models position-indexed edges of the complete digraph.", 
        "240": "Since the families of digraphs are distinguished by forbidden local patterns, the choice of search space can be made purely on lexical grounds, blending well with lexicalized parsing and allowing possibilities such as choosing, per each word, what kind of structures the word can go with.", 
        "241": "Future work We are planning to extend the coverage of the approach by exploring 1-endpointcrossing and MHk trees (Pitler et al., 2013; Go\u0301mez-Rodr\u0131\u0301guez, 2016), and related digraphs \u2014 see (Yli-Jyra\u0308, 2004; Go\u0301mez-Rodr\u0131\u0301guez et al., 2011).", 
        "242": "Properties such as weakly projective, out, and strongly unambiguous prompt further study.", 
        "243": "An interesting avenue for future work is to explore higher order factorizations for noncrossing digraphs and the related inference.", 
        "244": "We would also like to have more insight on the transformation of MSO definable properties to the current framework and to logspace algorithms.", 
        "245": "Acknowledgements  AYJ has received funding as Research Fellow from the Academy of Finland (dec. No 270354 - A Usable Finite-State Model for Adequate Syntactic Complexity) and Clare Hall Fellow from the University of Helsinki (dec. RP 137/2013).", 
        "246": "CGR has received funding from the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation programme (grant agreement No 714150 - FASTPARSE) and from the TELEPARES-UDC project (FFI201451978-C2-2-R) from MINECO.", 
        "247": "The comments of Juha Kontinen, Mark-Jan Nederhof and the anonymous reviewers helped to improve the paper."
    }, 
    "document_id": "P17-1160.pdf.json"
}
