{
    "abstract_sentences": {
        "1": "We introduce a composite deep neural network architecture for supervised and language independent context sensitive lemmatization.", 
        "2": "The proposed method considers the task as to identify the correct edit tree representing the transformation between a word-lemma pair.", 
        "3": "To find the lemma of a surface word, we exploit two successive bidirectional gated recurrent structures the first one is used to extract the character level dependencies and the next one captures the contextual information of the given word.", 
        "4": "The key advantages of our model compared to the state-of-the-art lemmatizers such as Lemming and Morfette are (i) it is independent of human decided features (ii) except the gold lemma, no other expensive morphological attribute is required for joint learning.", 
        "5": "We evaluate the lemmatizer on nine languages Bengali, Catalan, Dutch, Hindi, Hungarian, Italian, Latin, Romanian and Spanish.", 
        "6": "It is found that except Bengali, the proposed method outperforms Lemming and Morfette on the other languages.", 
        "7": "To train the model on Bengali, we develop a gold lemma annotated dataset1 (having 1, 702 sentences with a total of 20, 257 word tokens), which is an additional contribution of this work."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1481\u20131491 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1136  1 Introduction  Lemmatization is the process to determine the root/dictionary form of a surface word.", 
        "2": "Morphologically rich languages suffer due to the existence\n1The dataset and the code of model architecture are released with the paper.", 
        "3": "They are also available in http: //www.isical.ac.in/\u02dcutpal/resources.php\nof various inflectional and derivational variations of a root depending on several linguistic properties such as honorificity, parts of speech (POS), person, tense etc.", 
        "4": "Lemmas map the related word forms to lexical resources thus identifying them as the members of the same group and providing their semantic and syntactic information.", 
        "5": "Stemming is a way similar to lemmatization producing the common portion of variants but it has several limitations - (i) there is no guarantee of a stem to be a legitimate word form (ii) words are considered in isolation.", 
        "6": "Hence, for context sensitive languages i.e.", 
        "7": "where same inflected word form may come from different sources and can only be disambiguated by considering its neighbouring information, there lemmatization defines the foremost task to handle diverse text processing problems (e.g.", 
        "8": "sense disambiguation, parsing, translation).", 
        "9": "The key contributions of this work are as follows.", 
        "10": "We address context sensitive lemmatization introducing a two-stage bidirectional gated recurrent neural network (BGRNN) architecture.", 
        "11": "Our model is a supervised one that needs lemma tagged continuous text to learn.", 
        "12": "Its two most important advantages compared to the state-ofthe-art supervised models (Chrupala et al., 2008; Toutanova and Cherry, 2009; Gesmundo and Samardzic, 2012; Mu\u0308ller et al., 2015) are - (i) we do not need to define hand-crafted features such as the word form, presence of special characters, character alignments, surrounding words etc.", 
        "13": "(ii) parts of speech and other morphological attributes of the surface words are not required for joint learning.", 
        "14": "Additionally, unknown word forms are also taken care of as the transformation between word-lemma pair is learnt, not the lemma itself.", 
        "15": "We exploit two steps learning in our method.", 
        "16": "At first, characters in the words are passed sequentially through a BGRNN to get a syntactic embedding of each word and then the outputs are\n1481\ncombined with the corresponding semantic embeddings.", 
        "17": "Finally, mapping between the combined embeddings to word-lemma transformations are learnt using another BGRNN.", 
        "18": "For the present work, we assess our model on nine languages having diverse morphological variations.", 
        "19": "Out of them, two (Bengali and Hindi) belong to the Indic languages family and the rests (Catalan, Dutch, Hungarian, Italian, Latin, Romanian and Spanish) are taken from the European languages.", 
        "20": "To evaluate the proposed model on Bengali, a lemma annotated continuous text has been developed.", 
        "21": "As so far there is no such standard large dataset for supervised lemmatization in Bengali, the prepared one would surely contribute to the respective NLP research community.", 
        "22": "For the remaining languages, standard datasets are used for experimentation.", 
        "23": "Experimental results reveal that our method outperforms Lemming (Mu\u0308ller et al., 2015) and Morfette (Chrupala et al., 2008) on all the languages except Bengali.", 
        "24": "1.1 Related Works  Efforts on developing lemmatizers can be divided into two principle categories (i) rule/heuristics based approaches (Koskenniemi, 1984; Plisson et al., 2004) which are usually not portable to different languages and (ii) learning based methods (Chrupala et al., 2008; Toutanova and Cherry, 2009; Gesmundo and Samardzic, 2012; Mu\u0308ller et al., 2015; Nicolai and Kondrak, 2016) requiring prior training dataset to learn the morphological patterns.", 
        "25": "Again, the later methods can be further classified depending on whether context of the current word is considered or not.", 
        "26": "Lemmatization without context (Cotterell et al., 2016; Nicolai and Kondrak, 2016) is closer to stemming and not the focus of the present work.", 
        "27": "It is noteworthy here that the supervised lemmatization methods do not try to classify the lemma of a given word form as it is infeasible due to having a large number of lemmas in a language.", 
        "28": "Rather, learning the transformation between word-lemma pair is more generalized and it can handle the unknown word forms too.", 
        "29": "Several representations of wordlemma transformation have been introduced so far such as shortest edit script (SES), label set, edit tree by Chrupala et al.", 
        "30": "(2008), Gesmundo and Samardzic (2012) and Mu\u0308ller et al.", 
        "31": "(2015) respectively.", 
        "32": "Following Mu\u0308ller et al.", 
        "33": "(2015), we consider lemmatization as the edit tree classification\nproblem.", 
        "34": "Toutanova and Cherry (2009); Mu\u0308ller et al.", 
        "35": "(2015) also showed that joint learning of lemmas with other morphological attributes is mutually beneficial but obtaining the gold annotated datasets is very expensive.", 
        "36": "In contrast, our model needs only lemma annotated continuous text (not POS and other tags) to learn the word morphology.", 
        "37": "Since our experiments include the Indic languages also, it would not be an overstatement to say that there have been little efforts on lemmatization so far (Faridee et al., 2009; Loponen and Ja\u0308rvelin, 2010; Paul et al., 2013; Bhattacharyya et al., 2014).", 
        "38": "The works by Faridee et al.", 
        "39": "(2009); Paul et al.", 
        "40": "(2013) are language specific rule based for Bengali and Hindi respectively.", 
        "41": "(Loponen and Ja\u0308rvelin, 2010)\u2019s primary objective was to improve the retrieval performance.", 
        "42": "Bhattacharyya et al.", 
        "43": "(2014) proposed a heuristics based lemmatizer using WordNet but they did not consider context of the target word which is an important basis to lemmatize Indic languages.", 
        "44": "Chakrabarty and Garain (2016) developed an unsupervised language independent lemmatizer and evaluated it on Bengali.", 
        "45": "They consider the contextual information but the major disadvantage of their method is dependency on dictionary as well as POS information.", 
        "46": "Very recently, a supervised neural lemmatization model has been introduced by Chakrabarty et al.", 
        "47": "(2016).", 
        "48": "They treat the problem as lemma transduction rather than classification.", 
        "49": "The particular root in the dictionary is chosen as the lemma with which the transduced vector possesses maximum cosine similarity.", 
        "50": "Hence, their approach fails when the correct lemma of a word is not present in the dictionary.", 
        "51": "Besides, the lemmatization accuracy obtained by the respective method is not very significant.", 
        "52": "Apart from the mentioned works, there is no such commendable effort so far.", 
        "53": "Rest of this paper is organized as follows.", 
        "54": "In section 2, we describe the proposed lemmatization method.", 
        "55": "Experimental setup and the results are presented in section 3.", 
        "56": "Finally, in section 4 we conclude the paper.", 
        "57": "2 The Proposed Method  As stated earlier in section 1.1, we represent the mapping between a word to its lemma using edit tree (Chrupa\u0142a, 2008; Mu\u0308ller et al., 2015).", 
        "58": "An edit tree embeds all the necessary edit operations within it i.e.", 
        "59": "insertions, deletions and substitutions of strings required throughout the transformation\nFigure 1: Edit trees for the word-lemma pairs \u2018sang-sing\u2019 and \u2018achieving-achieve\u2019.", 
        "60": "process.", 
        "61": "Figure 1 depicts two edit trees that map the inflected English words \u2018sang\u2019 and \u2018achieving\u2019 to their respective lemmas \u2018sing\u2019 and \u2018achieve\u2019.", 
        "62": "For generalization, edit trees encode only the substitutions and the length of prefixes and suffixes of the longest common substrings.", 
        "63": "Initially, all unique edit trees are extracted from the associated surface word-lemma pairs present in the training set.", 
        "64": "The extracted trees refer to the class labels in our model.", 
        "65": "So, for a test word, the goal is to classify the correct edit tree which, applied on the word, returns the lemma.", 
        "66": "Next, we will describe the architecture of the proposed neural lemmatization model.", 
        "67": "It is evident that for morphologically rich languages, both syntactic and semantic knowledge help in lemmatizing a surface word.", 
        "68": "Now a days, it is a common practice to embed the functional properties of words into vector representations.", 
        "69": "Despite the word vectors prove very effectual in semantic processing tasks, they are modelled using the distributional similarity obtained from a raw corpus.", 
        "70": "Morphological regularities, local and non-local dependencies in character sequences that play deciding roles to find the lemmas, are not taken into account where each word has its own vector interpretation.", 
        "71": "We address this issue by incorporating two different embeddings into our model.", 
        "72": "Semantic embedding is achieved using word2vec (Mikolov et al., 2013a,b), which has been empirically found highly successful.", 
        "73": "To devise the syntactic embedding of a word, we follow the work of Ling et al.", 
        "74": "(2015) that uses compositional character to word model using bidirectional long-short term memory (BLSTM) network.", 
        "75": "In our experiments, different\nFigure 2: Syntactic vector composition for a word.", 
        "76": "gated recurrent cells such as LSTM (Graves, 2013) and GRU (Cho et al., 2014), are explored.", 
        "77": "The next subsection describes the module to construct the syntactic vectors by feeding the character sequences into BGRNN architecture.", 
        "78": "2.1 Forming Syntactic Embeddings  Our goal is to build syntactic embeddings of words that capture the similarities in morphological level.", 
        "79": "Given an input word w, the target is to obtain a d dimensional vector representing the syntactic structure of w. The procedure is illustrated in Figure 2.", 
        "80": "At first, an alphabet of characters is defined as C. We represent w as a sequence of characters c1, .", 
        "81": ".", 
        "82": ".", 
        "83": ", cm where m is the word length and each character ci is defined as a one hot encoded vector 1ci , having one at the index of ci in the alphabet C. An embedding layer is defined as Ec \u2208 Rdc\u00d7|C|, that projects each one hot encoded character vector to a dc dimensional embedded vector.", 
        "84": "For a character ci, its projected vector eci is obtained from the embedding layer Ec, using this relation eci = Ec \u00b7 1ci where \u2018\u00b7\u2019 is the matrix multiplication operation.", 
        "85": "Given a sequence of vectors x1, .", 
        "86": ".", 
        "87": ".", 
        "88": ", xm as input, a LSTM cell computes the state sequence h1, .", 
        "89": ".", 
        "90": ".", 
        "91": ", hm using the following equations:\nft = \u03c3(Wf xt + Uf ht\u22121 + Vf ct\u22121 + bf ) it = \u03c3(Wixt + Uiht\u22121 + Vict\u22121 + bi) ct = ft \u2299 ct\u22121\n+ it \u2299 tanh(Wcxt + Ucht\u22121 + bc) ot = \u03c3(Woxt + Uoht\u22121 + Voct + bo) ht = ot \u2299 tanh(ct),\nWhereas, the updation rules for GRU are as follows\nzt = \u03c3(Wzxt + Uzht\u22121 + bz) rt = \u03c3(Wrxt + Urht\u22121 + br) ht = (1 \u2212 zt)\u2299 ht\u22121\n+ zt \u2299 tanh(Whxt + Uh(rt \u2299 ht\u22121) + bh),\n\u03c3 denotes the sigmoid function and \u2299 stands for the element-wise (Hadamard) product.", 
        "92": "Unlike the simple recurrent unit, LSTM uses an extra memory cell ct that is controlled by three gates - input (it), forget (ft) and output (ot).", 
        "93": "it controls the amount of newmemory content added to the memory cell, ft regulates the degree to which the existing memory is forgotten and ot finally adjusts the memory content exposure.", 
        "94": "W, U, V (weight matrices), b (bias) are the parameters.", 
        "95": "Without having a memory cell like LSTM, a GRU uses two gates namely update (zt) and reset (rt).", 
        "96": "The gate, zt decides the amount of update needed for activation and rt is used to ignore the previous hidden states (when close to 0, it forgets the earlier computation).", 
        "97": "So, for a sequence of projected characters ec1 , .", 
        "98": ".", 
        "99": ".", 
        "100": ", ecm , the forward and the backward networks produce the state sequences hf1 , .", 
        "101": ".", 
        "102": ".", 
        "103": ", h f m and hbm, .", 
        "104": ".", 
        "105": ".", 
        "106": ", hb1 respectively.", 
        "107": "Finally, we obtain the syntactic embedding of w, denoted as esynw , by concatenating the final states of these two sequences.", 
        "108": "esynw = [h b 1,h f m]  2.2 Model  We present the sketch of the final integrated model in Figure 3.", 
        "109": "For a word w, let esemw denotes its semantic embedding obtained using word2vec.", 
        "110": "Both the vectors, esynw and esemw are concatenated together to shape the composite representation ecomw which carries the morphological and distributional information within it.", 
        "111": "Firstly, for all the words present in the training set, their composite vectors are generated.", 
        "112": "Next, they are fed sentencewise into the next level of BGRNN to train the model for the edit tree classification task.", 
        "113": "This second level bidirectional network accounts the local context in both forward and backward directions, which is essential for lemmatization in context sensitive languages.", 
        "114": "Let, ecomw1 , .", 
        "115": ".", 
        "116": ".", 
        "117": ", e com wn be the input sequence of composite vectors to the BGRNN model, representing a sentence having n words w1, .", 
        "118": ".", 
        "119": ".", 
        "120": ", wn.", 
        "121": "For the ith vector ecomwi , h f i and\nhbi denote the forward and backward states respectively carrying the informations of w1, .", 
        "122": ".", 
        "123": ".", 
        "124": ", wi and wi, .", 
        "125": ".", 
        "126": ".", 
        "127": ", wn.", 
        "128": "2.2.1 Incorporating Applicable Edit Trees Information  One aspect that we did not look into so far, is that for a word all unique edit trees extracted from the training set are not applicable as this would lead to incompatible substitutions.", 
        "129": "For example, the edit tree for the word-lemma pair \u2018sang-sing\u2019 depicted in Figure 1, cannot be applied on the word \u2018achieving\u2019.", 
        "130": "This information is prior before training the model i.e.", 
        "131": "for any arbitrary word, we can sort out the subset of unique edit trees from the training samples in advance, which are applicable on it.", 
        "132": "In general, if all the unique edit trees in the training data are set as the class labels, the model will learn to distribute the probability mass over all the classes which is a clear-cut bottleneck.", 
        "133": "In order to alleviate this problem, we take a novel strategy so that for individual words in the input sequence, the model will learn, to which classes, the output probability should be apportioned.", 
        "134": "Let T = {t1, .", 
        "135": ".", 
        "136": ".", 
        "137": ", tk} be the set of distinct edit trees found in the training set.", 
        "138": "For the word wi in the input sequence w1, .", 
        "139": ".", 
        "140": ".", 
        "141": ", wn, we define its applicable edit trees vector as Ai = (a1i , .", 
        "142": ".", 
        "143": ".", 
        "144": ", aki ) where \u2200j \u2208 {1, .", 
        "145": ".", 
        "146": ".", 
        "147": ", k}, aji = 1 if tj is applicable for wi, otherwise 0.", 
        "148": "Hence, Ai holds the information regarding the set of edit trees to concentrate\nupon, while processing the word wi.", 
        "149": "We combine Ai together with hfi and h b i for the final classification task as following,\nli = softplus(Lf hfi + L bhbi + L aAi + bl),\nwhere \u2018softplus\u2019 denotes the activation function f(x) = ln(1 + ex) and Lf ,Lb,La and bl are the parameters trained by the network.", 
        "150": "At the end, li is passed through the softmax layer to get the output labels for wi.", 
        "151": "To pick the correct edit tree from the output of the softmax layer, we exploit the prior information Ai.", 
        "152": "Instead of choosing the class that gets the maximum probability, we select the maximum over the classes corresponding to the applicable edit trees.", 
        "153": "The idea is expressed as follows.", 
        "154": "Let Oi = (o1i , .", 
        "155": ".", 
        "156": ".", 
        "157": ", oki ) be the output of the softmax layer.", 
        "158": "Instead of opting for the maximum over o1i , .", 
        "159": ".", 
        "160": ".", 
        "161": ", o k i as the class label, the highest probable class out of those corresponding to the applicable edit trees, is picked up.", 
        "162": "That is, the particular edit tree tj \u2208 T is considered as the right candidate for wi, where\nj = argmax j\u2032\u2208{1,...,k} \u2227 aj\u2032i =1\noj \u2032\ni\nIn this way, we cancel out the non-applicable classes and focus only on the plausible candidates.", 
        "163": "3 Experimentation  Out of the nine reference languages, initially we choose four of them (Bengali, Hindi, Latin and Spanish) for in-depth analysis.", 
        "164": "We conduct an exhaustive set of experiments - such as determining the direct lemmatization accuracy, accuracy obtained without using applicable edit trees in training, measuring the model\u2019s performance on the unseen words etc.", 
        "165": "on these four languages.", 
        "166": "Later we consider five more languages (Catalan, Dutch, Hungarian, Italian and Romanian) mostly for testing the generalization ability of the proposed method.", 
        "167": "For these additional languages, we present only the lemmatization accuracy in section 3.2.", 
        "168": "Datasets: As Bengali is a low-resourced language, a relatively large lemma annotated dataset is prepared for the present work using Tagore\u2019s short stories collection2 and randomly selected news articles from miscellaneous domains.", 
        "169": "One\n2www.rabindra-rachanabali.nltr.org\nlinguist took around 2 months to complete the annotation which was checked by another person and differences were sorted out.", 
        "170": "Out of the 91 short stories of Tagore, we calculate the value of (# tokens / # distinct tokens) for each story.", 
        "171": "Based on this value (lower is better), top 11 stories are selected.", 
        "172": "The news articles3 are crafted from the following domains: animal, archaeology, business, country, education, food, health, politics, psychology, science and travelogue.", 
        "173": "In Hindi, we combine the COLING\u201912 shared task data for dependency parsing and Hindi WSD health and tourism corpora4 (Khapra et al., 2010) together5.", 
        "174": "For Latin, the data is taken from the PROIEL treebank (Haug and J\u00f8hndal, 2008) and for Spanish, we merge the training and development datasets of CoNLL\u201909 (Hajic\u030c et al., 2009) shared task on syntactic and semantic dependencies.", 
        "175": "The dataset statistics are given in Table 1.", 
        "176": "We assess the lemmatization performance by measuring the direct accuracy which is the ratio of the number of correctly lemmatized words to the total number of input words.", 
        "177": "The experiments are performed using 4 fold cross validation technique i.e.", 
        "178": "the datasets are equi-partitioned into 4 parts at sentence level and then each part is tested exactly once using the model trained on the remaining 3 parts.", 
        "179": "Finally, we report the average accuracy over 4 fold.", 
        "180": "Induction of Edit Tree Set: Initially, distinct edit trees are induced from the word-lemma pairs present in the training set.", 
        "181": "Next, the words in the training data are annotated with their corresponding edit trees.", 
        "182": "Training is accomplished on this edit tree tagged text.", 
        "183": "Figure 4 plots the growth of the edit tree set against the number of word-lemma samples in the four languages.", 
        "184": "With the increase of samples, the size of edit tree set gradually converges revealing the fact that most of the frequent transformation patterns (both regular and irregular) are covered by the induction process.", 
        "185": "From\n3http://www.anandabazar.com/ 4http://www.cfilt.iitb.ac.in/wsd/\nannotated_corpus/ 5We also release the Hindi dataset with this paper as it is a combination of two different datasets.", 
        "186": "Figure 4, morphological richness can be compared across the languages.", 
        "187": "When convergence happens quickly i.e.", 
        "188": "at relatively less number of samples, it evidences that the language is less complex.", 
        "189": "Among the four reference languages, Latin stands out as the most intricate, followed by Bengali, Spanish and Hindi.", 
        "190": "Semantic Embeddings: We obtain the distributional word vectors for Bengali and Hindi by training the word2vec model on FIRE Bengali and Hindi news corpora6.", 
        "191": "Following the work by Mikolov et al.", 
        "192": "(2013a), continuous-bag-ofwords architecture with negative sampling is used to get 200 dimensional word vectors.", 
        "193": "For Latin and Spanish, we use the embeddings released by Bamman and Smith (2012)7 and Cardellino (2016)8 respectively.", 
        "194": "Syntactic Representation: We acquire the statistics of word length versus frequency from the datasets and find out that irrespective of the languages, longer words (have more than 20-25 characters) are few in numbers.", 
        "195": "Based on this finding, each word is limited to a sequence of 25 characters.", 
        "196": "Smaller words are padded null characters at the end and for the longer words, excess characters are truncated out.", 
        "197": "So, each word is represented as a 25 length array of one hot encoded vectors which is given input to the embedding layer that works as a look up table producing an equal length array of embedded vectors.", 
        "198": "Initialization of the embedding layer is done randomly and the embedded vector dimension is set to 10.", 
        "199": "Eventually, the output of the embedding layer is passed to the first\n6http://fire.irsi.res.in/fire 7http://www.cs.cmu.edu/\u02dcdbamman/latin.", 
        "200": "html 8http://crscardellino.me/SBWCE/\nlevel BGRNN for learning the syntactic representation.", 
        "201": "Hyper Parameters: There are several hyper parameters in our model such as the number of neurons in the hidden layer (ht) of both first and second level BGRNN, learning mode, number of epochs to train the models, optimization algorithm, dropout rate etc.", 
        "202": "We experiment with different settings of these parameters and report where optimum results are achieved.", 
        "203": "For both the bidirectional networks, number of hidden layer neurons is set to 64.", 
        "204": "Online learning is applied for updation of the weights.", 
        "205": "Number of epochs varies across languages to converge the training.", 
        "206": "It is maximum for Bengali (around 80 epochs), followed by Latin, Spanish and Hindi taking around 50, 35 and 15 respectively.", 
        "207": "Throughout the experiments, we set the dropout rate as 0.2 to prevent over-fitting.", 
        "208": "Different optimization algorithms like AdaDelta (Zeiler, 2012), Adam (Kingma and Ba, 2014), RMSProp (Dauphin et al., 2015) are explored.", 
        "209": "Out of them, Adam yields the best result.", 
        "210": "We use the categorical cross-entropy as the loss function in our model.", 
        "211": "Baselines: We compare our method with Lemming9 and Morfette10.", 
        "212": "Both the model jointly learns lemma and other morphological tags in context.", 
        "213": "Lemming uses a 2nd-order linear-chain CRF to predict the lemmas whereas, the current version of Morfette is based on structured perceptron learning.", 
        "214": "As POS information is a compulsory requirement of these two models, the Bengali data is manually POS annotated.", 
        "215": "For the other languages, the tags were already available.", 
        "216": "Although this comparison is partially biased as the proposed method does not need POS information, but the experimental results show the effectiveness of our model.", 
        "217": "There is an option in Lemming and Morfette to provide an exhaustive set of root words which is used to exploit the dictionary features i.e.", 
        "218": "to verify if a candidate lemma is a valid form or not.", 
        "219": "To make the comparisons consistent, we do not exploit any external dictionary in our experiments.", 
        "220": "3.1 Results  The lemmatization results are presented in Table 2.", 
        "221": "We explore our proposed model with two types of gated recurrent cells - LSTM and GRU.", 
        "222": "As there\n9http://cistern.cis.lmu.de/lemming/ 10https://github.com/gchrupala/morfette\nare two successive bidirectional networks - the first one for building the syntactic embedding and the next one for the edit tree classification, so basically we deal with two different models BLSTMBLSTM and BGRU-BGRU.", 
        "223": "Table 2 shows the comparison results of these models with Lemming and Morfette.", 
        "224": "In all cases, the average accuracy over 4 fold cross validation on the datasets is reported.", 
        "225": "For an entry \u2018x/y\u2019 in Table 2, x denotes the accuracy without output classes restriction, i.e.", 
        "226": "taking the maximum over all edit tree classes present in the training set, whereas y refers to the accuracy when output is restricted in only the applicable edit tree classes of the input word.", 
        "227": "Except for Bengali, the proposed models outperform the baselines for the other three languages.", 
        "228": "In Hindi, BLSTM-BLSTM gives the best result (94.90%).", 
        "229": "For Latin and Spanish, the highest accuracy is achieved by BGRU-BGRU (89.59% and 98.11% respectively).", 
        "230": "In the Bengali dataset, Lemming produces the optimum result (91.69%) beating its closest performer BLSTM-BLSTM by 0.55%.", 
        "231": "It is to note that the training set size in Bengali is smallest compared to the other languages (on average, 16, 712 tokens in each of the 4 folds).", 
        "232": "Overall, BLSTM-BLSTM and BGRU-BGRU perform equally good.", 
        "233": "For Bengali and Hindi, the former model is better and for Latin and Spanish, the later yields more accuracy.", 
        "234": "Throughout the experiments, restricting the output over applicable classes improves the performance significantly.", 
        "235": "The maximum improvements we get are: 0.30% in Bengali using BLSTM-BLSTM (from 90.84% to 91.14%), 0.06% in Hindi using BGRU-BGRU (from 94.44% to 94.50%), 0.19% in Latin using BGRU-BGRU (from 89.40% to 89.59%) and 0.06% in Spanish using BLSTM-BLSTM (from 97.85% to 97.91%).", 
        "236": "To compare between the two baselines, Lemming consistently performs better\nthan Morfette (the maximum difference between their accuracies is 1.40% in Latin).", 
        "237": "Effect of Training without Applicable Edit Trees: We also explore the impact of applicable edit trees in training.", 
        "238": "To see the effect, we train our model without giving the applicable edit trees information as input.", 
        "239": "In the model design, the equation for the final classification task is changed as follows,\nli = softplus(Lf hfi + L bhbi + bl),\nThe results are presented in Table 3.", 
        "240": "Except for Spanish, BLSTM-BLSTM outperforms BGRUBGRU in all the other languages.", 
        "241": "As compared with the results in Table 2, for every model, training without applicable edit trees degrades the lemmatization performance.", 
        "242": "In all cases, BGRUBGRU model gets more affected than BLSTMBLSTM.", 
        "243": "Language-wise, the drops in its accuracy are: 1.94% in Bengali (from 90.84% to 88.90%), 0.46% in Hindi (from 94.50% to 94.04%), 2.72% in Latin (from 89.59% to 86.87%) and 0.38% in Spanish (from 98.11% to 97.73%).", 
        "244": "One important finding to note in Table 3 is that irrespective of any particular language and model used, the amount of increase in accuracy due to the output restriction on the applicable classes is much more than that observed in Table 2.", 
        "245": "For instance, in Table 2 the accuracy improvement for Bengali using BLSTM-BLSTM is 0.30% (from 90.84% to 91.14%), whereas in Table 3 the corresponding value is 3.06% (from 86.46% to 89.52%).", 
        "246": "These outcomes signify the fact that training with the ap-\nplicable edit trees already learns to dispense the output probability to the legitimate classes over which, output restriction cannot yield much enhancement.", 
        "247": "Results for Unseen Word Forms: Next, we discuss about the lemmatization performance on those words which were absent in the training set.", 
        "248": "Table 4 shows the proportion of unseen forms averaged over 4 folds on the datasets.", 
        "249": "In Table 5, we present the accuracy obtained by our models and the baselines.", 
        "250": "For Bengali and Hindi, Lemming produces the best results (74.10% and 90.35%).", 
        "251": "For Latin and Spanish, BLSTM-BLSTM and BGRU-BGRU obtain the highest accuracy (61.63% and 92.25%) respectively.", 
        "252": "In Spanish, our model gets the maximum improvement over the baselines.", 
        "253": "BGRU-BGRU beats Lemming with 33.36% margin (on average, out of 9, 011 unseen forms, 3, 005 more tokens are correctly lemmatized).", 
        "254": "Similar to the results in Table 2, the results in Table 5 evidences that restricting the output in applicable classes enhances the lemmatization performance.", 
        "255": "The maximum accuracy improvements due to the output restriction are: 1.04% in Bengali (from 71.06% to 72.10%), 0.38% in Hindi (from 87.80% to 88.18%) using BLSTM-BLSTM and 0.87% in Latin (from 60.65% to 61.52%), 0.77% in Spanish (from 91.48% to 92.25%) using BGRU-BGRU.", 
        "256": "Further, we investigate the performance of our models trained without the applicable edit trees information, on the unseen word forms.", 
        "257": "The results are given in Table 6.", 
        "258": "As expected, for every model, the accuracy drops compared to the results shown in Table 5.", 
        "259": "The only exception that we find out is in the entry for Hindi with BLSTM-BLSTM.", 
        "260": "Though without restricting the output, the accuracy in Table 5 (87.80%) is higher than the corresponding value in Table 6 (87.42%), but after out-\nput restriction, the performance changes (88.18% in Table 5, 88.41% in Table 6) which reveals that only selecting the maximum probable class over the applicable ones would be a better option for the unseen word forms in Hindi.", 
        "261": "Effects of Semantic and Syntactic Embeddings in Isolation: To understand the impact of the combined word vectors on the model\u2019s performance, we measure the accuracy experimenting with each one of them separately.", 
        "262": "While using the semantic embedding, only distributional word vectors are used for edit tree classification.", 
        "263": "On the other hand, to test the effect of the syntactic embedding exclusively, output from the character level recurrent network is fed to the second level BGRNN.", 
        "264": "We present the results in Table 7.", 
        "265": "For Bengali and Hindi, experiments are carried out with the BLSTM-BLSTM model as it gives better results for these languages compared to BGRU-BGRU (given in Table 2).", 
        "266": "Similarly for Latin and Spanish, the results obtained from BGRU-BGRU are reported.", 
        "267": "From the outcome of these experiments, use of semantic vec-\ntor proves to be more effective than the character level embedding.", 
        "268": "However, to capture the distributional properties of words efficiently, a huge corpus is needed which may not be available for low resourced languages.", 
        "269": "In that case, making use of syntactic embedding is a good alternative.", 
        "270": "Nonetheless, use of both types of embedding together improves the result.", 
        "271": "3.2 Experimental Results for Another Five Languages  As mentioned earlier, five additional languages (Catalan, Dutch, Hungarian, Italian and Romanian) are considered to test the generalization ability of the method.", 
        "272": "The datasets are taken from the UD Treebanks11 (Nivre et al., 2017).", 
        "273": "For each language, we merge the training and development data together and perform 4 fold cross validation on it to measure the average accuracy.", 
        "274": "The dataset statistics are shown in Table 8.", 
        "275": "For experimentation, we use the pre-trained semantic embeddings released by (Bojanowski et al., 2016).", 
        "276": "Only BLSTM-BLSTM model is explored and it is compared with Lemming and Morfette.", 
        "277": "The hyper parameters are kept same as described previously except for the number of epochs needed for training across the languages.", 
        "278": "We present the results in Table 9.", 
        "279": "For all the languages, BLSTM-BLSTM outperforms Lemming and Morfette.", 
        "280": "The maximum improvement over the baselines we get is for Catalan (beats Lemming and Morfette by 8.15% and 8.49% respectively).", 
        "281": "Similar to the results in Table 2, restricting the output over applicable classes yields consistent performance improvement.", 
        "282": "4 Conclusion  This article presents a neural network based context sensitive lemmatization method which is language independent and supervised in nature.", 
        "283": "The proposed model learns the transformation patterns between word-lemma pairs and hence, can handle the unknown word forms too.", 
        "284": "Additionally, it does not rely on human defined features and various\n11http://universaldependencies.org/\nmorphological tags except the gold lemma annotated continuous text.", 
        "285": "We explore different variations of the model architecture by changing the type of recurrent units.", 
        "286": "For evaluation, nine languages are taken as the references.", 
        "287": "Except Bengali, the proposed method outperforms the stateof-the-art models (Lemming and Morfette) on all the other languages.", 
        "288": "For Bengali, it produces the second best performance (91.14% using BLSTMBLSTM).", 
        "289": "We measure the accuracy on the partial data (keeping the data size comparable to the Bengali dataset) for Hindi, Latin and Spanish to check the effect of the data amount on the performance.", 
        "290": "For Hindi, the change in accuracy is insignificant but for Latin and Spanish, accuracy drops by 3.50% and 6% respectively.", 
        "291": "The time requirement of the proposed method is also analyzed.", 
        "292": "Training time depends on several parameters such as size of the data, number of epochs required for convergence, configuration of the system used etc.", 
        "293": "In our work, we use the \u2018keras\u2019 software keeping \u2018theano\u2019 as backend.", 
        "294": "The codes were run on a single GPU (Nvidia GeForce GTX 960, 2GB memory).", 
        "295": "Once trained, the model takes negligible time to predict the appropriate edit trees for test words (e.g.", 
        "296": "844 and 930 words/second for Bengali and Hindi respectively).", 
        "297": "We develop a Bengali lemmatization dataset which is definitely a notable contribution to the language resources.", 
        "298": "From the present study, one important finding comes out that for the unseen words, the lemmatization accuracy drops by a large margin in Bengali and Spanish, which may be the area of further research work.", 
        "299": "Apart from it, we intend to propose a neural architecture that accomplishes the joint learning of lemmas with other morphological attributes."
    }, 
    "document_id": "P17-1136.pdf.json"
}
