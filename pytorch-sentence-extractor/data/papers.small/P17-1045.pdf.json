{
    "abstract_sentences": {
        "1": "This paper proposes KB-InfoBot1 \u2014 a multi-turn dialogue agent which helps users search Knowledge Bases (KBs) without composing complicated queries.", 
        "2": "Such goal-oriented dialogue agents typically need to interact with an external database to access real-world knowledge.", 
        "3": "Previous systems achieved this by issuing a symbolic query to the KB to retrieve entries based on their attributes.", 
        "4": "However, such symbolic operations break the differentiability of the system and prevent endto-end training of neural dialogue agents.", 
        "5": "In this paper, we address this limitation by replacing symbolic queries with an induced \u201csoft\u201d posterior distribution over the KB that indicates which entities the user is interested in.", 
        "6": "Integrating the soft retrieval process with a reinforcement learner leads to higher task success rate and reward in both simulations and against real users.", 
        "7": "We also present a fully neural end-to-end agent, trained entirely from user feedback, and discuss its application towards personalized dialogue agents."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 484\u2013495 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1045  1 Introduction  The design of intelligent assistants which interact with users in natural language ranks high on the agenda of current NLP research.", 
        "2": "With an increasing focus on the use of statistical and machine learning based approaches (Young et al., 2013), the last few years have seen some truly remarkable conversational agents appear on the market (e.g.", 
        "3": "Apple Siri, Microsoft Cortana, Google Allo).", 
        "4": "These agents can perform simple tasks, answer\n1The source code is available at: https://github.", 
        "5": "com/MiuLab/KB-InfoBot\nfactual questions, and sometimes also aimlessly chit-chat with the user, but they still lag far behind a human assistant in terms of both the variety and complexity of tasks they can perform.", 
        "6": "In particular, they lack the ability to learn from interactions with a user in order to improve and adapt with time.", 
        "7": "Recently, Reinforcement Learning (RL) has been explored to leverage user interactions to adapt various dialogue agents designed, respectively, for task completion (Gas\u030cic\u0301 et al., 2013), information access (Wen et al., 2016b), and chitchat (Li et al., 2016a).", 
        "8": "We focus on KB-InfoBots, a particular type of dialogue agent that helps users navigate a Knowledge Base (KB) in search of an entity, as illustrated by the example in Figure 1.", 
        "9": "Such agents must necessarily query databases in order to retrieve the requested information.", 
        "10": "This is usually done by performing semantic parsing on the input to construct a symbolic query representing the beliefs of the agent about the user goal, such as Wen et al.", 
        "11": "(2016b), Williams and Zweig (2016), and Li et al.", 
        "12": "(2017)\u2019s work.", 
        "13": "We call such an operation a Hard-KB lookup.", 
        "14": "While natural, this approach has two drawbacks: (1) the retrieved results do not carry any information about uncertainty in semantic parsing, and (2) the retrieval operation is non differentiable, and hence the parser and dialog policy are trained separately.", 
        "15": "This makes online endto-end learning from user feedback difficult once the system is deployed.", 
        "16": "In this work, we propose a probabilistic framework for computing the posterior distribution of the user target over a knowledge base, which we term a Soft-KB lookup.", 
        "17": "This distribution is constructed from the agent\u2019s belief about the attributes of the entity being searched for.", 
        "18": "The dialogue policy network, which decides the next system action, receives as input this full distribution instead of a handful of retrieved results.", 
        "19": "We show in our ex-\n484\nperiments that this framework allows the agent to achieve a higher task success rate in fewer dialogue turns.", 
        "20": "Further, the retrieval process is differentiable, allowing us to construct an end-to-end trainable KB-InfoBot, all of whose components are updated online using RL.", 
        "21": "Reinforcement learners typically require an environment to interact with, and hence static dialogue corpora cannot be used for their training.", 
        "22": "Running experiments on human subjects, on the other hand, is unfortunately too expensive.", 
        "23": "A common workaround in the dialogue community (Young et al., 2013; Schatzmann et al., 2007b; Scheffler and Young, 2002) is to instead use user simulators which mimic the behavior of real users in a consistent manner.", 
        "24": "For training KB-InfoBot, we adapt the publicly available2 simulator described in Li et al.", 
        "25": "(2016b).", 
        "26": "Evaluation of dialogue agents has been the subject of much research (Walker et al., 1997; Mo\u0308ller et al., 2006).", 
        "27": "While the metrics for evaluating an InfoBot are relatively clear \u2014 the agent should return the correct entity in a minimum number of turns \u2014 the environment for testing it not so much.", 
        "28": "Unlike previous KB-based QA systems, our focus is on multi-turn interactions, and as such there are no publicly available benchmarks for this problem.", 
        "29": "We evaluate several versions of KB-InfoBot with the simulator and on real users, and show that the proposed Soft-KB lookup helps the reinforcement learner discover better dialogue policies.", 
        "30": "Initial experiments on the end-to-end agent also demonstrate its strong learning capability.", 
        "31": "2 https://github.com/MiuLab/TC-Bot  2 Related Work  Our work is motivated by the neural GenQA (Yin et al., 2016a) and neural enquirer (Yin et al., 2016b) models for querying KBs via natural language in a fully \u201cneuralized\u201d way.", 
        "32": "However, the key difference is that these systems assume that users can compose a complicated, compositional natural language query that can uniquely identify the element/answer in the KB.", 
        "33": "The research task is to parse the query, i.e., turning the natural language query into a sequence of SQL-like operations.", 
        "34": "Instead we focus on how to query a KB interactively without composing such complicated queries in the first place.", 
        "35": "Our work is motivated by the observations that (1) users are more used to issuing simple queries of length less than 5 words (Spink et al., 2001); (2) in many cases, it is unreasonable to assume that users can construct compositional queries without prior knowledge of the structure of the KB to be queried.", 
        "36": "Also related is the growing body of literature focused on building end-to-end dialogue systems, which combine feature extraction and policy optimization using deep neural networks.", 
        "37": "Wen et al.", 
        "38": "(2016b) introduced a modular neural dialogue agent, which uses a Hard-KB lookup, thus breaking the differentiability of the whole system.", 
        "39": "As a result, training of various components of the dialogue system is performed separately.", 
        "40": "The intent network and belief trackers are trained using supervised labels specifically collected for them; while the policy network and generation network are trained separately on the system utterances.", 
        "41": "We retain modularity of the network by keeping the belief trackers separate, but replace the hard lookup with a differentiable one.", 
        "42": "Dialogue agents can also interface with the database by augmenting their output action space with predefined API calls (Williams and Zweig, 2016; Zhao and Eskenazi, 2016; Bordes and Weston, 2016; Li et al., 2017).", 
        "43": "The API calls modify a query hypothesis maintained outside the end-toend system which is used to retrieve results from this KB.", 
        "44": "This framework does not deal with uncertainty in language understanding since the query hypothesis can only hold one slot-value at a time.", 
        "45": "Our approach, on the other hand, directly models the uncertainty to construct the posterior over the KB.", 
        "46": "Wu et al.", 
        "47": "(2015) presented an entropy minimization dialogue management strategy for In-\nfoBots.", 
        "48": "The agent always asks for the value of the slot with maximum entropy over the remaining entries in the database, which is optimal in the absence of language understanding errors, and serves as a baseline against our approach.", 
        "49": "Reinforcement learning neural turing machines (RLNTM) (Zaremba and Sutskever, 2015) also allow neural controllers to interact with discrete external interfaces.", 
        "50": "The interface considered in that work is a one-dimensional memory tape, while in our work it is an entity-centric KB.", 
        "51": "3 Probabilistic KB Lookup  This section describes a probabilistic framework for querying a KB given the agent\u2019s beliefs over the fields in the KB.", 
        "52": "3.1 Entity-Centric Knowledge Base (EC-KB)  A Knowledge Base consists of triples of the form (h, r, t), which denotes that relation r holds between the head h and tail t. We assume that the KB-InfoBot has access to a domain-specific entity-centric knowledge base (EC-KB) (Zwicklbauer et al., 2013) where all head entities are of a particular type (such as movies or persons), and the relations correspond to attributes of these head entities.", 
        "53": "Such a KB can be converted to a table format whose rows correspond to the unique head entities, columns correspond to the unique relation types (slots henceforth), and some entries may be missing.", 
        "54": "An example is shown in Figure 1.", 
        "55": "3.2 Notations and Assumptions  Let T denote the KB table described above and Ti,j denote the jth slot-value of the ith entity.", 
        "56": "1 \u2264 i \u2264 N and 1 \u2264 j \u2264M .", 
        "57": "We let V j denote the vocabulary of each slot, i.e.", 
        "58": "the set of all distinct values in the j-th column.", 
        "59": "We denote missing values from the table with a special token and write Ti,j = \u03a8. Mj = {i : Ti,j = \u03a8} denotes the set of entities for which the value of slot j is missing.", 
        "60": "Note that the user may still know the actual value of Ti,j , and we assume this lies in V j .", 
        "61": "We do not deal with new entities or relations at test time.", 
        "62": "We assume a uniform prior G \u223c U [{1, ...N}] over the rows in the table T , and let binary random variables \u03a6j \u2208 {0, 1} indicate whether the user knows the value of slot j or not.", 
        "63": "The agent maintains M multinomial distributions ptj(v) for v \u2208 V j denoting the probability at turn t that the user constraint for slot j is v, given their utterances\nU t1 till that turn.", 
        "64": "The agent also maintains M binomials qtj = Pr(\u03a6j = 1) which denote the probability that the user knows the value of slot j.", 
        "65": "We assume that column values are independently distributed to each other.", 
        "66": "This is a strong assumption but it allows us to model the user goal for each slot independently, as opposed to modeling the user goal over KB entities directly.", 
        "67": "Typically maxj |V j | < N and hence this assumption reduces the number of parameters in the model.", 
        "68": "3.3 Soft-KB Lookup  Let ptT (i) = Pr(G = i|U t1) be the posterior probability that the user is interested in row i of the table, given the utterances up to turn t. We assume all probabilities are conditioned on user inputs U t1 and drop it from the notation below.", 
        "69": "From our assumption of independence of slot values, we can write ptT (i) \u221d \u220fM j=1 Pr(Gj = i), where Pr(Gj = i) denotes the posterior probability of user goal for slot j pointing to Ti,j .", 
        "70": "Marginalizing this over \u03a6j gives:\nPr(Gj = i) =\n1\u2211\n\u03c6=0\nPr(Gj = i,\u03a6j = \u03c6) (1)\n= qtj Pr(Gj = i|\u03a6j = 1)+ (1\u2212 qtj) Pr(Gj = i|\u03a6j = 0).", 
        "71": "For \u03a6j = 0, the user does not know the value of the slot, and from the prior:\nPr(Gj = i|\u03a6j = 0) = 1\nN , 1 \u2264 i \u2264 N (2)\nFor \u03a6j = 1, the user knows the value of slot j, but this may be missing from T , and we again have two cases:\nPr(Gj = i|\u03a6j = 1) = { 1 N , i \u2208Mj\nptj(v) Nj(v)\n( 1\u2212 |Mj |\nN\n) , i 6\u2208Mj (3)\nHere, Nj(v) is the count of value v in slot j.", 
        "72": "Detailed derivation for (3) is provided in Appendix A.", 
        "73": "Combining (1), (2), and (3) gives us the procedure for computing the posterior over KB entities.", 
        "74": "4 Towards an End-to-End-KB-InfoBot  We claim that the Soft-KB lookup method has two benefits over the Hard-KB method \u2013 (1) it helps the agent discover better dialogue policies by providing it more information from the language understanding unit, (2) it allows end-to-end training of both dialogue policy and language understanding in an online setting.", 
        "75": "In this section we describe several agents to test these claims.", 
        "76": "4.1 Overview  Figure 2 shows an overview of the components of the KB-InfoBot.", 
        "77": "At each turn, the agent receives a natural language utterance ut as input, and selects an action at as output.", 
        "78": "The action space, denoted byA, consists ofM+1 actions \u2014 request(slot=i) for 1 \u2264 i \u2264 M will ask the user for the value of slot i, and inform(I) will inform the user with an ordered list of results I from the KB.", 
        "79": "The dialogue ends once the agent chooses inform.", 
        "80": "We adopt a modular approach, typical to goaloriented dialogue systems (Wen et al., 2016b), consisting of: a belief tracker module for identifying user intents, extracting associated slots, and tracking the dialogue state (Yao et al., 2014; Hakkani-Tu\u0308r et al., 2016; Chen et al., 2016b; Henderson et al., 2014; Henderson, 2015); an interface with the database to query for relevant results (Soft-KB lookup); a summary module to summarize the state into a vector; a dialogue policy which selects the next system action based on current state (Young et al., 2013).", 
        "81": "We assume the agent only responds with dialogue acts.", 
        "82": "A templatebased Natural Language Generator (NLG) can be easily constructed for converting dialogue acts into natural language.", 
        "83": "4.2 Belief Trackers  The InfoBot consists of M belief trackers, one for each slot, which get the user input xt and produce two outputs, ptj and q t j , which we shall collectively call the belief state: ptj is a multinomial distribution over the slot values v, and qtj is a scalar probability of the user knowing the value of slot j.", 
        "84": "We describe two versions of the belief tracker.", 
        "85": "Hand-Crafted Tracker: We first identify mentions of slot-names (such as \u201cactor\u201d) or slot-values (such as \u201cBill Murray\u201d) from the user input ut, using token-level keyword search.", 
        "86": "Let {w \u2208 x} de-\nnote the set of tokens in a string x3, then for each slot in 1 \u2264 j \u2264 M and each value v \u2208 V j , we compute its matching score as follows:\nstj [v] = |{w \u2208 ut} \u2229 {w \u2208 v}|\n|{w \u2208 v}| (4)\nA similar score btj is computed for the slot-names.", 
        "87": "A one-hot vector reqt \u2208 {0, 1}M denotes the previously requested slot from the agent, if any.", 
        "88": "qtj is set to 0 if reqt[j] is 1 but stj [v] = 0 \u2200v \u2208 V j , i.e.", 
        "89": "the agent requested for a slot but did not receive a valid value in return, else it is set to 1.", 
        "90": "Starting from an prior distribution p0j (based on the counts of the values in the KB), ptj [v] is updated as:\nptj [v] \u221d pt\u22121j [v] + C ( stj [v] + b t j + 1(req t[j] = 1) ) (5)\nHere C is a tuning parameter, and the normalization is given by setting the sum over v to 1.", 
        "91": "Neural Belief Tracker: For the neural tracker the user input ut is converted to a vector representation xt, using a bag of n-grams (with n = 2) representation.", 
        "92": "Each element of xt is an integer indicating the count of a particular n-gram in ut.", 
        "93": "We let V n denote the number of unique n-grams, hence xt \u2208 NV n0 .", 
        "94": "Recurrent neural networks have been used for belief tracking (Henderson et al., 2014; Wen et al., 2016b) since the output distribution at turn t depends on all user inputs till that turn.", 
        "95": "We use a Gated Recurrent Unit (GRU) (Cho et al., 2014) for each tracker, which, starting from h0j = 0 computes htj = GRU(x\n1, .", 
        "96": ".", 
        "97": ".", 
        "98": ", xt) (see Appendix B for details).", 
        "99": "htj \u2208 Rd can be interpreted as a summary of what the user has said about slot j till turn t. The belief states are computed from this vector as follows:\nptj = softmax(W p j h t j + b p j ) (6) qtj = \u03c3(W \u03a6 j h t j + b \u03a6 j ) (7)\nHere W pj \u2208 RV j\u00d7d, bpj \u2208 RV j , W\u03a6j \u2208 Rd and b\u03a6j \u2208 R, are trainable parameters.", 
        "100": "4.3 Soft-KB Lookup + Summary  This module uses the Soft-KB lookup described in section 3.3 to compute the posterior ptT \u2208 RN over the EC-KB from the belief states (ptj , q t j).", 
        "101": "3We use the NLTK tokenizer available at http://www.", 
        "102": "nltk.org/api/nltk.tokenize.html\nCollectively, outputs of the belief trackers and the soft-KB lookup can be viewed as the current dialogue state internal to the KB-InfoBot.", 
        "103": "Let st = [pt1, p t 2, ..., p t M , q t 1, q t 2, ..., q t M , p t T ] be the vector of\nsize \u2211\nj V j+M+N denoting this state.", 
        "104": "It is pos-\nsible for the agent to directly use this state vector to select its next action at.", 
        "105": "However, the large size of the state vector would lead to a large number of parameters in the policy network.", 
        "106": "To improve efficiency we extract summary statistics from the belief states, similar to (Williams and Young, 2005).", 
        "107": "Each slot is summarized into an entropy statistic over a distribution wtj computed from elements of the KB posterior ptT as follows:\nwtj(v) \u221d \u2211\ni:Ti,j=v ptT (i) + p 0 j (v)\n\u2211\ni:Ti,j=\u03a8 ptT (i) .", 
        "108": "(8) Here, p0j is a prior distribution over the values of slot j, estimated using counts of each value in the KB.", 
        "109": "The probability mass of v in this distribution is the agent\u2019s confidence that the user goal has value v in slot j.", 
        "110": "This two terms in (8) correspond to rows in KB which have value v, and rows whose value is unknown (weighted by the prior probability that an unknown might be v).", 
        "111": "Then the summary statistic for slot j is the entropy H(wtj).", 
        "112": "The KB posterior ptT is also summarized into an entropy statistic H(ptT ).", 
        "113": "The scalar probabilities qtj are passed as is to the dialogue policy, and the final summary vector is s\u0303t = [H(p\u0303t1), ...,H(p\u0303 t M ), q t 1, ..., q t M , H(p t T )].", 
        "114": "Note that this vector has size 2M + 1.", 
        "115": "4.4 Dialogue Policy  The dialogue policy\u2019s job is to select the next action based on the current summary state s\u0303t and the dialogue history.", 
        "116": "We present a hand-crafted baseline and a neural policy network.", 
        "117": "Hand-Crafted Policy: The rule based policy is adapted from (Wu et al., 2015).", 
        "118": "It asks for the slot j\u0302 = arg minH(p\u0303tj) with the minimum entropy, except if \u2013 (i) the KB posterior entropy H(ptT ) < \u03b1R, (ii) H(p\u0303 t j) < min(\u03b1T , \u03b2H(p\u0303 0 j ), (iii) slot j has already been requestedQ times.", 
        "119": "\u03b1R, \u03b1T , \u03b2,Q are tuned to maximize reward against the simulator.", 
        "120": "Neural Policy Network: For the neural approach, similar to (Williams and Zweig, 2016; Zhao and Eskenazi, 2016), we use an RNN to allow the network to maintain an internal state of\ndialogue history.", 
        "121": "Specifically, we use a GRU unit followed by a fully-connected layer and softmax nonlinearity to model the policy \u03c0 over actions in A (W \u03c0 \u2208 R|A|\u00d7d, b\u03c0 \u2208 R|A|):\nht\u03c0 = GRU(s\u0303 1, ..., s\u0303t) (9) \u03c0 = softmax(W \u03c0ht\u03c0 + b \u03c0) .", 
        "122": "(10)\nDuring training, the agent samples its actions from the policy to encourage exploration.", 
        "123": "If this action is inform(), it must also provide an ordered set of entities indexed by I = (i1, i2, .", 
        "124": ".", 
        "125": ".", 
        "126": ", iR) in the KB to the user.", 
        "127": "This is done by sampling R items from the KB-posterior ptT .", 
        "128": "This mimics a search engine type setting, where R may be the number of results on the first page.", 
        "129": "5 Training  Parameters of the neural components (denoted by \u03b8) are trained using the REINFORCE algorithm (Williams, 1992).", 
        "130": "We assume that the learner has access to a reward signal rt throughout the course of the dialogue, details of which are in the next section.", 
        "131": "We can write the expected discounted return of the agent under policy \u03c0 as J(\u03b8) = E\u03c0 [\u2211H t=0 \u03b3 trt ] (\u03b3 is the discounting factor).", 
        "132": "We also use a baseline reward signal b, which is the average of all rewards in a batch, to reduce the variance in the updates (Greensmith et al., 2004).", 
        "133": "When only training the dialogue policy \u03c0 using this signal, updates are given by (details in Appendix C):\n\u2207\u03b8J(\u03b8) = E\u03c0 [ H\u2211\nk=0\n\u2207\u03b8 log \u03c0\u03b8(ak) H\u2211\nt=0\n\u03b3t(rt\u2212b) ] ,\n(11) For end-to-end training we need to update both the dialogue policy and the belief trackers using the reinforcement signal, and we can view the retrieval as another policy \u00b5\u03b8 (see Appendix C).", 
        "134": "The updates are given by:\n\u2207\u03b8J(\u03b8) =Ea\u223c\u03c0,I\u223c\u00b5 [( \u2207\u03b8 log\u00b5\u03b8(I)+\nH\u2211\nh=0\n\u2207\u03b8 log \u03c0\u03b8(ah) ) H\u2211\nk=0\n\u03b3k(rk \u2212 b) ] ,\n(12)\nIn the case of end-to-end learning, we found that for a moderately sized KB, the agent almost always fails if starting from random initialization.", 
        "135": "In this case, credit assignment is difficult for the agent, since it does not know whether the failure is due to an incorrect sequence of actions or incorrect set of results from the KB.", 
        "136": "Hence, at the beginning of training we have an Imitation Learning (IL) phase where the belief trackers and policy network are trained to mimic the hand-crafted agents.", 
        "137": "Assume that p\u0302tj and q\u0302 t j are the belief states from a rule-based agent, and a\u0302t its action at turn t. Then the loss function for imitation learning is: L(\u03b8) = E [ D(p\u0302tj ||ptj(\u03b8))+H(q\u0302tj , qtj(\u03b8))\u2212log \u03c0\u03b8(a\u0302t) ]\nD(p||q) and H(p, q) denote the KL divergence and cross-entropy between p and q respectively.", 
        "138": "The expectations are estimated using a minibatch of dialogues of size B.", 
        "139": "For RL we use RMSProp (Hinton et al., 2012) and for IL we use vanilla SGD updates to train the parameters \u03b8.", 
        "140": "6 Experiments and Results  Previous work in KB-based QA has focused on single-turn interactions and is not directly comparable to the present study.", 
        "141": "Instead we compare different versions of the KB-InfoBot described above to test our claims.", 
        "142": "6.1 KB-InfoBot versions  We have described two belief trackers \u2013 (A) HandCrafted and (B) Neural, and two dialogue policies \u2013 (C) Hand-Crafted and (D) Neural.", 
        "143": "Rule agents use the hand-crafted belief trackers and hand-crafted policy (A+C).", 
        "144": "RL agents use the hand-crafted belief trackers and the neural policy (A+D).", 
        "145": "We compare three variants of both sets of agents, which differ only in the inputs to the dialogue policy.", 
        "146": "The No-KB version only takes entropy H(p\u0302tj) of each of the slot distributions.", 
        "147": "The Hard-KB version performs a hard-KB lookup and selects the next action based on the entropy of the slots over retrieved results.", 
        "148": "This is the same approach as in Wen et al.", 
        "149": "(2016b), except that we take entropy instead of summing probabilities.", 
        "150": "The Soft-KB version takes summary statistics of the slots and KB posterior described in Section 4.", 
        "151": "At the end of the dialogue, all versions inform the user with the top results from the KB posterior ptT , hence the difference only lies in the policy for action selection.", 
        "152": "Lastly, the E2E agent uses the neural belief tracker and the neural policy (B+D), with a Soft-KB lookup.", 
        "153": "For the RL agents, we also append q\u0302tj and a one-hot encoding of the previous\nagent action to the policy network input.", 
        "154": "Hyperparameter details for the agents are provided in Appendix D.  6.2 User Simulator  Training reinforcement learners is challenging because they need an environment to operate in.", 
        "155": "In the dialogue community it is common to use simulated users for this purpose (Schatzmann et al., 2007a,b; Cuaya\u0301huitl et al., 2005; Asri et al., 2016).", 
        "156": "In this work we adapt the publicly-available user simulator presented in Li et al.", 
        "157": "(2016b) to follow a simple agenda while interacting with the KB-InfoBot, as well as produce natural language utterances .", 
        "158": "Details about the simulator are included in Appendix E. During training, the simulated user also provides a reward signal at the end of each dialogue.", 
        "159": "The dialogue is a success if the user target is in top R = 5 results returned by the agent; and the reward is computed as max(0, 2(1 \u2212 (r \u2212 1)/R)), where r is the actual rank of the target.", 
        "160": "For a failed dialogue the agent receives a reward of \u22121, and at each turn it receives a reward of \u22120.1 to encourage short sessions4.", 
        "161": "The maximum length of a dialogue is 10 turns beyond which it is deemed a failure.", 
        "162": "6.3 Movies-KB  We use a movie-centric KB constructed using the IMDBPy5 package.", 
        "163": "We constructed four different splits of the dataset, with increasing number of entities, whose statistics are given in Table 1.", 
        "164": "The original KB was modified to reduce the number of actors and directors in order to make the task more challenging6.", 
        "165": "We randomly remove 20% of the values from the agent\u2019s copy of the KB to simulate a scenario where the KB may be incomplete.", 
        "166": "The user, however, may still know these values.", 
        "167": "4A turn consists of one user action and one agent action.", 
        "168": "5http://imdbpy.sourceforge.net/ 6We restricted the vocabulary to the first few unique values of these slots and replaced all other values with a random value from this set.", 
        "169": "6.4 Simulated User Evaluation  We compare each of the discussed versions along three metrics: the average rewards obtained (R), success rate (S) (where success is defined as providing the user target among top R results), and the average number of turns per dialogue (T).", 
        "170": "For the RL and E2E agents, during training we fix the model every 100 updates and run 2000 simulations with greedy action selection to evaluate its performance.", 
        "171": "Then after training we select the model with the highest average reward and run a further 5000 simulations and report the performance in Table 2.", 
        "172": "For reference we also show the performance of an agent which receives perfect information about the user target without any errors, and selects actions based on the entropy of the slots (Max).", 
        "173": "This can be considered as an upper bound on the performance of any agent (Wu et al., 2015).", 
        "174": "In each case the Soft-KB versions achieve the highest average reward, which is the metric all agents optimize.", 
        "175": "In general, the trade-off between minimizing average turns and maximizing success rate can be controlled by changing the reward signal.", 
        "176": "Note that, except the E2E version, all versions share the same belief trackers, but by re-asking values of some slots they can have different posteriors ptT to inform the results.", 
        "177": "This shows that having full information about the current state of beliefs over the KB helps the Soft-KB agent discover better policies.", 
        "178": "Further, reinforcement learning helps discover better policies than the handcrafted rule-based agents, and we see a higher reward for RL agents compared to Rule ones.", 
        "179": "This is due to the noisy natural language inputs; with perfect information the rule-based strategy is optimal.", 
        "180": "Interestingly, the RL-Hard agent has the minimum number of turns in 2 out of the 4 settings, at the cost of a lower success rate and average reward.", 
        "181": "This agent does not receive any information about the uncertainty in semantic parsing, and it tends to\ninform as soon as the number of retrieved results becomes small, even if they are incorrect.", 
        "182": "Among the Soft-KB agents, we see that E2E>RL>Rule, except for the X-Large KB.", 
        "183": "For E2E, the action space grows exponentially with the size of the KB, and hence credit assignment gets more difficult.", 
        "184": "Future work should focus on improving the E2E agent in this setting.", 
        "185": "The difficulty of a KB-split depends on number of entities it has, as well as the number of unique values for each slot (more unique values make the problem easier).", 
        "186": "Hence we see that both the \u201cSmall\u201d and \u201cX-Large\u201d settings lead to lower reward for the agents, since maxj |V\nj | N is small for them.", 
        "187": "6.5 Human Evaluation  We further evaluate the KB-InfoBot versions trained using the simulator against real subjects, recruited from the author\u2019s affiliations.", 
        "188": "In each session, in a typed interaction, the subject was first presented with a target movie from the \u201cMedium\u201d KB-split along with a subset of its associated slot-\nvalues from the KB.", 
        "189": "To simulate the scenario where end-users may not know slot values correctly, the subjects in our evaluation were presented multiple values for the slots from which they could choose any one while interacting with the agent.", 
        "190": "Subjects were asked to initiate the conversation by specifying some of these values, and respond to the agent\u2019s subsequent requests, all in natural language.", 
        "191": "We test RL-Hard and the three Soft-KB agents in this study, and in each session one of the agents was picked at random for testing.", 
        "192": "In total, we collected 433 dialogues, around 20 per subject.", 
        "193": "Figure 3 shows a comparison of these agents in terms of success rate and number of turns, and Figure 4 shows some sample dialogues from the user interactions with RL-Soft.", 
        "194": "In comparing Hard-KB versus Soft-KB lookup methods we see that both Rule-Soft and RL-Soft agents achieve a higher success rate than RL-Hard, while E2E-Soft does comparably.", 
        "195": "They do so in an increased number of average turns, but achieve a higher average reward as well.", 
        "196": "Between RL-Soft and Rule-Soft agents, the success rate is similar, however the RL agent achieves that rate in a lower number of turns on average.", 
        "197": "RL-Soft achieves a success rate of 74% on the human evaluation and 80% against the simulated user, indicating minimal overfitting.", 
        "198": "However, all agents take a higher number of turns against real users as compared to the simulator, due to the noisier inputs.", 
        "199": "The E2E gets the highest success rate against the simulator, however, when tested against real users it performs poorly with a lower success rate and a higher number of turns.", 
        "200": "Since it has more trainable components, this agent is also most prone to overfitting.", 
        "201": "In particular, the vocabulary of the simulator it is trained against is quite limited (V n = 3078), and hence when real users\nprovided inputs outside this vocabulary, it performed poorly.", 
        "202": "In the future we plan to fix this issue by employing a better architecture for the language understanding and belief tracker components Hakkani-Tu\u0308r et al.", 
        "203": "(2016); Liu and Lane (2016); Chen et al.", 
        "204": "(2016b,a), as well as by pretraining on separate data.", 
        "205": "While its generalization performance is poor, the E2E system also exhibits the strongest learning capability.", 
        "206": "In Figure 5, we compare how different agents perform against the simulator as the temperature of the output softmax in its NLG is increased.", 
        "207": "A higher temperature means a more uniform output distribution, which leads to generic simulator responses irrelevant to the agent questions.", 
        "208": "This is a simple way of introducing noise in the utterances.", 
        "209": "The performance of all agents drops as the temperature is increased, but less so for the E2E agent, which can adapt its belief tracker to the inputs it receives.", 
        "210": "Such adaptation\nis key to the personalization of dialogue agents, which motivates us to introduce the E2E agent.", 
        "211": "7 Conclusions and Discussion  This work is aimed at facilitating the move towards end-to-end trainable dialogue agents for information access.", 
        "212": "We propose a differentiable probabilistic framework for querying a database given the agent\u2019s beliefs over its fields (or slots).", 
        "213": "We show that such a framework allows the downstream reinforcement learner to discover better dialogue policies by providing it more information.", 
        "214": "We also present an E2E agent for the task, which demonstrates a strong learning capacity in simulations but suffers from overfitting when tested on real users.", 
        "215": "Given these results, we propose the following deployment strategy that allows a dialogue system to be tailored to specific users via learning from agent-user interactions.", 
        "216": "The system could start off with an RL-Soft agent (which gives good performance out-of-the-box).", 
        "217": "As the user interacts with this agent, the collected data can be used to train the E2E agent, which has a strong learning capability.", 
        "218": "Gradually, as more experience is collected, the system can switch from RL-Soft to the personalized E2E agent.", 
        "219": "Effective implementation of this, however, requires the E2E agent to learn quickly and this is the research direction we plan to focus on in the future.", 
        "220": "Acknowledgements  We would like to thank Dilek Hakkani-Tu\u0308r and reviewers for their insightful comments on the paper.", 
        "221": "We would also like to acknowledge the volunteers from Carnegie Mellon University and Microsoft Research for helping us with the human evaluation.", 
        "222": "Yun-Nung Chen is supported by the Ministry of Science and Technology of Taiwan under the contract number 105-2218-E-002-033, Institute for Information Industry, and MediaTek.", 
        "223": "A Posterior Derivation  Here, we present a derivation for equation 3, i.e., the posterior over the KB slot when the user knows the value of that slot.", 
        "224": "For brevity, we drop \u03a6j = 0 from the condition in all probabilities below.", 
        "225": "For the case when i \u2208Mj , we can write:\nPr(Gj = i)\n= Pr(Gj \u2208Mj) Pr(Gj = i|Gj \u2208Mj) = |Mj | N 1 |Mj | = 1 N , (13)\nwhere we assume all missing values to be equally likely, and estimate the prior probability of the goal being missing from the count of missing values in that slot.", 
        "226": "For the case when i = v 6\u2208Mj :\nPr(Gj = i)\n= Pr(Gj 6\u2208Mj) Pr(Gj = i|Gj 6\u2208Mj)\n= ( 1\u2212 |Mj |\nN\n) \u00d7 ptj(v)\nNj(v) , (14)\nwhere the second term comes from taking the probability mass associated with v in the belief tracker and dividing it equally among all rows with value v.\nWe can also verify that the above distribution is valid: i.e., it sums to 1:\n\u2211\ni\nPr(Gj = i)\n= \u2211\ni\u2208Mj Pr(Gj = i) +\n\u2211\ni 6\u2208Mj Pr(Gj = i)\n= \u2211\ni\u2208Mj\n1 N + \u2211\ni 6\u2208Mj\n( 1\u2212 |Mj |\nN\n) ptj(v)\n#jv\n= |Mj | N +\n( 1\u2212 |Mj |\nN\n) \u2211\ni 6\u2208Mj\nptj(v)\n#jv\n= |Mj | N +\n( 1\u2212 |Mj |\nN\n)\u2211\ni\u2208V j #jv\nptj(v)\n#jv\n= |Mj | N +\n( 1\u2212 |Mj |\nN\n) \u00d7 1\n= 1 .", 
        "227": "B Gated Recurrent Units  A Gated Recurrent Unit (GRU) (Cho et al., 2014) is a recurrent neural network which operates on an input sequence x1, .", 
        "228": ".", 
        "229": ".", 
        "230": ", xt.", 
        "231": "Starting from an initial\nstate h0 (usually set to 0 it iteratively computes the final output ht as follows:\nrt = \u03c3(Wrxt + Urht\u22121 + br)\nzt = \u03c3(Wzxt + Uzht\u22121 + bz)\nh\u0303t = tanh(Whxt + Uh(rt ht\u22121) + bh) ht = (1\u2212 zt) ht\u22121 + zt h\u0303t .", 
        "232": "(15)\nHere \u03c3 denotes the sigmoid nonlinearity, and an element-wise product.", 
        "233": "C REINFORCE updates  We assume that the learner has access to a reward signal rt throughout the course of the dialogue, details of which are in the next section.", 
        "234": "We can write the expected discounted return of the agent under policy \u03c0 as follows:\nJ(\u03b8) = E\n[ H\u2211\nt=0\n\u03b3trt ] (16)\nHere, the expectation is over all possible trajectories \u03c4 of the dialogue, \u03b8 denotes the trainable parameters of the learner, H is the maximum length of an episode, and \u03b3 is the discounting factor.", 
        "235": "We can use the likelihood ratio trick (Glynn, 1990) to write the gradient of the objective as follows:\n\u2207\u03b8J(\u03b8) = E [ \u2207\u03b8 log p\u03b8(\u03c4) H\u2211\nt=0\n\u03b3trt ] , (17)\nwhere p\u03b8(\u03c4) is the probability of observing a particular trajectory under the current policy.", 
        "236": "With a Markovian assumption, we can write\np\u03b8(\u03c4) = p(s0) H\u220f\nk=0\np(sk+1|sk, ak)\u03c0\u03b8(ak|sk),\n(18) where \u03b8 denotes dependence on the neural network parameters.", 
        "237": "From 17,18 we obtain\n\u2207\u03b8J(\u03b8) = Ea\u223c\u03c0 [ H\u2211\nk=0\n\u2207\u03b8 log \u03c0\u03b8(ak) H\u2211\nt=0\n\u03b3trt ] ,\n(19) If we need to train both the policy network and the belief trackers using the reinforcement signal, we can view the KB posterior ptT as another policy.", 
        "238": "During training then, to encourage exploration, when the agent selects the inform action we\nsampleR results from the following distribution to return to the user:\n\u00b5(I) = ptT (i1)\u00d7 ptT (i2)\n1\u2212 ptT (i1) \u00d7 \u00b7 \u00b7 \u00b7 .", 
        "239": "(20)\nThis formulation also leads to a modified version of the episodic REINFORCE update rule (Williams, 1992).", 
        "240": "Specifically, eq.", 
        "241": "18 now becomes,\np\u03b8(\u03c4) = [ p(s0) H\u220f\nk=0\np(sk+1|sk, ak)\u03c0\u03b8(ak|sk) ] \u00b5\u03b8(I),\n(21) Notice the last term \u00b5\u03b8 above which is the posterior of a set of results from the KB.", 
        "242": "From 17,21 we obtain\n\u2207\u03b8J(\u03b8) =Ea\u223c\u03c0,I\u223c\u00b5 [( \u2207\u03b8 log\u00b5\u03b8(I)+\nH\u2211\nh=0\n\u2207\u03b8 log \u03c0\u03b8(ah) ) H\u2211\nk=0\n\u03b3krk ] , (22)  D Hyperparameters  We use GRU hidden state size of d = 50 for the RL agents and d = 100 for the E2E, a learning rate of 0.05 for the imitation learning phase and 0.005 for the reinforcement learning phase, and minibatch size 128.", 
        "243": "For the rule agents, hyperparameters were tuned to maximize the average reward of each agent in simulations.", 
        "244": "For the E2E agent, imitation learning was performed for 500 updates, after which the agent switched to reinforcement learning.", 
        "245": "The input vocabulary is constructed from the NLG vocabulary and bigrams in the KB, and its size is 3078.", 
        "246": "E User Simulator  At the beginning of each dialogue, the simulated user randomly samples a target entity from the ECKB and a random combination of informable slots for which it knows the value of the target.", 
        "247": "The remaining slot-values are unknown to the user.", 
        "248": "The user initiates the dialogue by providing a subset of its informable slots to the agent and requesting for an entity which matches them.", 
        "249": "In subsequent turns, if the agent requests for the value of a slot, the user complies by providing it or informs the agent that it does not know that value.", 
        "250": "If the agent informs results from the KB, the simulator checks whether the target is among them and provides the reward.", 
        "251": "We convert dialogue acts from the user into natural language utterances using a separately trained natural language generator (NLG).", 
        "252": "The NLG is trained in a sequence-to-sequence fashion, using conversations between humans collected by crowd-sourcing.", 
        "253": "It takes the dialogue actions (DAs) as input, and generates template-like sentences with slot placeholders via an LSTM decoder.", 
        "254": "Then, a post-processing scan is performed to replace the slot placeholders with their actual values, which is similar to the decoder module in (Wen et al., 2015, 2016a).", 
        "255": "In the LSTM decoder, we apply beam search, which iteratively considers the top k best sentences up to time step t when generating the token of the time step t+ 1.", 
        "256": "For the sake of the trade-off between the speed and performance, we use the beam size of 3 in the following experiments.", 
        "257": "There are several sources of error in user utterances.", 
        "258": "Any value provided by the user may be corrupted by noise, or substituted completely with an incorrect value of the same type (e.g., \u201cBill Murray\u201d might become just \u201cBill\u201d or \u201cTom Cruise\u201d).", 
        "259": "The NLG described above is inherently stochastic, and may sometimes generate utterances irrelevant to the agent request.", 
        "260": "By increasing the temperature of the output softmax in the NLG we can increase the noise in user utterances."
    }, 
    "document_id": "P17-1045.pdf.json"
}
