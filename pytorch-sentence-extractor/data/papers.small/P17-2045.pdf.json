{
    "abstract_sentences": {
        "1": "We propose a model to automatically describe changes introduced in the source code of a program using natural language.", 
        "2": "Our method receives as input a set of code commits, which contains both the modifications and message introduced by an user.", 
        "3": "These two modalities are used to train an encoder-decoder architecture.", 
        "4": "We evaluated our approach on twelve real world open source projects from four different programming languages.", 
        "5": "Quantitative and qualitative results showed that the proposed approach can generate feasible and semantically sound descriptions not only in standard in-project settings, but also in a cross-project setting."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Short Papers), pages 287\u2013292 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-2045  1 Introduction  Source code, while conceived as a set of structured and sequential instructions, inherently reflects human intent: it encodes the way we command a machine to perform a task.", 
        "2": "In that sense, it is expected that it follows to some extent the same distributional regularities that a proper natural language manifests (Hindle et al., 2012).", 
        "3": "Moreover, the unambiguous nature of source code, comprised in plain and human-readable format, allows an indirect way of communication between developers, a phenomenon boosted in recent years given the current software development paradigm, where billions of lines code are written in a distributed and asynchronous way (Gousios et al., 2014).", 
        "4": "The scale and complexity of software systems these days has naturally led to explore automated ways to support developers\u2019 code comprehension (Letovsky, 1987) from a linguistic perspective.", 
        "5": "One of these attempts is automatic summarization, which aims to generate a compact representation\nof the source code in a portion of natural language (Haiduc et al., 2010).", 
        "6": "While existing code summarization methods are able to provide relevant insights about the purpose and functional features of the code, their scope is inherently static.", 
        "7": "In contrast, software development can be seen as a sequence of incremental changes, intended to either generate a new functionality or to repair an existing one.", 
        "8": "Source code changes are critical for understanding program evolution, which motivated us to explore if it is possible to extend the notion of summarization to encode code changes into natural language representations, i.e., develop a model able to explain a source code level modification.", 
        "9": "With this, we envision a tool for developers that is able to i) ease the comprehension of the dynamics of the system, which could be useful for debugging and repairing purposes and ii) automate the documentation of source code changes.", 
        "10": "To this end, we rely on the concept of code commit, the standard contribution procedure implemented in modern subversion systems (Gousios et al., 2014), which provides both the actual change and a short explanatory paragraph.", 
        "11": "Our model consists of an encoder-decoder architecture which is trained on a set of triples conformed by the version of a system before and after the change, along with the comment.", 
        "12": "Given the high heterogeneity of the modalities involved, we rely on an attention mechanism to efficiently learn the parts of the sequences that are more expressive and have more explanatory power.", 
        "13": "We performed an empirical study on twelve real world software systems, from which we obtained the commit activity to evaluate our model.", 
        "14": "Our experiments explored in-project and crossproject scenarios, and our results showed that the proposed model is able to generate semantically sound descriptions.", 
        "15": "287  2 Related Work  The use natural language processing to support software engineering tasks has increased consistently over the years, mainly in terms of source code search, traceability and program feature location (Panichella et al., 2013; Asuncion et al., 2010).", 
        "16": "The emergence of unifying paradigms that explicitly relate programming and natural languages in distributional terms (Hindle et al., 2012) and the availability of large corpus mainly from open source software opened the door for the use of language modeling for several tasks (Raychev et al., 2015).", 
        "17": "Examples of this are approaches for learning program representations (Mou et al., 2016), bug localization (Huo et al.", 
        "18": "), API suggestion (Gu et al., 2016) and code completion (Raychev et al., 2014).", 
        "19": "Source code summarization has received special attention, ranging from the use of information retrieval techniques to the addition of physiological features such as eye tracking (Rodeghero et al., 2014).", 
        "20": "In recent years several representation learning approaches have been proposed, such as (Allamanis et al., 2016), where the authors employ a convolutional architecture embedded inside an attention mechanism to learn an efficient mapping between source code tokens and natural language keywords.", 
        "21": "More recently, (Iyer et al., 2016) proposed a encoder-decoder model that learns to summarize from Stackoverflow data, which contains snippet of code along with descriptions.", 
        "22": "Both approaches share the use of attention mechanisms (Bahdanau et al., 2014) to overcome the natural disparity between the modalities when finding relevant token alignments.", 
        "23": "Although we also use an attention mechanism, we differ from them in the sense we are targeting the changes in the code rather than the description of a file.", 
        "24": "In terms of specifically working on code change summarization, Corte\u0301s-Coy et al.", 
        "25": "(2014); LinaresVa\u0301squez et al.", 
        "26": "(2015) propose a method based on a set of rules that considers the type and impact of the changes, and (Buse and Weimer, 2010) combines summarization with symbolic execution.", 
        "27": "To the best of our knowledge, our approach represents the first attempt to generate natural language descriptions from code changes without the use of hand-crafted features, a desirable setting given the heterogeneity of the data involved.", 
        "28": "3 Proposed Model  Our model assumes the existence of T versions of a given project {v1, .", 
        "29": ".", 
        "30": ".", 
        "31": ", vT }.", 
        "32": "Given a pair of consecutive versions (vt\u22121, vt), we define the tuple (Ct, Nt), where Ct = \u2206tt\u22121(v) represents a code snippet associated to changes over v in time t and Nt represents its corresponding natural language (NL) description.", 
        "33": "Let C be the set of all source code snippets and N be the set of all descriptions in NL.", 
        "34": "We consider a training corpus with T code snippets and summary pairs (Ct, Nt), 1 \u2264 t \u2264 T , Ct \u2208 C , Nt \u2208 N. Then, for a given code snippet Ck \u2208 C, the goal of our model is to produce the most likely NL description N?.", 
        "35": "Concretely, similarly to (Iyer et al., 2016), we use an attention-augmented encoder-decoder architecture.", 
        "36": "The encoder can be seen as a lookup layer, which simply reads through the source input sequence and returns the embedded tokens.", 
        "37": "The decoder is a RNN that reads this representation and generates NL words one at a time based on its current hidden state and guided by a global attention model (Luong et al., 2015).", 
        "38": "We model the probability of a description as a product of the conditional next-word probabilities.", 
        "39": "More formally, for each NL token ni \u2208 Nt we define,\nhi = f(ni\u22121E, hi\u22121) (1)\np(ni|n1, ..., ni\u22121) \u221d W tanh(W1hi +W2ai) (2)\nwhere E is the embedding matrix for NL tokens, \u221d denotes a softmax operation, hi represents the hidden state and ai is the contribution from the attention model on the source code.", 
        "40": "W , W1 and W2 are trainable combination matrices.", 
        "41": "The decoder repeats the recurrence until a fixed number of words or a special END token is generated.", 
        "42": "The attention contribution ai is defined as ai = \u2211k j=1 \u03b1i,j \u00b7 cjF , where cj \u2208 Ct is a source code token, F is the source code token embedding matrix and \u03b1i,j is:\n\u03b1i,j = exp (h>i cjF )\u2211\ncj\u2208Ct exp (h > i cjF )\n(3)\nWe use a dropout-regularized LSTM cell for the decoder (Zaremba et al., 2015) and also add dropout at the NL embeddings and at the output softmax layer, to prevent over-fitting.", 
        "43": "We added special START and END tokens to our training sequences and replaced all tokens and output words occurring less than 2 and 3 times, respectively,\nwith a special UNK token.", 
        "44": "We set the maximum code and NL length to be 100 tokens.", 
        "45": "For decoding, we approximate N?", 
        "46": "by performing a beam search on the space of all possible summaries using the model output, with a beam size of 10 and a maximum summary length of 20 words.", 
        "47": "To evaluate the quality of our generated descriptions we use both METEOR (Lavie and Agarwal, 2007) and sentence level BLEU-4 (Papineni et al., 2002).", 
        "48": "Since the training objective does not directly optimize for these scores, we compute METEOR on our validation set after every epoch and save the intermediate model that gives the maximum score as the final model.", 
        "49": "For evaluation on our test set we used the BLEU-4 score.", 
        "50": "4 Empirical Study  Data and pre-processing: We captured historical data from twelve open source projects hosted on Github based on their popularity and maturity, selecting 3 projects for each of the following languages: python, java, javascript and c++.", 
        "51": "For each project, we downloaded diff files and metadata of the full commit history.", 
        "52": "Diff files encode per-line differences between two files or sets of files in a standard format, allowing us to recover source code changes in each commit at the line level.", 
        "53": "On the other hand, medatada allows us to recover information such as the author and message of each commit.", 
        "54": "The extracted commit messages were processed using the Penn Treebank tokenizer (Marcus et al., 1993), which nicely deals with punctuation and other text marks.", 
        "55": "To obtain a source code representation of each commit, we parsed the diff files and used a lexer (Brandl, 2016) to tokenize their contents in a per-line fashion allowing us to maximize the amount of source code recovered from the diff files.", 
        "56": "Data and source code available1.", 
        "57": "Experimental Setup: Given the flat structure of the diff file, source code in contiguous lines might not necessarily correspond to originally neighboring code lines.", 
        "58": "Moreover, they might come from different files in the project.", 
        "59": "To deal with this issue, we first worked only with those commits that modify a single file in the project; we call this the atomicity assumption.", 
        "60": "By using only atomic commits we reduced our training data by an average of roughly 50%, but in exchange we made sure all the extracted code lines came from\n1http://github.com/epochx/commitgen\nthe same file.", 
        "61": "At the same time, we expect to maximize the likelihood of observing a direct relation between the commit message and the lines altered.", 
        "62": "We then relaxed our atomicity assumption and experimented with the full commit history.", 
        "63": "Given our maximum sequence length constrain of 100 tokens, we only observed an average of 1,97% extra data on each project.", 
        "64": "Since source code lines may come from different files, we added a delimiting token NEW FILE when corresponding.", 
        "65": "We were also interested in studying the performance of the model in a cross-project setting.", 
        "66": "Given the additional challenges that this involves, we designed a more controlled experiment.", 
        "67": "Starting from the atomic dataset, we selected commits that only add or only remove code lines, conforming a derived dataset that we call uni-action.", 
        "68": "We chose the python language to maximize the available data.", 
        "69": "See Table 1.", 
        "70": "Results and Discussion: We begin by training our model on the atomic dataset.", 
        "71": "As baseline we used MOSES (Koehn et al., 2007) which although is designed as a phrase-based machine translation system, was previously used by Iyer et al.", 
        "72": "(2016) to generate text from source code.", 
        "73": "Concretely, we treated the tokenized code snippet as the source language and the NL description as the target.", 
        "74": "We trained a 3-gram language model using KenLM (Heafield et al., 2013) and used mGiza to obtain alignments.", 
        "75": "For validation, we use minimum error rate training (Bertoldi et al., 2009; Och, 2003) in our validation set.", 
        "76": "As Table 3 shows, our model trained on atomic data outperforms the baseline in all but one project with an average gain of 5 BLEU points.", 
        "77": "In particular, we observe bigger gains for java projects such as CoreNLP and guava.", 
        "78": "We hypothesize this is because program differences in Java tend to be longer than the rest.", 
        "79": "While this impacts on training time, at the same time it allows the model to\nwork with a larger vocabulary space.", 
        "80": "On the other hand, our model performs similarly to MOSES for the node and slightly worse for the youtube-dl.", 
        "81": "A detailed inspection of the NL messages for node showed that many of them exhibit a fixed pattern in their structure.", 
        "82": "We believe this rigidity restrains the generation capabilities of the decoder, making it more prone to memorization.", 
        "83": "Table 2 shows examples of generated descriptions for real changes and their references.", 
        "84": "Results suggest that our model is able to generate semantically sound descriptions for the changes.", 
        "85": "We can also visualize the summarizing power of the model, as seen in the Theano and bitcoin examples.", 
        "86": "We observe a tendency to choose more general terms over too specific ones meanwhile also avoiding irrelevant words such as numbers or names.", 
        "87": "Results also suggest the emergence of rephrasing capabilities, specifically in the second example from Theano.", 
        "88": "Finally, our generated descriptions are, in most cases, semantically well correlated to the reference descriptions.", 
        "89": "We also report not so successful results, such as case of youtube-dl, where we can see signs of memorization on the generated descriptions.", 
        "90": "Regarding the cross-project setting experiments on python, we obtained BLEU scores of 14.6 and 18.9 for only-adding and only-removing instances in the uni-action dataset, respectively.", 
        "91": "We also obtained validation accuracies up to 43.94%, suggesting feasibility in this more challenging scenario.", 
        "92": "Moreover, as the generated descriptions from the keras project in Table 2 show, the model is still able to generate semantically sound descriptions.", 
        "93": "Despite the small data increase, we also trained our model on full datasets as a way to confirm the generative power of our model.", 
        "94": "In particular, we wanted to test the model is able leverage on atomic data to also capture and compress multifile changes.", 
        "95": "As shown in Table 3, results in terms of BLEU and validation accuracy manifest reasonable consistency, despite the higher disparity be-\ntween source code and natural language on this dataset, which means the model was able to learn representations with more compressive power.", 
        "96": "Soft alignments derived from Figure 1, which shows examples of attention heatmaps, illustrate how the model effectively associates source code tokens with meaningful words.", 
        "97": "5 Conclusion and Future work  We proposed an encoder-decoder model for automatically generating natural descriptions from source code changes.", 
        "98": "We believe our current results suggest that the idea is feasible and, if improved, could represent a contribution for the understanding of software evolution from a linguistic perspective.", 
        "99": "As future work, we will consider improving the model by allowing feature learning from richer inputs, such as abstract syntax trees and also functional data, such as execution traces."
    }, 
    "document_id": "P17-2045.pdf.json"
}
