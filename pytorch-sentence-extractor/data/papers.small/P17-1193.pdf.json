{
    "abstract_sentences": {
        "1": "We study the Maximum Subgraph problem in deep dependency parsing.", 
        "2": "We consider two restrictions to deep dependency graphs: (a) 1-endpoint-crossing and (b) pagenumber-2.", 
        "3": "Our main contribution is an exact algorithm that obtains maximum subgraphs satisfying both restrictions simultaneously in time O(n5).", 
        "4": "Moreover, ignoring one linguistically-rare structure descreases the complexity to O(n4).", 
        "5": "We also extend our quartic-time algorithm into a practical parser with a discriminative disambiguation model and evaluate its performance on four linguistic data sets used in semantic dependency parsing."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 2110\u20132120 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1193  1 Introduction  Dependency parsing has long been studied as a central issue in developing syntactic or semantic analysis.", 
        "2": "Recently, some linguistic projects grounded on deep grammar formalisms, including CCG, LFG, and HPSG, draw attentions to rich syntactic and semantic dependency annotations that are not limited to trees (Hockenmaier and Steedman, 2007; Sun et al., 2014; Ivanova et al., 2012).", 
        "3": "Parsing for these deep dependency representations can be viewed as the search for Maximum Subgraphs (Kuhlmann and Jonsson, 2015).", 
        "4": "This is a natural extension of the Maximum Spanning Tree (MST) perspective (McDonald et al., 2005) for dependency tree parisng.", 
        "5": "One main challenge of the Maximum Subgraph perspective is to design tracTable algorithms for certain graph classes that have good empirical coverage for linguistic annotations.", 
        "6": "Unfortunately, no previously defined class simultaneously has high\n\u2217The first two authors contribute equally.", 
        "7": "coverage and low-degree polynomial parsing algorithms.", 
        "8": "For example, noncrossing dependency graphs can be found in time O(n3), but cover only 48.23% of sentences in CCGBank (Kuhlmann and Jonsson, 2015).", 
        "9": "We study two well-motivated restrictions to deep dependency graphs: (a) 1-endpoint-crossing (1EC hereafter; Pitler et al., 2013) and (b) pagenumber is less than or equal to 2 (P2 hereafter; Kuhlmann and Jonsson, 2015).", 
        "10": "We will show that if the output dependency graphs are restricted to satisfy both restrictions, the Maximum Subgraph problem can be solved using dynamic programming in time O(n5).", 
        "11": "Moreover, if we ignore one linguistically-rare sub-problem, we can reduce the time complexity to O(n4).", 
        "12": "Though this new algorithm is a degenerated one, it has the same empirical coverage for various deep dependency annotations.", 
        "13": "We evaluate the coverage of our algorithms on four linguistic data sets: CCGBank, DeepBank, Enju HPSGBank and Prague Dependency TreeBank.", 
        "14": "They cover 95.68%, 97.67%, 97.28% and 97.53% of dependency graphs in the four corpora.", 
        "15": "The relatively satisfactory coverage makes it possible to parse with high accuracy.", 
        "16": "Based on the quartic-time algorithm, we implement a parser with a discriminative disambiguation model.", 
        "17": "Our new parser can be taken as a graph-based parser which is complementary to transition-based (Henderson et al., 2013; Zhang et al., 2016) and factorization-based (Martins and Almeida, 2014; Du et al., 2015a) systems.", 
        "18": "We evaluate our parser on four data sets: those used in SemEval 2014 Task 8 (Oepen et al., 2014), and the dependency graphs extracted from CCGbank (Hockenmaier and Steedman, 2007).", 
        "19": "Evaluations indicate that our parser produces very accurate deep dependency analysis.", 
        "20": "It reaches state-of-the-art results on average produced by a transition-based system of Zhang et al.", 
        "21": "2110\n(2016) and factorization-based systems (Martins and Almeida, 2014; Du et al., 2015a).", 
        "22": "The implementation of our parser is available at http://www.icst.pku.edu.cn/ lcwm/grass.", 
        "23": "2 Background  Dependency parsing is the task of mapping a natural language sentence into a dependency graph.", 
        "24": "Previous work on dependency parsing mainly focused on tree-shaped representations.", 
        "25": "Recently, it is shown that data-driven parsing techniques are also applicable to generate more flexible deep dependency graphs (Du et al., 2014; Martins and Almeida, 2014; Du et al., 2015b,a; Zhang et al., 2016; Sun et al., 2017).", 
        "26": "Parsing for deep dependency representations can be viewed as the search for Maximum Subgraphs for a certain graph class G (Kuhlmann and Jonsson, 2015), a generalization of the MST perspective for tree parsing.", 
        "27": "In particular, we have the following optimization problem: Given an arc-weighted graphG = (V, A), find a subgraph G\u2032 = (V,A\u2032 \u2286 A) with maximum total weight such that G\u2032 belongs to G. The choice of G determines the computational complexity of dependency parsing.", 
        "28": "For example, if G is the set of projective trees, the problem can be solved in time O(|V |3), and if G is the set of noncrossing dependency graphs, the complexity is O(|V |3).", 
        "29": "Unfortunately, no previously defined class simultaneously has high coverage on deep dependency annotations and low-degree polynomial decoding algorithms for practical parsing.", 
        "30": "In this paper, we study well-motivated restrictions: 1EC (Pitler et al., 2013) and P2 (Kuhlmann and Jonsson, 2015).", 
        "31": "We will show that relatively satisfactory coverage and parsing complexity can be obtained for graphs that satisfy both restrictions.", 
        "32": "3 The 1EC, P2 Graphs    3.1 The 1EC Restriction  Pitler et al.", 
        "33": "(2013) introduced a very nice property for modelling non-projective dependency trees, i.e.", 
        "34": "1EC.", 
        "35": "This property not only covers a large amount of tree annotations in natural language treebanks, but also allows the corresponding MST problem to bo solved in time ofO(n4).", 
        "36": "The formal description of the 1EC property is adopted from (Pitler et al., 2013).", 
        "37": "Definition 1.", 
        "38": "Edges e1 and e2 cross if e1 and e2\nhave distinct endpoints and exactly one of the endpoints of e1 lies between the endpoints of e2.", 
        "39": "Definition 2.", 
        "40": "A dependency graph is 1-EndpointCrossing if for any edge e, all edges that cross e share an endpoint p.\nGiven a sentence s = w0w1 \u00b7 \u00b7 \u00b7wn\u22121 of length n, the vertices, i.e.", 
        "41": "words, are indexed with integers, an arc from wi to wj as a(i,j), and the common endpoint, namely pencil point, of all edges crossed with a(i,j) or a(j,i) as pt(i, j).", 
        "42": "We denote an edge as e(i,j), if we do not consider its direction.", 
        "43": "3.2 The P2 Restriction  The term pagenumber is referred to as planar by some other authors, e.g.", 
        "44": "(Titov et al., 2009; Go\u0301mez-Rodr\u0131\u0301guez and Nivre, 2010; Pitler et al., 2013).", 
        "45": "We give the definition of related concepts as follows.", 
        "46": "Definition 3.", 
        "47": "A book is a particular kind of topological space that consists of a single line called the spine, together with a collection of one or more half-planes, called the pages, each having the spine as its boundary.", 
        "48": "Definition 4.", 
        "49": "A book embedding of a finite graph G onto a book B satisfies three conditions: (1) every vertex of G is drawn as a point on the spine of B; (2) every edge of G is drawn as a curve that lies within a single page of B; (3) every page of B does not have any edge crossings.", 
        "50": "Empirically, a deep dependency graph is not very dense and can typically be embedded onto a very thin book.", 
        "51": "To measure the thickness of a graph, we can use its pagenumber.", 
        "52": "Definition 5.", 
        "53": "The book pagenumber of G is the minimum number of pages required for a book embedding of G.\nFor sake of concision, we say a graph is \u201cpagenumber-k\u201d, meaning that the pagenumber is at most k.\nTheorem 1.", 
        "54": "The pagenumber of 1EC graph may be greater than 2.", 
        "55": "Proof.", 
        "56": "The graph in Figure 1 gives an instance which is 1EC but the pagenumber of which is 3.", 
        "57": "There is a cycle, namely a \u2192 c \u2192 e \u2192 b \u2192 d \u2192 a, consisting of odd number of edges.", 
        "58": "Pitler et al.", 
        "59": "(2013) proved that 1EC trees are a subclass of graphs whose pagenumber is at most 2.", 
        "60": "This property provides the foundation to the\nsuccess in designing dynamic programming algorithms for trees.", 
        "61": "Theorem 1 indicates that when we consider more general graph, the case is more complicated.", 
        "62": "In this paper, we study graphs that are constrained to be both 1EC and P2.", 
        "63": "We call them 1EC/P2 graphs.", 
        "64": "3.3 Coverage on Linguistic Data  To show that the two restrictions above are wellmotivated for describing linguistic data, we evaluate their empirical coverage on four deep dependency corpora (as defined in Section 5.2).", 
        "65": "These corpora are also used for training and evaluating our data-driven parsers.", 
        "66": "The coverage is evaluated using sentences in the training sets.", 
        "67": "Table 1 shows the results.", 
        "68": "We can see that 1EC is also an empirical well-motivated restriction when it comes to deep dependency structures.", 
        "69": "The P2 property has an even better coverage.", 
        "70": "Unfortunately, it is a NP-hard problem to find optimal P2 graphs (Kuhlmann and Jonsson, 2015).", 
        "71": "Though theoretically a 1EC graph is not necessarily P2, the empirical evaluation demonstrates the high overlap of them on linguistic annotations.", 
        "72": "In particular, almost all 1EC deep dependency graphs are P2.", 
        "73": "The percentages of graphs satisfying both restrictions vary between 95.68% for CCGBank and 97.67% for DeepBank.", 
        "74": "The relatively satisfactory coverage enables accurate practical parsing.", 
        "75": "4 The Algorithm  This section contains the main contribution of this paper: a polynomial time exact algorithm for solving the Maximum Subgraph problem for the class\nof 1EC/P2 graphs.", 
        "76": "Theorem 2.", 
        "77": "Take 1EC/P2 graphs as target subgraphs, the maximum subgraph problem can be solved in time O(|V |5).", 
        "78": "For sake of formal concision, we introduce the algorithm of which the goal is to calculate the maximum score of a subgraph.", 
        "79": "Extracting corresponding optimal graphs can be done in a number of ways.", 
        "80": "For example, we can maintain an auxiliary arc table which is populated parallel to the procedure of obtaining maximum scores.", 
        "81": "Our algorithm is highly related to the following property: Every subgraph of a 1EC/P2 graph is also a 1EC/P2 graph.", 
        "82": "We therefore focus on maximal 1EC/P2 graphs, a particular type of 1EC/P2 graphs defined as follows.", 
        "83": "Definition 6.", 
        "84": "A maximal 1EC/P2 graph is a 1EC/P2 graph that cannot be extended by including one more edge.", 
        "85": "Our algorithm is a bottom-up dynamic programming algorithm.", 
        "86": "It defines different structures corresponding to different sub-problems, and visits all structures from bottom to top, finding the best combination of smaller structures to form a new structure.", 
        "87": "The key design is to make sure that it can produce all maximal 1EC/P2 graphs.", 
        "88": "During the search for maximal 1EC/P2 graphs, we can freely delete bad edges whose scores are negative.", 
        "89": "In particular, we figure out some edges, in each construction step, which can be created without violating either 1EC or P2 restriction.", 
        "90": "Assume the arc weight associated with a(i,j) is w[i, j].", 
        "91": "Then we define a function SELECT(i, j) according to the comparison of 0 and w[i, j] as well as w[j, i].", 
        "92": "If w[i, j] \u2265 0 (or w[j, i] \u2265 0), we then select a(i,j) (or a(j,i)) and add it to currently the best solution of a sub-problem.", 
        "93": "SELECT(i, j) returns max(max(0, w[i, j]) + max(0, w[j, i])).", 
        "94": "If we allow at most one arc between two nodes, SELECT(i, j) returns max(0, w[i, j], w[j, i]).", 
        "95": "The graphical illustration of our algorithm uses undirected graphs1.", 
        "96": "In other words, we use e(i,j) to include the discussion about both a(i,j) and a(j,i).", 
        "97": "4.1 Sub-problems  We consider six sub-problems when we construct a maximum dependency graph on a given (closed) interval [i, k] \u2286 V of vertices.", 
        "98": "When we focus on the nodes strictly inside this interval, and we use an open interval (i, k) to exclude i and j.", 
        "99": "See Figure 2 for graphical visualization.", 
        "100": "The first five are adapted in concord with Pitler et al.", 
        "101": "(2013)\u2019s solution for trees, and we introduce a new sub-problem, namely C. Because graphs allow for loops as well as disconnectedness, the subproblems are simplified to some extent, while a special case of LR is now prominent.", 
        "102": "C is thus introduced to represent the special case.", 
        "103": "The subproblems are explained as follows.", 
        "104": "Int Int[i, j] represents a partial analysis associated with an interval from i to j inclusively.", 
        "105": "Int[i, j] may or may not contain edge e(i,j).", 
        "106": "To parse a given sentence is equivalent to solve the problem Int[0, n\u2212 1].", 
        "107": "L L[i, j, x] represents a partial analysis associated with an interval from i to j inclusively as well as an external vertex x.", 
        "108": "\u2200p \u2208 (i, j), pt(x, p) = i. L[i, j, x] can contain e(i,j) but disallows e(x,i) or e(x,j).", 
        "109": "R R[i, j, x] represents a partial analysis associated with an interval from i to j inclusively as well as an external vertex x.", 
        "110": "\u2200p \u2208 (i, j), pt(x, p) = j. R[i, j, x] can contain e(i,j) but disallows e(x,i) or e(x,j).", 
        "111": "1 The single-head property does not hold.", 
        "112": "We currently do not consider other constraints of directions.", 
        "113": "So prediction of the direction of one edge does not affect prediction of other edges as well as their directions.", 
        "114": "The directions can be assigned locally, and our parser builds directed rather than undirected graphs in this way.", 
        "115": "Undirected graphs are only used to conveniently illustrate our algorithms.", 
        "116": "All experimental results in Section 5.2 consider directed dependencies in a standard way.", 
        "117": "We use the official evaluation tool provided by SDP2014 shared task.", 
        "118": "The numberic results reported in this paper are directly comparable to results in other papers.", 
        "119": "LR LR[i, j, x] represents a partial analysis associated with an interval from i to j inclusively as well as an external vertex x.", 
        "120": "\u2200p \u2208 (i, j), pt(x, p) = i or j. LR[i, j, x] must allow e(i,j) but disallows e(x,i) or e(x,j).", 
        "121": "N N [i, j, x] represents a partial analysis associated with an interval from i to j inclusively and an external vertex x.", 
        "122": "\u2200p \u2208 (i, j), pt(x, p) /\u2208 [i, j].", 
        "123": "N [i, j, x] can contain e(i,j) but disallows e(x,i) or e(x,j).", 
        "124": "C C[x, i, a, b](a \u0338= b, a > i, b > i) represents a partial analysis associated with an interval from i to max{a, b} inclusively and an external vertex x.", 
        "125": "Intuitively, C depicts a class of graphs constructed by upper- and lowerplane edges arranged in a staggered pattern.", 
        "126": "a stands for the last endpoint in the upper plane, and b the last endpoint in the lower plane.", 
        "127": "We give a definition of C. There exists in C[x, i, a, b] a series {s1, \u00b7 \u00b7 \u00b7 , sm} that fulfills the following constraints:\n1. s1 = i < s2 < ... < sm = max{a, b}.", 
        "128": "2.", 
        "129": "\u2203e(x,s2).", 
        "130": "3.", 
        "131": "\u2200k \u2208 [1,m\u2212 2], \u2203e(sk,sk+2).", 
        "132": "4.", 
        "133": "\u2200k \u2208 [1,m\u2212 2], \u2204e(l,r)(sk, sk+2) \u2282 (l, r) \u2282 (s1, sm) 2.", 
        "134": "5.", 
        "135": "\u2200k \u2208 [2,m \u2212 3], e(sk,sk+2) crosses only with e(sk\u22121,sk+1) and e(sk+1,sk+3); e(s1,s3) crosses only with e(s2,s4) and e(x,s2); e(sm\u22122,sm) crosses only with e(sm\u22123,sm\u22121).", 
        "136": "6. e(x,sm\u22121), e(s1,sm), e(x,s1), e(x,sm) are disallowed.", 
        "137": "7.", 
        "138": "While a < b, the series can be written as {s1 = i, \u00b7 \u00b7 \u00b7 , sm\u22121 = a, sm = b}(m \u2265 5).", 
        "139": "While b < a, the series is {s1, \u00b7 \u00b7 \u00b7 , sm\u22121 =\n2By \u201c(x, y) \u2282 (z, w),\u201d we mean x \u2265 z, y < w or x > z, y \u2264 w.\nb, sm = a}(m \u2265 4).", 
        "140": "We denote the two cases using the signs C1 and C2 respectively.", 
        "141": "The distinction between C1 and C2 is whether there is one more edge below than above.", 
        "142": "4.2 Decomposing an Int Sub-problem  Consider an Int[i, j] sub-problem.", 
        "143": "Assume that k(k \u2208 (i, j)) is the farthest vertex that is linked with i, and l = pt(i, k).", 
        "144": "When j \u2212 i > 1, there must be such a k given that we consider maximal 1EC/P2 graphs.", 
        "145": "There are three cases.", 
        "146": "Case 1: l = j. Vertex k divides the interval [i, j] into two parts: [i, k] and [k, j].", 
        "147": "First notice that the edges linking (i, k) and j can only cross with e(i,k).", 
        "148": "Thus i or k can be the pencil points of those edges, which entails that interval [i, k] is an LR in respect to external vertex j.", 
        "149": "Because there exist no edge from i to any node in (k, j), interval [k, j] is an Int.", 
        "150": "The problem is eventually decomposed to: LR[i, k, j] + Int[k, j] + SELECT[i, j].", 
        "151": "Case 2: l \u2208 (k, j).", 
        "152": "In this case, we can freely add e(i,l) without violating either 1EC or P2 conditions.", 
        "153": "Therefore Case 2 does not lead to any maximal 1EC/P2 graph.", 
        "154": "Our algorithm does not need to explicitly handle this case, given that they can be derived from solutions to other cases.", 
        "155": "Case 3: l \u2208 (i, k).", 
        "156": "Now assume that there is an edge from i to a vertex in (l, k).", 
        "157": "Consider the farthest vertex that is linked with l, say p(p \u2208 (k, j).", 
        "158": "We can freely add e(i,p) without violating the 1EC and P2 restrictions.", 
        "159": "Similar to Case 2, we do not explicitly deal with this case.", 
        "160": "If there is no edge from i to any vertex in (l, k), then [i, l], [l, k], [k, j] are R, Int, L respectively.", 
        "161": "Three external edges are e(i,k), e(l,j), and e(i,j).", 
        "162": "The decomposition is: R[i, l, k]+Int[l, k]+ L[k, j, l] + SELECT[l, j] + SELECT[i, j].", 
        "163": "4.3 Decomposing an L Sub-problem  If there is no edge from x to any node in (i, j), the graph is reduced to Int[i, j].", 
        "164": "If there is one, let k be the vertex farthest from i and adjacent to x.", 
        "165": "There are two different cases, as shown in Figure 4.", 
        "166": "1.", 
        "167": "If there exists an edge from x to some node in (i, k), intervals [i, k], [k, j] are classified as L, N respectively.", 
        "168": "Two edges external to the interval: e(x,k), e(i,j).", 
        "169": "The decomposition is L[i, k, x]+N [k, j, i]+SELECT[x, k]+ SELECT[i, j].", 
        "170": "Case 1: l = j\n.", 
        "171": "i\nk\nj = +\nCase 2: l \u2208 (k, j)\n.", 
        "172": "i\nk\nl j\nCase 3: l \u2208 (i, k)\n2.", 
        "173": "Otherwise, Intervals [i, k], [k, j] are classified as Int, L respectively.", 
        "174": "Two edges external to the interval: e(x,k), e(i,j).", 
        "175": "The decomposition is Int[i, k] +L[k, j, i] + SELECT[x, k] + SELECT[i, j].", 
        "176": "4.4 Decomposing an R Sub-problem  If there is no edge from x to (i, j), then the graph is reduced to Int[i, j].", 
        "177": "If there is one, let k be the farthest vertex from j and adjacent to x.", 
        "178": "There are two different cases:\n1.", 
        "179": "If there exist an edge from x to (k, j), Intervals [i, k], [k, j] are classified as N, R respectively.", 
        "180": "Two edges external to the interval: e(x,k), e(i,j).", 
        "181": "The decomposition\nis N [i, k, j] + R[k, j, x] + SELECT[x, k] + SELECT[i, j].", 
        "182": "2.", 
        "183": "Otherwise, Intervals [i, k], [k, j] are classified as R, Int respectively.", 
        "184": "Two edges external to the interval are e(x,k), e(i,j).", 
        "185": "The decomposition is R[i, k, j]+Int[k, j]+ SELECT[x, k]+ SELECT[i, j].", 
        "186": "The decomposition is similar to L, we thus do not give a graphical representation to save space.", 
        "187": "4.5 Decomposing an N Sub-problem  If there is no edge from x to (i, j), then the graph is reduced to Int[i, j].", 
        "188": "If there is one, let k be the farthest vertex from i and adjacent to x.", 
        "189": "By definition, N [i, j, x] does not allow for e(x,i) or e(x,j).", 
        "190": "Thus k \u0338= i or j. Intervals [i, k], [k, j] are classified as N, Int respectively.", 
        "191": "Two edges external to the interval are e(x,k), e(i,j).", 
        "192": "The decomposition is N [i, k, x] + Int[k, j] + SELECT[x, k] + SELECT[i, j].", 
        "193": "4.6 Decomposing an LR Sub-problem  If the pencil point of all edges from x to (i, j) is i, then the model is the same as L[i, j, x].", 
        "194": "Similary, if the pencil point is j, then the model is the same as R[i, j, x].", 
        "195": "If some of the edges from x to (i, j) share a pencil point i, and the others share j, there are two different cases.", 
        "196": "1.", 
        "197": "If there is a k which satisfies that within [i, j], only e(i,j) crosses over k (i.e., [i, j] can be divided along dashed line k into two), then, k divides [i, j] into [i, k] and [k, j].", 
        "198": "Because k is not allowed to be pencil point, the two\nsubintervals must be an L and an R in terms of external x, respectively.", 
        "199": "In addition, there are two edges, namely e(x,k) and e(i,j) not included by the subintervals.", 
        "200": "The problem is thus decomposed as L[i, k, x] + R[k, j, x] + SELECT[x, k] + SELECT[i, j].", 
        "201": "2.", 
        "202": "If there is no such k in concord with the condition in (1), it comes a much more difficult case for which we introduce sub-problem C. Here we put forward the conclusion:\nLemma 1.", 
        "203": "Assume that k(k \u2208 (i, j)) is the vertex that is adjacent to x and farthest from i.", 
        "204": "The decomposition for the second case is C[x, i, k, j] + SELECT[x, k] + SELECT[i, j].", 
        "205": "Proof.", 
        "206": "The distinction between Case 1 and 2 implies the following property, which is essential, \u2200t \u2208 (i, j), \u2203e(pl,pr) such that t \u2208 (pl, pr) \u2282 [i, j].", 
        "207": "We can recursively generate a series of length n\u2014{e(slk,srk)}\u2014in LR[i, j, x] as follows.", 
        "208": "k = 1 Let slk = i, srk = max{p|p \u2208 (i + 1, j) and \u2203e(i,p)};\nk > 1 For srk\u22121, we denote all edges that cover it as e(pl1,pr1), \u00b7 \u00b7 \u00b7 , e(pls,prs).", 
        "209": "Note that there is at least one such edge.", 
        "210": "For any two edges in them, viz e(plu,pru) and e(plv ,prv), (plu, pru) \u2282 (plv, prv) or (plv, prv) \u2282 (plu, pru).", 
        "211": "Otherwise, the P2 property no longer holds due to the interaction among e(slk\u22121,srk\u22121), e(plu,pru) and e(plv ,prv).", 
        "212": "Assume (plw, prw) is the largest one, then we let slk = plw, srk = prw.", 
        "213": "When srk = j, recursion ends.", 
        "214": "We are going to prove that if we delete two edges e(x,srn\u22121) and e(i,j) from LR[i, j, x], the series {sl1, sl2, sl3, ..., sln\u22122, sln\u22121, sln, srn\u22121, srn} satisfies each and all the conditions of C1.", 
        "215": "Condition 1.", 
        "216": "Because e(sln,srn) covers srn\u22121, Condition 1 holds for k = m\u22123,m\u22122.", 
        "217": "Consider k \u2264 m\u2212 4 = n\u2212 2.", 
        "218": "Assume that sk+1 < sk, then we have e(sk+1,srk+1) is larger than e(sk,srk+1).", 
        "219": "This is impossible because we select the largest edge in every step.", 
        "220": "Condition 2.", 
        "221": "TheLR sub-problemwe discussed now cannot be reduced to L nor R, so there must be two edges from x that respectively cross edges linked to i and j.", 
        "222": "We are going to prove that\nthe two edges must be e(x,s2) and e(x,srn\u22121).", 
        "223": "Assume that there is e(x,p), where p \u2208 (i, j), p \u0338= s2 and p \u0338= srn\u22121.", 
        "224": "If p \u2208 (i, s2), then e(s1,s3) crosses with e(x,p) and e(s2,s4) simultaneously.", 
        "225": "1EC is violated.", 
        "226": "If p \u2208 (s2, srn\u22121), e(x,p) necessarily crosses with some edge e(sk,sk+2).", 
        "227": "Furthermore, i < sk < sk+2 < j.", 
        "228": "Thus 1EC is violated.", 
        "229": "If p \u2208 (srn\u22121, j), the situation is similar to p \u2208 (i, s2).", 
        "230": "Condition 3.", 
        "231": "\u2200k \u2208 [1, n \u2212 2], e(slk,srk) and e(slk+1,srk+1) cross, e(slk+1,srk+1) and e(slk+2,srk+2) cross, so srk \u2264 slk+2.", 
        "232": "Otherwise the interaction of the three edges results in the violation of P2.", 
        "233": "If srk < slk+2, e(slk,srk) and e(slk+2,srk+2) share no common endpoint, violating 1EC.", 
        "234": "Therefore, srk = slk+2 = sk+2, and Condition 3 is satisfied.", 
        "235": "We also reach proposition that pt(sk, sk+2) = sk+1.", 
        "236": "Condition 4.", 
        "237": "This condition is easy to verify because (sk, sk+2) is the largest with respective to srk.", 
        "238": "Condition 5.", 
        "239": "Assume, that there is e(pl,pr) which intersects with e(sk,sk+2), and at the same time satisfy the conditions: e(pl,pr) /\u2208 {e(st,st+2)|t \u2208 [1,m \u2212 2]} \u222a {e(x,s2), e(x,srn\u22121)}.", 
        "240": "Since pt(sk, sk+2) = sk+1, pl = sk+1 or pr = sk+1.", 
        "241": "If pl = sk+1, then pl < slk+2 < pr, and in turn k < m \u2212 2.", 
        "242": "In addition, according to Condition 4, (pl, pr) \u2282 (sk+1, sk+3).", 
        "243": "So pr < sk+3.", 
        "244": "If k = m\u2212 3 then e(x,sn\u22121) crosses with e(pl,pr) and e(i,j) simultaneously.", 
        "245": "1EC is violated.", 
        "246": "If k < m\u2212 3 then e(sk+2,sk+4) cross with e(pl,pr), and pr < sk+3 = pt(e(sk+2,sk+4)).", 
        "247": "Again 1EC is violated.", 
        "248": "If pr = sk+1 The symmetry of our proof entails the violation of 1ec.", 
        "249": "All in all, the assumption does not hold and thus satisfies Condition 5.", 
        "250": "Condition 6. e(x,s1), e(x,sm) are disallowed due to definition of an LR problem.", 
        "251": "e(x,sm\u22121), e(s1,sm) are disallowed due to the decomposition.", 
        "252": "Condition 7.", 
        "253": "Due to the existence of e(x,s2) and e(x,srn\u22121), there must be two edges: e(x,p1) and e(x,p2) that cross e(i,s2) and e(srn\u22121,j) respectively.", 
        "254": "There must be an odd number of edges in the series {e(slk,srk)}, otherwise P2 is violated as the case shown in Figure 1.", 
        "255": "In summary, the last condition\nis satisfied and we have a C1 structure in this LR sub-problem.", 
        "256": "4.7 Decomposing a C Sub-problem  We illustrate the decomposition using the graphical representations shown in Figure 7.", 
        "257": "When a < b, since a is the upper-plane endpoint farthest to the right, and b is the lower-plane counterpart, in this case a precedes b (i.e., a is to the left of b).", 
        "258": "Let C[x, i, a, k] be aC in which the lower-plane endpoint k precedes a.", 
        "259": "Add e(k,b) gives a new C sub-problem with lower-plane endpoint preceded by the upper-plane one.", 
        "260": "The decomposition is then C[x, i, a, k] + Int[a, b] + SELECT[k, b].", 
        "261": "When a > b and n > 2, the lower-plane endpoint b precedes a.", 
        "262": "In analogy, the case can be obtained by adding e(k,a) toC[x, i, k, b].", 
        "263": "The decomposition: C[x, i, k, b] + Int[b, a] + SELECT[k, a].", 
        "264": "When n = 2, we reach the most fundamental case.", 
        "265": "Only 4 vertices are in the series, namely i,k,b,a.", 
        "266": "Moreover, there are three edges: e(x,k), e(i,b), e(k,a), and the interval [i,a] is divided by k,b into three parts.", 
        "267": "The decomposition is Int[i, k]+Int[k, b]+Int[b, a]+SELECT[x, k]+ SELECT[i, b] + SELECT[k, a].", 
        "268": "4.8 Discussion    4.8.1 Soundness and Completeness  The algorithm is sound and complete with respective to 1EC/P2 graphs.", 
        "269": "We present our algorithms by detailing the decomposition rules.", 
        "270": "The completeness is obvious because we can decompose any 1EC/P2 graph from an Int, use our rules to reduce it into smaller sub-problems, and repeat this procedure.", 
        "271": "The decomposition rules are also construction rules.", 
        "272": "During constructing graphs by applying these rules, we never violate 1EC nor P2\nrestrictions.", 
        "273": "So our algorithm is sound.", 
        "274": "4.8.2 Greedy Search during Construction  There is an important difference between our algorithm and Eisner-style MST algorithms (Eisner, 1996b; McDonald and Pereira, 2006; Carreras, 2007; Koo and Collins, 2010) for trees as well as Kuhlmann and Jonsson\u2019s Maximum Subgraph algorithm for noncrossing graphs.", 
        "275": "In each construction step, our algorithm allows multiple arcs to be constructed, but whether or not such arcs are added to the target graph depends on their arc-weights.", 
        "276": "In each step, we do greedy search and decide if adding an related arc according to local scores.", 
        "277": "If all arcs are assigned scores that are greater than 0, the output of our algorithm includes the most complicated 1EC/P2 graphs.", 
        "278": "That means adding one more arc voilates the 1EC or P2 restrictions.", 
        "279": "For all other aforementioned algorithms, in a single construction step, it is clear whether to add a new arc, and which one.", 
        "280": "There is no local search.", 
        "281": "4.8.3 Spurious Ambiguity  To generate the same graph, even a maximal 1EC/P2 graph, we may have different derivations.", 
        "282": "Figure 8 is an example.", 
        "283": "This is similar to syntactic analysis licensed by Combinatory Categorial Grammar (CCG; Steedman, 1996, 2000).", 
        "284": "To derive one surface string, there usually exists multiple CCG derivations.", 
        "285": "A practice of CCG parsing is defining one particular derivation as the standard one, namely normal form (Eisner, 1996a).", 
        "286": "The spurious ambiguity in our algorithm does not affect the correctness of first-order parsing, because scores are assigned to individual dependen-\ncies, rather than derivation processes.", 
        "287": "There is no need to distinguish one special derivation here.", 
        "288": "4.8.4 Complexity  The sub-problem Int is of size O(n2), each graph of which takes a calculating time of order O(n2).", 
        "289": "For sub-problems L, R, LR, and N, each has O(n3) elements, with a unit calculating time O(n).", 
        "290": "C has O(n4) elements, with a unit calculating time O(n).", 
        "291": "Therefore the full version algorithm runs in time of O(n5) with a space requirement of O(n4).", 
        "292": "4.9 A Degenerated Version  We find that graphical structures involved in the C sub-problem, namely coupled staggered pattern, is extremely rare in linguistic analysis.", 
        "293": "If we ignore this special case, we get a degenerated version of dynamic programming algorithm.", 
        "294": "This algorithm can find a strict subset of 1EC/P2 graphs.", 
        "295": "We can improve efficiency without sacrificing expressiveness in terms of linguistic data.", 
        "296": "This degenerated version algorithm requires O(n4) time and O(n3) space.", 
        "297": "5 Practical Parsing    5.1 Disambiguation  We extend our quartic-time parsing algorithm into a practical parser.", 
        "298": "In the context of data-driven parsing, this requires an extra disambiguation model.", 
        "299": "As with many other parsers, we employ a global linear model.", 
        "300": "Following Zhang et al.", 
        "301": "(2016)\u2019s experience, we define rich features extracted fromword, POS-tags and pseudo trees.", 
        "302": "For details we refer to the source code.", 
        "303": "To estimate parameters, we utilize the averaged perceptron algorithm (Collins, 2002).", 
        "304": "5.2 Data  We conduct experiments on unlabeled parsing using four corpora: CCGBank (Hockenmaier and Steedman, 2007), DeepBank (Flickinger et al., 2012), Enju HPSGBank (EnjuBank; Miyao et al., 2004) and Prague Dependency TreeBank (PCEDT; Hajic et al., 2012), We use \u201cstandard\u201d training, validation, and test splits to facilitate comparisons.", 
        "305": "Following previous experimental setup for CCG parsing, we use section 02-21 as training data, section 00 as the development data, and section 23 for testing.", 
        "306": "The other three data sets are from SemEval 2014 Task 8 (Oepen et al.,\n2014), and the data splitting policy follows the shared task.", 
        "307": "All the four data sets are publicly available from LDC (Oepen et al., 2016).", 
        "308": "Experiments for CCG-grounded analysis were performed using automatically assigned POS-tags that are generated by a symbol-refined HMM tagger (Huang et al., 2010).", 
        "309": "Experiments for the other three data sets used POS-tags provided by the shared task.", 
        "310": "We also use features extracted from pseudo trees.", 
        "311": "We utilize the Mate parser (Bohnet, 2010) to generate pseudo trees.", 
        "312": "The pre-processing for CCGBank, DeepBank and EnjuBank are exactly the same as in experiments reported in (Zhang et al., 2016).", 
        "313": "5.3 Accuracy  We evaluate two parsing algorithms, the algorithm for noncrossing dependency graphs (Kuhlmann and Jonsson, 2015), i.e.", 
        "314": "pagenumber-1 (denoted as P1) graphs, and our quartic-time algorithm (denoted as 1ECP2d).", 
        "315": "Table 2 summerizes the accuracy obtained our parser.", 
        "316": "Same feature templates are applied for disambiguation.", 
        "317": "We can see that our new algorithm yields significant improvements on all data sets, as expected.", 
        "318": "Especially, due to the improved coverage, the recall is improved more.", 
        "319": "5.4 Comparison with Other Parsers  Our new parser can be taken as a graph-based parser which employ a different architecture from transition-based and factorization-based (Martins and Almeida, 2014; Du et al., 2015a) systems.", 
        "320": "We compare our parser with the best reported systems in the other two architectures.", 
        "321": "ZDSW (Zhang et al., 2016) is transition-based parser while MA (Martins and Almeida, 2014) and DSW (Du et al.,\n2015a) are two factorization-based systems.", 
        "322": "All of them achieves state-of-the-art performance.", 
        "323": "All results on the test set is shown in Table 3.", 
        "324": "We can see that our parser, as a graph-based parser, is comparable to state-of-the-art transition-based and factorization-based parsers.", 
        "325": "6 Conclusion and Future Work  In this paper, we explore the strength of the graphbased approach.", 
        "326": "In particular, we enhance the Maximum Subgraph model with new parsing algorithms for 1EC/P2 graphs.", 
        "327": "Our work indicates the importance of finding appropriate graph classes that on the one hand are linguistically expressive and on the other hand allow efficient search.", 
        "328": "Within tree-structured dependency parsing, higher-order factorization that conditions on wider syntactic contexts than arc-factored relationships have been proved very useful.", 
        "329": "The arcfactored model proposed in this paper may be enhanced with higher-order features too.", 
        "330": "We leave this for future investigation.", 
        "331": "Acknowledgments  This work was supported by 863 Program of China (2015AA015403), NSFC (61331011), and Key Laboratory of Science, Technology and Standard in Press Industry (Key Laboratory of Intelligent Press Media Technology).", 
        "332": "We thank the first anonymous reviewer whose valuable comments led to significant revisions.", 
        "333": "We thank Xingfeng Shi for his help in explicating the idea.", 
        "334": "Weiwei Sun is the corresponding author."
    }, 
    "document_id": "P17-1193.pdf.json"
}
