{
    "abstract_sentences": {
        "1": "Our goal is to learn a semantic parser that maps natural language utterances into executable programs when only indirect supervision is available: examples are labeled with the correct execution result, but not the program itself.", 
        "2": "Consequently, we must search the space of programs for those that output the correct result, while not being misled by spurious programs: incorrect programs that coincidentally output the correct result.", 
        "3": "We connect two common learning paradigms, reinforcement learning (RL) and maximum marginal likelihood (MML), and then present a new learning algorithm that combines the strengths of both.", 
        "4": "The new algorithm guards against spurious programs by combining the systematic search traditionally employed in MML with the randomized exploration of RL, and by updating parameters such that probability is spread more evenly across consistent programs.", 
        "5": "We apply our learning algorithm to a new neural semantic parser and show significant gains over existing state-of-theart results on a recent context-dependent semantic parsing task."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1051\u20131062 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1097  1 Introduction  We are interested in learning a semantic parser that maps natural language utterances into executable programs (e.g., logical forms).", 
        "2": "For example, in Figure 1, a program corresponding to the utterance transforms an initial world state into a new world state.", 
        "3": "We would like to learn from indirect supervision, where each training example is only labeled with the correct output (e.g.", 
        "4": "a target world state), but not the program that produced that out-\nz*\nz'0.1\n0.1\n0.1 0.1 0.1\n0.1 0.1 0.1 0.1 0.1\np(z') = 10-4\np(z*) = 10-6\nred\nyellow hasHat blue hasShirt leftOf move\nmove1hasShirt\nput (Clarke et al., 2010; Liang et al., 2011; Krishnamurthy and Mitchell, 2012; Artzi and Zettlemoyer, 2013; Liang et al., 2017).", 
        "5": "The process of constructing a program can be formulated as a sequential decision-making process, where feedback is only received at the end of the sequence when the completed program is executed.", 
        "6": "In the natural language processing literature, there are two common approaches for handling this situation: 1) reinforcement learning (RL), particularly the REINFORCE algorithm (Williams, 1992; Sutton et al., 1999), which maximizes the expected reward of a sequence of actions; and 2) maximum marginal likelihood (MML), which treats the sequence of actions as a latent variable, and then maximizes the marginal likelihood of observing the correct program output (Dempster et al., 1977).", 
        "7": "While the two approaches have enjoyed success on many tasks, we found them to work poorly out of the box for our task.", 
        "8": "This is because in addition to the sparsity of correct programs, our task also requires weeding out spurious programs (Pasupat and Liang, 2016): incorrect interpretations\n1051\nof the utterances that accidentally produce the correct output, as illustrated in Figure 1.", 
        "9": "We show that MML and RL optimize closely related objectives.", 
        "10": "Furthermore, both MML and RL methods have a mechanism for exploring program space in search of programs that generate the correct output.", 
        "11": "We explain why this exploration tends to quickly concentrate around short spurious programs, causing the model to sometimes overlook the correct program.", 
        "12": "To address this problem, we propose RANDOMER, a new learning algorithm with two parts:\nFirst, we propose randomized beam search, an exploration strategy which combines the systematic beam search traditionally employed in MML with the randomized off-policy exploration of RL.", 
        "13": "This increases the chance of finding correct programs even when the beam size is small or the parameters are not pre-trained.", 
        "14": "Second, we observe that even with good exploration, the gradients of both the RL and MML objectives may still upweight entrenched spurious programs more strongly than correct programs with low probability under the current model.", 
        "15": "We propose a meritocratic parameter update rule, a modification to the MML gradient update, which more equally upweights all programs that produce the correct output.", 
        "16": "This makes the model less likely to overfit spurious programs.", 
        "17": "We apply RANDOMER to train a new neural semantic parser, which outputs programs in a stackbased programming language.", 
        "18": "We evaluate our resulting system on SCONE, the context-dependent semantic parsing dataset of Long et al.", 
        "19": "(2016).", 
        "20": "Our approach outperforms standard RL and MML methods in a direct comparison, and achieves new state-of-the-art results, improving over Long et al.", 
        "21": "(2016) in all three domains of SCONE, and by over 30% accuracy on the most challenging one.", 
        "22": "2 Task  We consider the semantic parsing task in the SCONE dataset1 (Long et al., 2016).", 
        "23": "As illustrated in Figure 1, each example consists of a world containing several objects (e.g., people), each with certain properties (e.g., shirt color and hat color).", 
        "24": "Given the initial world state w0 and a sequence of M natural language utterances u = (u1, .", 
        "25": ".", 
        "26": ".", 
        "27": ", uM ), the task is to generate a program that manipulates the world state according to the utterances.", 
        "28": "Each\n1 https://nlp.stanford.edu/projects/scone\nutterance um describes a single action that transforms the world state wm\u22121 into a new world state wm.", 
        "29": "For training, the system receives weakly supervised examples with input x = (u, w0) and the target final world state y = wM .", 
        "30": "The dataset includes 3 domains: ALCHEMY, TANGRAMS, and SCENE.", 
        "31": "The description of each domain can be found in Appendix B.", 
        "32": "The domains highlight different linguistic phenomena: ALCHEMY features ellipsis (e.g., \u201cthrow the rest out\u201d, \u201cmix\u201d); TANGRAMS features anaphora on actions (e.g., \u201crepeat step 3\u201d, \u201cbring it back\u201d); and SCENE features anaphora on entities (e.g., \u201che moves back\u201d, \u201c.", 
        "33": ".", 
        "34": ".", 
        "35": "to his left\u201d).", 
        "36": "Each domain contains roughly 3,700 training and 900 test examples.", 
        "37": "Each example contains 5 utterances and is labeled with the target world state after each utterance, but not the target program.", 
        "38": "Spurious programs.", 
        "39": "Given a training example (u, w0, wM ), our goal is to find the true underlying program z\u2217 which reflects the meaning of u.", 
        "40": "The constraint that z\u2217 must transformw0 intowM , i.e.", 
        "41": "z(w0) = wM , is not enough to uniquely identify the true z\u2217, as there are often many z satisfying z(w0) = wM : in our experiments, we found at least 1600 on average for each example.", 
        "42": "Almost all do not capture the meaning of u (see Figure 1).", 
        "43": "We refer to these incorrect z\u2019s as spurious programs.", 
        "44": "Such programs encourage the model to learn an incorrect mapping from language to program operations: e.g., the spurious program in Figure 1 would cause the model to learn that \u201cman in the yellow hat\u201d maps to hasShirt(red).", 
        "45": "Spurious programs in SCONE.", 
        "46": "In this dataset, utterances often reference objects in different ways (e.g.", 
        "47": "a person can be referenced by shirt color, hat color, or position).", 
        "48": "Hence, any target programming language must also support these different reference strategies.", 
        "49": "As a result, even a single action such as moving a person to a target destination can be achieved by many different programs, each selecting the person and destination in a different way.", 
        "50": "Across multiple actions, the number of programs grows combinatorially.2 Only a few programs actually implement the correct reference strategy as defined by the utterance.", 
        "51": "This problem would be more severe in any more general-purpose language (e.g.", 
        "52": "Python).", 
        "53": "2The number of well-formed programs in SCENE exceeds 1015  3 Model  We formulate program generation as a sequence prediction problem.", 
        "54": "We represent a program as a sequence of program tokens in postfix notation; for example, move(hasHat(yellow), leftOf(hasShirt(blue))) is linearized as yellow hasHat blue hasShirt leftOf move.", 
        "55": "This representation also allows us to incrementally execute programs from left to right using a stack: constants (e.g., yellow) are pushed onto the stack, while functions (e.g., hasHat) pop appropriate arguments from the stack and push back the computed result (e.g., the list of people with yellow hats).", 
        "56": "Appendix B lists the full set of program tokens, Z , and how they are executed.", 
        "57": "Note that each action always ends with an action token (e.g., move).", 
        "58": "Given an input x = (u, w0), the model generates program tokens z1, z2, .", 
        "59": ".", 
        "60": ".", 
        "61": "from left to right using a neural encoder-decoder model with attention (Bahdanau et al., 2015).", 
        "62": "Throughout the generation process, the model maintains an utterance pointer, m, initialized to 1.", 
        "63": "To generate zt, the model\u2019s encoder first encodes the utterance um into a vector em.", 
        "64": "Then, based on em and previously generated tokens z1:t\u22121, the model\u2019s decoder defines a distribution p(zt | x, z1:t\u22121) over the possible values of zt \u2208 Z .", 
        "65": "The next token zt is sampled from this distribution.", 
        "66": "If an action token (e.g., move) is generated, the model increments the utterance pointer m. The process terminates when all M utterances are processed.", 
        "67": "The final probability of generating a particular program z = (z1, .", 
        "68": ".", 
        "69": ".", 
        "70": ", zT ) is p(z | x) = \u220fT t=1 p(zt | x, z1:t\u22121).", 
        "71": "Encoder.", 
        "72": "The utterance um under the pointer is encoded using a bidirectional LSTM:\nhFi = LSTM(h F i\u22121,\u03a6u(um,i)) hBi = LSTM(h B i+1,\u03a6u(um,i))\nhi = [h F i ;h B i ],\nwhere \u03a6u(um,i) is the fixed GloVe word embedding (Pennington et al., 2014) of the ith word in um.", 
        "73": "The final utterance embedding is the concatenation em = [hF|um|;h B 1 ].", 
        "74": "Decoder.", 
        "75": "Unlike Bahdanau et al.", 
        "76": "(2015), which used a recurrent network for the decoder, we opt for a feed-forward network for simplicity.", 
        "77": "We use em and an embedding f(z1:t\u22121) of the previous execution history (described later) as inputs to\ncompute an attention vector ct:\nqt = ReLU(Wq[em; f(z1:t\u22121)]) \u03b1i \u221d exp(q>t Wahi) (i = 1, .", 
        "78": ".", 
        "79": ".", 
        "80": ", |um|) ct = \u2211\ni\n\u03b1ihi.", 
        "81": "Finally, after concatenating qt with ct, the distribution over the set Z of possible program tokens is computed via a softmax:\np(zt | x, z1:t\u22121) \u221d exp(\u03a6z(zt)>Ws[qt; ct]),\nwhere \u03a6z(zt) is the embedding for token zt.", 
        "82": "Execution history embedding.", 
        "83": "We compare two options for f(z1:t\u22121), our embedding of the execution history.", 
        "84": "A standard approach is to simply take the k most recent tokens zt\u2212k:t\u22121 and concatenate their embeddings.", 
        "85": "We will refer to this as TOKENS and use k = 4 in our experiments.", 
        "86": "We also consider a new approach which leverages our ability to incrementally execute programs using a stack.", 
        "87": "We summarize the execution history by embedding the state of the stack at time t \u2212 1, achieved by concatenating the embeddings of all values on the stack.", 
        "88": "(We limit the maximum stack size to 3.)", 
        "89": "We refer to this as STACK.", 
        "90": "4 Reinforcement learning versus maximum marginal likelihood  Having formulated our task as a sequence prediction problem, we must still choose a learning algorithm.", 
        "91": "We first compare two standard paradigms: reinforcement learning (RL) and maximum marginal likelihood (MML).", 
        "92": "In the next section, we propose a better alternative.", 
        "93": "4.1 Comparing objective functions  Reinforcement learning.", 
        "94": "From an RL perspective, given a training example (x, y), a policy makes a sequence of decisions z = (z1, .", 
        "95": ".", 
        "96": ".", 
        "97": ", zT ), and then receives a reward at the end of the episode: R(z) = 1 if z executes to y and 0 otherwise (dependence on x and y has been omitted from the notation).", 
        "98": "We focus on policy gradient methods, in which a stochastic policy function is trained to maximize the expected reward.", 
        "99": "In our setup, p\u03b8(z | x) is the policy (with parameters \u03b8), and its expected reward on a given example (x, y) is\nG(x, y) = \u2211\nz\nR(z) p\u03b8(z | x), (1)\nwhere the sum is over all possible programs.", 
        "100": "The overall RL objective, JRL, is the expected reward across examples:\nJRL = \u2211\n(x,y)\nG(x, y).", 
        "101": "(2)\nMaximum marginal likelihood.", 
        "102": "The MML perspective assumes that y is generated by a partially-observed random process: conditioned on x, a latent program z is generated, and conditioned on z, the observation y is generated.", 
        "103": "This implies the marginal likelihood:\np\u03b8(y | x) = \u2211\nz\np(y | z) p\u03b8(z | x).", 
        "104": "(3)\nNote that since the execution of z is deterministic, p\u03b8(y | z) = 1 if z executes to y and 0 otherwise.", 
        "105": "The log marginal likelihood of the data is then\nJMML = logLMML, (4) where LMML = \u220f\n(x,y)\np\u03b8(y | x).", 
        "106": "(5)\nTo estimate our model parameters \u03b8, we maximize JMML with respect to \u03b8.", 
        "107": "With our choice of reward, the RL expected reward (1) is equal to the MML marginal probability (3).", 
        "108": "Hence the only difference between the two formulations is that in RL we optimize the sum of expected rewards (2), whereas in MML we optimize the product (5).3  4.2 Comparing gradients  In both policy gradient and MML, the objectives are typically optimized via (stochastic) gradient ascent.", 
        "109": "The gradients of JRL and JMML are closely related.", 
        "110": "They both have the form:\n\u2207\u03b8J = \u2211\n(x,y)\nEz\u223cq [R(z)\u2207 log p\u03b8(z | x)] (6)\n= \u2211\n(x,y)\n\u2211\nz\nq(z)R(z)\u2207 log p\u03b8(z | x),\nwhere q(z) equals\nqRL(z) = p\u03b8(z | x) for JRL, (7)\nqMML(z) = R(z)p\u03b8(z | x)\u2211 z\u0303R(z\u0303)p\u03b8(z\u0303 | x)\n(8)\n= p\u03b8(z | x,R(z) 6= 0) for JMML.", 
        "111": "3 Note that the log of the product in (5) does not equal the\nsum in (2).", 
        "112": "Taking a step in the direction of\u2207 log p\u03b8(z | x) upweights the probability of z, so we can heuristically think of the gradient as attempting to upweight each reward-earning program z by a gradient weight q(z).", 
        "113": "In Subsection 5.2, we argue why qMML is better at guarding against spurious programs, and propose an even better alternative.", 
        "114": "4.3 Comparing gradient approximation strategies  It is often intractable to compute the gradient (6) because it involves taking an expectation over all possible programs.", 
        "115": "So in practice, the expectation is approximated.", 
        "116": "In the policy gradient literature, Monte Carlo integration (MC) is the typical approximation strategy.", 
        "117": "For example, the popular REINFORCE algorithm (Williams, 1992) uses Monte Carlo sampling to compute an unbiased estimate of the gradient:\n\u2206MC = 1\nB\n\u2211 z\u2208S [R(z)\u2212 c]\u2207 log p\u03b8(z | x), (9)\nwhere S is a collection of B samples z(b) \u223c q(z), and c is a baseline (Williams, 1992) used to reduce the variance of the estimate without altering its expectation.", 
        "118": "In the MML literature for latent sequences, the expectation is typically approximated via numerical integration (NUM) instead:\n\u2206NUM = \u2211\nz\u2208S q(z)R(z)\u2207 log p\u03b8(z | x).", 
        "119": "(10)\nwhere the programs in S come from beam search.", 
        "120": "Beam search.", 
        "121": "Beam search generates a set of programs via the following process.", 
        "122": "At step t of beam search, we maintain a beam Bt of at most B search states.", 
        "123": "Each state s \u2208 Bt represents a partially constructed program, s = (z1, .", 
        "124": ".", 
        "125": ".", 
        "126": ", zt) (the first t tokens of the program).", 
        "127": "For each state s in the beam, we generate all possible continuations,\ncont(s) = cont((z1, .", 
        "128": ".", 
        "129": ".", 
        "130": ", zt))\n= {(z1, .", 
        "131": ".", 
        "132": ".", 
        "133": ", zt, zt+1) | zt+1 \u2208 Z} .", 
        "134": "We then take the union of these continuations, cont(Bt) = \u22c3 s\u2208Bt cont(s).", 
        "135": "The new beam Bt+1 is simply the highest scoringB continuations in cont(Bt), as scored by the policy, p\u03b8(s | x).", 
        "136": "Search is halted after a fixed number of iterations\nor when there are no continuations possible.", 
        "137": "S is then the set of all complete programs discovered during beam search.", 
        "138": "We will refer to this as beam search MML (BS-MML).", 
        "139": "In both policy gradient and MML, we think of the procedure used to produce the set of programs S as an exploration strategy which searches for programs that produce reward.", 
        "140": "One advantage of numerical integration is that it allows us to decouple the exploration strategy from the gradient weights assigned to each program.", 
        "141": "5 Tackling spurious programs  In this section, we illustrate why spurious programs are problematic for the most commonly used methods in RL (REINFORCE) and MML (beam search MML).", 
        "142": "We describe two key problems and propose a solution to each, based on insights gained from our comparison of RL and MML in Section 4.", 
        "143": "5.1 Spurious programs bias exploration  As mentioned in Section 4, REINFORCE and BSMML both employ an exploration strategy to approximate their respective gradients.", 
        "144": "In both methods, exploration is guided by the current model policy, whereby programs with high probability under the current policy are more likely to be explored.", 
        "145": "A troubling implication is that programs with low probability under the current policy are likely to be overlooked by exploration.", 
        "146": "If the current policy incorrectly assigns low probability to the correct program z\u2217, it will likely fail to discover z\u2217 during exploration, and will consequently fail to upweight the probability of z\u2217.", 
        "147": "This repeats on every gradient step, keeping the probability of z\u2217 perpetually low.", 
        "148": "The same feedback loop can also cause already highprobability spurious programs to gain even more probability.", 
        "149": "From this, we see that exploration is sensitive to initial conditions: the rich get richer, and the poor get poorer.", 
        "150": "Since there are often thousands of spurious programs and only a few correct programs, spurious programs are usually found first.", 
        "151": "Once spurious programs get a head start, exploration increasingly biases towards them.", 
        "152": "As a remedy, one could try initializing parameters such that the model puts a uniform distribution over all possible programs.", 
        "153": "A seemingly reasonable tactic is to initialize parameters such that the\n\"The man in the yellow hat moves to the left of the woman in blue.\u201d\nSpurious: move(hasShirt(red), 1) Correct: move(hasHat(yellow), leftOf(hasShirt(blue)))\n1 2 3 1 2 3\nBEFORE AFTER\nmodel policy puts near-uniform probability over the decisions at each time step.", 
        "154": "However, this causes shorter programs to have orders of magnitude higher probability than longer programs, as illustrated in Figure 2 and as we empirically observe.", 
        "155": "A more sophisticated approach might involve approximating the total number of programs reachable from each point in the programgenerating decision tree.", 
        "156": "However, we instead propose to reduce sensitivity to the initial distribution over programs.", 
        "157": "Solution: randomized beam search One solution to biased exploration is to simply rely less on the untrustworthy current policy.", 
        "158": "We can do this by injecting random noise into exploration.", 
        "159": "In REINFORCE, a common solution is to sample from an -greedy variant of the current policy.", 
        "160": "On the other hand, MML exploration with beam search is deterministic.", 
        "161": "However, it has a key advantage over REINFORCE-style sampling: even if one program occupies almost all probability under the current policy (a peaky distribution), beam search will still use its remaining beam capacity to explore at least B\u2212 1 other programs.", 
        "162": "In contrast, sampling methods will repeatedly visit the mode of the distribution.", 
        "163": "To get the best of both worlds, we propose a simple -greedy randomized beam search.", 
        "164": "Like regular beam search, at iteration t we compute the set of all continuations cont(Bt) and sort them by their model probability p\u03b8(s | x).", 
        "165": "But instead of selecting the B highest-scoring continuations, we choose B continuations one by one without replacement from cont(Bt).", 
        "166": "When choosing a continuation from the remaining pool, we either uniformly sample a random continuation with probability , or pick the highest-scoring continuation in the pool with probability 1\u2212 .", 
        "167": "Empirically, we\nfind that this performs much better than both classic beam search and -greedy sampling (Table 3).", 
        "168": "5.2 Spurious programs dominate gradients  In both RL and MML, even if exploration is perfect and the gradient is exactly computed, spurious programs can still be problematic.", 
        "169": "Even if perfect exploration visits every program, we see from the gradient weights q(z) in (7) and (8) that programs are weighted proportional to their current policy probability.", 
        "170": "If a spurious program z\u2032 has 100 times higher probability than z\u2217 as in Figure 2, the gradient will spend roughly 99% of its magnitude upweighting towards z\u2032 and only 1% towards z\u2217 even though the two programs get the same reward.", 
        "171": "This implies that it would take many updates for z\u2217 to catch up.", 
        "172": "In fact, z\u2217 may never catch up, depending on the gradient updates for other training examples.", 
        "173": "Simply increasing the learning rate is inadequate, as it would cause the model to take overly large steps towards z\u2032, potentially causing optimization to diverge.", 
        "174": "Solution: the meritocratic update rule To solve this problem, we want the upweighting to be more \u201cmeritocratic\u201d: any program that obtains reward should be upweighted roughly equally.", 
        "175": "We first observe that JMML already improves over JRL in this regard.", 
        "176": "From (6), we see that the gradient weight qMML(z) is the policy distribution restricted to and renormalized over only rewardearning programs.", 
        "177": "This renormalization makes the gradient weight uniform across examples: even if all reward-earning programs for a particular example have very low model probability, their combined gradient weight \u2211 z qMML(z) is always 1.", 
        "178": "In our experiments, JMML performs significantly better than JRL (Table 4).", 
        "179": "However, while JMML assigns uniform weight across examples, it is still not uniform over the programs within each example.", 
        "180": "Hence we propose a new update rule which goes one step further in pursuing uniform updates.", 
        "181": "Extending qMML(z), we define a \u03b2-smoothed version:\nq\u03b2(z) = qMML(z)\n\u03b2\n\u2211 z\u0303 qMML(z\u0303) \u03b2 .", 
        "182": "(11)\nWhen \u03b2 = 0, our weighting is completely uniform across all reward-earning programs within an example while \u03b2 = 1 recovers the original MML weighting.", 
        "183": "Our new update rule is to simply take\na modified gradient step where q = q\u03b2 .4 We will refer to this as the \u03b2-meritocratic update rule.", 
        "184": "5.3 Summary of the proposed approach  We described two problems5 and their solutions: we reduce exploration bias using -greedy randomized beam search and perform more balanced optimization using the \u03b2-meritocratic parameter update rule.", 
        "185": "We call our resulting approach RANDOMER.", 
        "186": "Table 1 summarizes how RANDOMER combines desirable qualities from both REINFORCE and BS-MML.", 
        "187": "6 Experiments  Evaluation.", 
        "188": "We evaluate our proposed methods on all three domains of the SCONE dataset.", 
        "189": "Accuracy is defined as the percentage of test examples where the model produces the correct final world state wM .", 
        "190": "All test examples have M = 5 (5utts), but we also report accuracy after processing the first 3 utterances (3utts).", 
        "191": "To control for the effects of randomness, we train 5 instances of each model with different random seeds.", 
        "192": "We report the median accuracy of the instances unless otherwise noted.", 
        "193": "Training.", 
        "194": "Following Long et al.", 
        "195": "(2016), we decompose each training example into smaller examples.", 
        "196": "Given an example with 5 utterances, u = [u1, .", 
        "197": ".", 
        "198": ".", 
        "199": ", u5], we consider all length-1 and length-2 substrings of u: [u1], [u2], .", 
        "200": ".", 
        "201": ".", 
        "202": ", [u3, u4], [u4, u5] (9 total).", 
        "203": "We form a new training example from each substring, e.g., (u\u2032, w\u20320, w \u2032 M ) where u\n\u2032 = [u4, u5], w\u20320 = w3 and w \u2032 M = w5.", 
        "204": "All models are implemented in TensorFlow (Abadi et al., 2015).", 
        "205": "Model parameters are randomly initialized (Glorot and Bengio, 2010), with no pre-training.", 
        "206": "We use the Adam optimizer (Kingma and Ba, 2014) (which is applied to the gradient in (6)), a learning rate of 0.001, a minibatch size of 8 examples (different from the beam size), and train until accuracy on the validation set converges (on average about 13,000 steps).", 
        "207": "We\n4 Also, note that if exploration were exhaustive, \u03b2 = 0 would be equivalent to supervised learning using the set of all reward-earning programs as targets.", 
        "208": "5 These problems concern the gradient w.r.t.", 
        "209": "a single example.", 
        "210": "The full gradient averages over multiple examples, which helps separate correct from spurious.", 
        "211": "E.g., if multiple examples all mention \u201cyellow hat\u201d, we will find a correct program parsing this as hasHat(yellow) for each example, whereas the spurious programs we find will follow no consistent pattern.", 
        "212": "Consequently, spurious gradient contributions may cancel out while correct program gradients will all \u201cvote\u201d in the same direction.", 
        "213": "use fixed GloVe vectors (Pennington et al., 2014) to embed the words in each utterance.", 
        "214": "Hyperparameters.", 
        "215": "For all models, we performed a grid search over hyperparameters to maximize accuracy on the validation set.", 
        "216": "Hyperparameters include the learning rate, the baseline in REINFORCE, -greediness and \u03b2meritocraticness.", 
        "217": "For REINFORCE, we also experimented with a regression-estimated baseline (Ranzato et al., 2015), but found it to perform worse than a constant baseline.", 
        "218": "6.1 Main results  Comparison to prior work.", 
        "219": "Table 2 compares RANDOMER to results from Long et al.", 
        "220": "(2016) as well as two baselines, REINFORCE and BSMML (using the same neural model but different learning algorithms).", 
        "221": "Our approach achieves new state-of-the-art results by a significant margin, especially on the SCENE domain, which features the most complex program syntax.", 
        "222": "We report the results for REINFORCE, BS-MML, and RANDOMER on the seed and hyperparameters that achieve the best validation accuracy.", 
        "223": "We note that REINFORCE performs very well on TANGRAMS but worse on ALCHEMY and very poorly on SCENE.", 
        "224": "This might be because the program syntax for TANGRAMS is simpler than the other two: there is no other way to refer to objects except by index.", 
        "225": "We also found that REINFORCE required - greedy exploration to make any progress.", 
        "226": "Using -greedy greatly skews the Monte Carlo approximation of \u2207JRL, making it more uniformly weighted over programs in a similar spirit to using \u03b2-meritocratic gradient weights q\u03b2 .", 
        "227": "However, q\u03b2 increases uniformity over reward-earning programs only, rather than over all programs.", 
        "228": "Effect of randomized beam search.", 
        "229": "Table 3 shows that -greedy randomized beam search consistently outperforms classic beam search.", 
        "230": "Even when we increase the beam size of classic beam\nsearch to 128, it still does not surpass randomized beam search with a beam of 32, and further increases yield no additional improvement.", 
        "231": "Effect of \u03b2-meritocratic updates.", 
        "232": "Table 4 evaluates the impact of \u03b2-meritocratic parameter updates (gradient weight q\u03b2).", 
        "233": "More uniform upweighting across reward-earning programs leads to higher accuracy and fewer spurious programs, especially in SCENE.", 
        "234": "However, no single value of \u03b2 performs best over all domains.", 
        "235": "Choosing the right value of \u03b2 in RANDOMER significantly accelerates training.", 
        "236": "Figure 3 illustrates that while \u03b2 = 0 and \u03b2 = 1 ultimately achieve similar accuracy on ALCHEMY, \u03b2 = 0 reaches good performance in half the time.", 
        "237": "Since lowering \u03b2 reduces trust in the model policy, \u03b2 < 1 helps in early training when the current policy is untrustworthy.", 
        "238": "However, as it grows more trustworthy, \u03b2 < 1 begins to pay a price for ignoring it.", 
        "239": "Hence, it may be worthwhile to anneal \u03b2 towards 1 over time.", 
        "240": "Effect of execution history embedding.", 
        "241": "Table 5 compares our two proposals for embedding the execution history: TOKENS and STACK.", 
        "242": "STACK performs better in the two domains where an object can be referenced in multiple ways (SCENE and ALCHEMY).", 
        "243": "STACK directly embeds objects on the stack, invariant to the way in which they were pushed onto the stack, unlike TOKENS.", 
        "244": "We hypothesize that this invariance increases robustness to spurious behavior: if a program accidentally pushes the right object onto the stack via spurious means, the model can still learn the remaining steps of the program without conditioning on a spurious history.", 
        "245": "Fitting vs overfitting the training data.", 
        "246": "Table 6 reveals that BS-MML and RANDOMER use different strategies to fit the training data.", 
        "247": "On the depicted training example, BS-MML actually achieves higher expected reward / marginal probability than RANDOMER, but it does so by putting most of its probability on a spurious program\u2014 a form of overfitting.", 
        "248": "In contrast, RANDOMER spreads probability mass over multiple rewardearning programs, including the correct ones.", 
        "249": "As a consequence of overfitting, we observed at test time that BS-MML only references people by positional indices instead of by shirt or hat color, whereas RANDOMER successfully learns to use multiple reference strategies.", 
        "250": "7 Related work and discussion  Semantic parsing from indirect supervision.", 
        "251": "Our work is motivated by the classic problem of learning semantic parsers from indirect supervision (Clarke et al., 2010; Liang et al., 2011; Artzi\nand Zettlemoyer, 2011, 2013; Reddy et al., 2014; Pasupat and Liang, 2015).", 
        "252": "We are interested in the initial stages of training from scratch, where getting any training signal is difficult due to the combinatorially large search space.", 
        "253": "We also highlighted the problem of spurious programs which capture reward but give incorrect generalizations.", 
        "254": "Maximum marginal likelihood with beam search (BS-MML) is traditionally used to learn semantic parsers from indirect supervision.", 
        "255": "Reinforcement learning.", 
        "256": "Concurrently, there has been a recent surge of interest in reinforcement learning, along with the wide application of the classic REINFORCE algorithm (Williams, 1992)\u2014to troubleshooting (Branavan et al., 2009), dialog generation (Li et al., 2016), game playing (Narasimhan et al., 2015), coreference resolution (Clark and Manning, 2016), machine translation (Norouzi et al., 2016), and even semantic parsing (Liang et al., 2017).", 
        "257": "Indeed, the challenge of training semantic parsers from indirect supervision is perhaps better captured by the notion of sparse rewards in reinforcement learning.", 
        "258": "The RL answer would be better exploration, which can take many forms including simple action-dithering such as -greedy, entropy regularization (Williams and Peng, 1991), Monte Carlo tree search (Coulom, 2006), randomized value functions (Osband et al., 2014, 2016), and methods which prioritize learning environment dynamics (Duff, 2002) or under-explored states (Kearns and Singh, 2002; Bellemare et al., 2016; Nachum et al., 2016).", 
        "259": "The majority of these methods employ Monte Carlo sampling for exploration.", 
        "260": "In\ncontrast, we find randomized beam search to be more suitable in our setting, because it explores low-probability states even when the policy distribution is peaky.", 
        "261": "Our \u03b2-meritocratic update also depends on the fact that beam search returns an entire set of reward-earning programs rather than one, since it renormalizes over the reward-earning set.", 
        "262": "While similar to entropy regularization, \u03b2meritocratic update is more targeted as it only increases uniformity of the gradient among rewardearning programs, rather than across all programs.", 
        "263": "Our strategy of using randomized beam search and meritocratic updates lies closer to MML than RL, but this does not imply that RL has nothing to offer in our setting.", 
        "264": "With the simple connection between RL and MML we established, much of the literature on exploration and variance reduction in RL can be directly applied to MML problems.", 
        "265": "Of special interest are methods which incorporate a value function such as actor-critic.", 
        "266": "Maximum likelihood and RL.", 
        "267": "It is tempting to group our approach with sequence learning methods which interpolate between supervised learning and reinforcement learning (Ranzato et al., 2015; Venkatraman et al., 2015; Ross et al., 2011; Norouzi et al., 2016; Bengio et al., 2015; Levine,\n2014).", 
        "268": "These methods generally seek to make RL training easier by pre-training or \u201cwarm-starting\u201d with fully supervised learning.", 
        "269": "This requires each training example to be labeled with a reasonably correct output sequence.", 
        "270": "In our setting, this would amount to labeling each example with the correct program, which is not known.", 
        "271": "Hence, these methods cannot be directly applied.", 
        "272": "Without access to correct output sequences, we cannot directly maximize likelihood, and instead resort to maximizing the marginal likelihood (MML).", 
        "273": "Rather than proposing MML as a form of pre-training, we argue that MML is a superior substitute for the standard RL objective, and that the \u03b2-meritocratic update is even better.", 
        "274": "Simulated annealing.", 
        "275": "Our \u03b2-meritocratic update employs exponential smoothing, which bears resemblance to the simulated annealing strategy of Och (2003); Smith and Eisner (2006); Shen et al.", 
        "276": "(2015).", 
        "277": "However, a key difference is that these methods smooth the objective function whereas we smooth an expectation in the gradient.", 
        "278": "To underscore the difference, we note that fixing \u03b2 = 0 in our method (total smoothing) is quite effective, whereas total smoothing in the simulated annealing methods would correspond to a completely flat objective function, and an uninformative gradient of zero everywhere.", 
        "279": "Neural semantic parsing.", 
        "280": "There has been recent interest in using recurrent neural networks for semantic parsing, both for modeling logical forms (Dong and Lapata, 2016; Jia and Liang, 2016; Liang et al., 2017) and for end-to-end execution (Yin et al., 2015; Neelakantan et al., 2016).", 
        "281": "We develop a neural model for the context-dependent setting, which is made possible by a new stackbased language similar to Riedel et al.", 
        "282": "(2016).", 
        "283": "Acknowledgments.", 
        "284": "This work was supported by the NSF Graduate Research Fellowship under No.", 
        "285": "DGE-114747 and the NSF CAREER Award under No.", 
        "286": "IIS-1552635.", 
        "287": "Reproducibility.", 
        "288": "Our code is made available at https://github.com/kelvinguu/lang2program.", 
        "289": "Reproducible experiments are available at https://worksheets.codalab.org/worksheets/ 0x88c914ee1d4b4a4587a07f36f090f3e5/.", 
        "290": "A Hyperparameters in Table 2  System ALCHEMY TANGRAMS SCENE\nREINFORCE\nSample size 32 Baseline 10\u22122\n= 0.15 embed TOKENS\nSample size 32 Baseline 10\u22122\n= 0.15 embed TOKENS\nSample size 32 Baseline 10\u22124\n= 0.15 embed TOKENS\nBS-MML Beam size 128 embed TOKENS Beam size 128 embed TOKENS Beam size 128 embed TOKENS\nRANDOMER \u03b2 = 1 = 0.05 embed TOKENS \u03b2 = 1 = 0.15 embed TOKENS \u03b2 = 0 = 0.15 embed STACK\nB SCONE domains and program tokens token type semantics Shared across ALCHEMY, TANGRAMS, SCENE 1, 2, 3, .", 
        "291": ".", 
        "292": ".", 
        "293": "constant push: number -1, -2, -3, .", 
        "294": ".", 
        "295": ".", 
        "296": "red, yellow, green, constant push: color orange, purple, brown allObjects constant push: the list of all objects index function pop: a list L and a number i\npush: the object L[i] (the index starts from 1; negative indices are allowed) prevArgj (j = 1, 2) function pop: a number i push: the j argument from the ith action prevAction action pop: a number i perform: fetch the ith action and execute it using the arguments on the stack Additional tokens for the ALCHEMY domain An ALCHEMY world contains 7 beakers.", 
        "297": "Each beaker may contain up to 4 units of colored chemical.", 
        "298": "1/1 constant push: fraction (used in the drain action) hasColor function pop: a color c push: list of beakers with chemical color c drain action pop: a beaker b and a number or fraction a perform: remove a units of chemical (or all chemical if a = 1/1) from b pour action pop: two beakers b1 and b2 perform: transfer all chemical from b1 to b2 mix action pop: a beaker b perform: turn the color of the chemical in b to brown Additional tokens for the TANGRAMS domain A TANGRAMS world contains a row of tangram pieces with different shapes.", 
        "299": "The shapes are anonymized; a tangram can be referred to by an index or a history reference, but not by shape.", 
        "300": "swap action pop: two tangrams t1 and t2 perform: exchange the positions of t1 and t2 remove action pop: a tangram t perform: remove t from the stage add action pop: a number i and a previously removed tangram t perform: insert t to position i Additional tokens for the SCENE domain A SCENE world is a linear stage with 10 positions.", 
        "301": "Each position may be occupied by a person with a colored shirt and optionally a colored hat.", 
        "302": "There are usually 1-5 people on the stage.", 
        "303": "noHat constant push: pseudo-color (indicating that the person is not wearing a hat) hasShirt, hasHat function pop: a color c push: the list of all people with shirt or hat color c hasShirtHat function pop: two colors c1 and c2 push: the list of all people with shirt color c1 and hat color c2 leftOf, rightOf function pop: a person p push: the location index left or right of p create action pop: a number i and two colors c1, c2 perform: add a new person at position i with shirt color c1 and hat color c2 move action pop: a person p and a number i perform: move p to position i swapHats action pop: two people p1 and p2 perform: have p1 and p2 exchange their hats leave action pop: a person p\nperform: remove p from the stage"
    }, 
    "document_id": "P17-1097.pdf.json"
}
