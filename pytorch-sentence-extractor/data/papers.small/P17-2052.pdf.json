{
    "abstract_sentences": {
        "1": "As entity type systems become richer and more fine-grained, we expect the number of types assigned to a given entity to increase.", 
        "2": "However, most fine-grained typing work has focused on datasets that exhibit a low degree of type multiplicity.", 
        "3": "In this paper, we consider the high-multiplicity regime inherent in data sources such as Wikipedia that have semi-open type systems.", 
        "4": "We introduce a set-prediction approach to this problem and show that our model outperforms unstructured baselines on a new Wikipedia-based fine-grained typing corpus."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Short Papers), pages 330\u2013334 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-2052  1 Introduction  Motivated by potential applications to information retrieval, coreference resolution, question answering, and other downstream tasks, recent work on entity typing has moved beyond coarse-grained systems towards richer ontologies with much more detailed information, and therefore correspondingly more specific types (Ling and Weld, 2012; Gillick et al., 2014; Yogatama et al., 2015).", 
        "2": "As types become more specific, entities will tend to belong to more types (i.e.", 
        "3": "there will tend to be higher type multiplicity).", 
        "4": "However, most data used in previous work exhibits an extremely low degree of multiplicity.", 
        "5": "In this paper, we focus on the high multiplicity case, which we argue naturally arises in largescale knowledge resources.", 
        "6": "To illustrate this point, we construct a corpus of entity mentions paired with higher-multiplicity type assignments.", 
        "7": "Our corpus is based on mentions and categories drawn from Wikipedia, but we generalize and denoise the raw Wikipedia categories to provide more coherent supervision.", 
        "8": "Table 1 gives examples of type\nassignments from our dataset.", 
        "9": "As type multiplicity grows, it is natural to consider type prediction as an inherently set-valued problem and ask questions about how such sets might be modeled.", 
        "10": "To this end, we develop a structured prediction approach in which the sets of assigned types are predicted as first-class objects, including a preliminary consideration of how to efficiently search over them.", 
        "11": "The resulting model captures type correlations and ultimately outperforms a strong unstructured baseline.", 
        "12": "Related work The fine-grained entity typing problem was first investigated in detail by Ling and Weld (2012).", 
        "13": "Subsequently, Gillick et al.", 
        "14": "(2014) introduced a larger evaluation corpus for this task and introduced methods for training predictors based on multiclass classification.", 
        "15": "Both used the Freebase typing system, coarsened to approximately 100 types, and subsequent work\n330\nhas mostly followed this lead (Yaghoobzadeh and Schu\u0308tze, 2016; Yogatama et al., 2015), although types based on WordNet have recently also been investigated (Corro et al., 2015).", 
        "16": "Most prior work has focused on unstructured predictors using some form of multiclass logistic regression (Ling and Weld, 2012; Gillick et al., 2014; Shimaoka et al., 2016; Yaghoobzadeh and Schu\u0308tze, 2016; Yogatama et al., 2015).", 
        "17": "Some of these approaches implicitly incorporate structure during decoding by enforcing hierarchy constraints (Gillick et al., 2014), while neural approaches can encode correlations in a soft manner via shared hidden layers (Shimaoka et al., 2016; Yaghoobzadeh and Schu\u0308tze, 2016).", 
        "18": "Our work differs from these lines of work in two respects: its use of a corpus exhibiting high type multiplicity with types derived from a semi-open inventory and its use of a fully structured model and decoding procedure, one that can in principle be integrated with neural models if desired.", 
        "19": "Previously, most results focused on the low-multiplicity Freebase-based FIGER corpus.", 
        "20": "The only work we are aware of that uses a type system similar to ours used a rule-based system and evaluated on their own newswire- and Twitter-based evaluation corpora (Corro et al., 2015).", 
        "21": "2 Model  Our structured prediction framework is based on modeling type assignments as sets.", 
        "22": "Each entity e is assigned a set of types T \u2217 drawn from the over-\nall set of types T .", 
        "23": "Our goal is thus to predict, given an input sentence-entity pair, the set of types associated with that entity.", 
        "24": "We take the commonly-used linear model approach to this structured prediction problem.", 
        "25": "Given a featurizer \u03d5 that takes an input sentence x and entity e, we seek to learn a weight vector w such that\nf (x, e) = argmaxT w >\u03d5 (x, e, T ) (1)\npredicts T correctly with high accuracy.", 
        "26": "Our approach stands in contrast to prior work, which deployed several techniques, of similar efficacy, to port single-type learning and inference strategies to the multi-type setting (Gillick et al., 2014).", 
        "27": "Provided type interactions can be neglected, equation (1) can be simplified to\nfsingle (x, e) = { t \u2208 T : w>\u03d5 (x, e, t) \u2265 r } .", 
        "28": "This simplification corresponds to expanding each multi-type example triple (x, e, T \u2217) into a set of single-type example triples { (x, e, t\u2217)t\u2217\u2208T \u2217 } .", 
        "29": "Learning can then be done using any technique for multiclass logistic regression, and inference can be carried out by specifying a threshold r and predicting all types that score above that threshold: In prior work, a simple r = 0 threshold was used (Ling and Weld, 2012).", 
        "30": "In this paper, we focus on the more general specification (1), though in Section 2.2, we explain a simplification that can be used to speed up inference if desired.", 
        "31": "2.1 Features  Modeling type assignments as sets in principle opens the door to non-decomposable set features (a simple instance of which would be set size).", 
        "32": "For reasons of tractability, we assume our features factor along type pairs:\n\u03d5 (x, e, T ) = \u2211\nt\u2208T \u03d5 (x, e, t) +\n\u2211 t, t\u2032\u2208T \u03d5 ( t, t\u2032 )\n(2) Note that in addition to enforcing factorization over type pairs, the specification (2) requires that any features linking the type assignment to the observed entity mention depend only on a single type at a time.", 
        "33": "We investigated non-decomposable features, but found they did not lead to improved performance.", 
        "34": "We use entity mention features very similar to those in previous work:\n1.", 
        "35": "Context unigrams and bigrams.", 
        "36": "Indicators on all uni- and bigrams within a certain window of the entity mention.", 
        "37": "2.", 
        "38": "Dependency parse features.", 
        "39": "Indicators on the lexical parent of the entity mention head, as well as the corresponding dependency type.", 
        "40": "Separately, indicators on the lexical children of the entity mention head and their dependency types.", 
        "41": "3.", 
        "42": "Entity head and non-head tokens.", 
        "43": "Indicators on the syntactic head of the entity mention and on its non-head tokens.", 
        "44": "4.", 
        "45": "Word shape features.", 
        "46": "Indicators on the shape of each token in the entity mention.", 
        "47": "We combine these features with type-based features to obtain the features our model actually uses:\n1.", 
        "48": "Conjunction features.", 
        "49": "These are simple conjunctions of mention features with indicators on type membership in the predicted set.", 
        "50": "Using only these features results in an unstructured model.", 
        "51": "2.", 
        "52": "Type pair features.", 
        "53": "These are indicators on pairs of types appearing in the predicted set.", 
        "54": "3.", 
        "55": "Graph-based features.", 
        "56": "As we discuss in Section 3, the type system in our corpus comes with a graph structure.", 
        "57": "We add indicators on certain patterns occurring within the\nset\u2013e.g.", 
        "58": "a parent-child type pair, sibling type pairs, and so on, abstracting away the specific types.", 
        "59": "2.2 Learning and Inference  We train our system using structured maxmargin (Tsochantaridis et al., 2005).", 
        "60": "Optimization is performed via AdaGrad on the primal (Kummerfeld et al., 2015).", 
        "61": "We use set-F1 as our loss function.", 
        "62": "Inference, for both prediction and lossaugmented decoding, poses a greater challenge, as solving the maximization problem (1) exactly requires iterating over all subsets of the type system.", 
        "63": "Fortunately, we find a simple greedy algorithm is effective.", 
        "64": "Our decoder begins by choosing the type that scores highest individually, taking only single-type features into account.", 
        "65": "It then proceeds by iteratively adding new types into the set until doing so would decrease the score.", 
        "66": "At the cost of restricting the permissible type sets slightly, we can speed up the greedy procedure further.", 
        "67": "Specifically, we can require that the predicted type set T be connected in some constraint graph over the types\u2014either the co-occurrence graph, the complete graph, or the graph underlying the type system.", 
        "68": "If we denote by C the set of all such connected sets, the corresponding predictor would be\nfconn (x, e) = argmaxT\u2208C w >\u03d5 (x, e, T )\nThe greedy decoding procedure for this predictor is faster because at each step, it need only consider adding types that are adjacent to some type that has already been included.", 
        "69": "3 Corpus  Our corpus construction methodology involves three key stages: mention identification, type system construction, and type assignment.1 We explain each of these in turn.", 
        "70": "Mention identification.", 
        "71": "We follow prior work on entity linking (Durrett and Klein, 2014) and take all mentions that occur as anchor text.", 
        "72": "We filter the resulting collection of mentions down to those that pass a heuristic filter that removes mentions of common nouns, as well as spurious sentences representing Wikipedia formatting.", 
        "73": "Type system construction.", 
        "74": "Prior work on finegrained entity typing has derived its type system from Freebase (Ling and Weld, 2012; Gillick et al., 2014).", 
        "75": "The resulting ontologies thus inherit the coverage and specificity limitations of Freebase, somewhat exacerbated by manual coarsening.", 
        "76": "Motivated by efforts to inject broader coverage, more complex knowledge resources into NLP systems, we instead derive our types from the Wikipedia category and WordNet graphs, in a manner similar to that of Ponzetto and Strube (2007).", 
        "77": "Our base type set consists of all Wikipedia categories.", 
        "78": "By following back-pointers in articles for categories, we derive a base underlying directed graph.", 
        "79": "To eliminate noise, we filter down to all categories whose syntactic heads can be found in WordNet and keep directed edges only when the head of the parent is a WordNet ancestor of the\n1Our corpus will be released at http://people.", 
        "80": "eecs.berkeley.edu/\u02dcrabinovich/.", 
        "81": "head of the child.", 
        "82": "We conclude by projecting each type down to its syntactic head.", 
        "83": "Type assignment.", 
        "84": "The type set for an entity is obtained by taking its Wikipedia category assignments, augmenting these with their ancestors in the category graph above, and then projecting these down to their syntactic heads.", 
        "85": "4 Experiments  We evaluate our method on the dataset described in Section 3.", 
        "86": "For these experiments, we restrict to the 100 most frequent types and downsample to 750K mentions.", 
        "87": "We use a baseline that closely replicates the FIGER system (Ling and Weld, 2012).", 
        "88": "Within our framework, this can be thought of as a model that sets all type pair features in (2) to zero.", 
        "89": "Table 3 summarizes our results.", 
        "90": "Starting with the baseline, we incrementally add the type pair, graph-based, and set size features discussed in 2.1.", 
        "91": "Adding type pair features results in an appreciable performance gain, while the graph features bring little benefit\u2014potentially because pairwise correlations suffice to summarize the set structure when the number of types is moderately low.", 
        "92": "A concern when studying multiclass problems with large numbers of classes, whether predicting sets or individual labels, is that performance on instances associated with common classes will dominate the performance metric.", 
        "93": "Figure 3 shows micro-averaged F1 for the binary prediction task associated with predicting the presence or absence of each type, demonstrating that our performance is strong even for many rare types.", 
        "94": "5 Conclusion  We have highlighted the issue of multiplicity in fine-grained entity typing.", 
        "95": "Whereas most prior work has focused on corpora with low multiplicity assignments, we denoised the Wikipedia type system to construct a realistic corpus with high multiplicity type assignments.", 
        "96": "Using this corpus as a testbed, we showed that an approach based on structured prediction of sets can outperform unstructured baselines when type assignments have high multiplicity.", 
        "97": "Our approach may therefore be preferable in such contexts."
    }, 
    "document_id": "P17-2052.pdf.json"
}
