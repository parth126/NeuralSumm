{
    "abstract_sentences": {
        "1": "We study a symmetric collaborative dialogue setting in which two agents, each with private knowledge, must strategically communicate to achieve a common goal.", 
        "2": "The open-ended dialogue state in this setting poses new challenges for existing dialogue systems.", 
        "3": "We collected a dataset of 11K human-human dialogues, which exhibits interesting lexical, semantic, and strategic elements.", 
        "4": "To model both structured knowledge and unstructured language, we propose a neural model with dynamic knowledge graph embeddings that evolve as the dialogue progresses.", 
        "5": "Automatic and human evaluations show that our model is both more effective at achieving the goal and more human-like than baseline neural and rule-based models."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1766\u20131776 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1162  1 Introduction  Current task-oriented dialogue systems (Young et al., 2013; Wen et al., 2017; Dhingra et al., 2017) require a pre-defined dialogue state (e.g., slots such as food type and price range for a restaurant searching task) and a fixed set of dialogue acts (e.g., request, inform).", 
        "2": "However, human conversation often requires richer dialogue states and more nuanced, pragmatic dialogue acts.", 
        "3": "Recent opendomain chat systems (Shang et al., 2015; Serban et al., 2015b; Sordoni et al., 2015; Li et al., 2016a; Lowe et al., 2017; Mei et al., 2017) learn a mapping directly from previous utterances to the next utterance.", 
        "4": "While these models capture open-ended aspects of dialogue, the lack of structured dialogue state prevents them from being directly applied to settings that require interfacing with structured knowledge.", 
        "5": "In order to bridge the gap between the two types\nFriends of agent A:\nName School Major Company\nJessica Columbia Computer Science Google Josh Columbia Linguistics Google ... ... ... ...\nA: Hi!", 
        "6": "Most of my friends work for Google B: do you have anyone who went to columbia?", 
        "7": "A: Hello?", 
        "8": "A: I have Jessica a friend of mine A: and Josh, both went to columbia B: or anyone working at apple?", 
        "9": "B: SELECT (Jessica, Columbia, Computer Science, Google) A: SELECT (Jessica, Columbia, Computer Science, Google)\nFigure 1: An example dialogue from the MutualFriends task in which two agents, A and B, each given a private list of a friends, try to identify their mutual friend.", 
        "10": "Our objective is to build an agent that can perform the task with a human.", 
        "11": "Crosstalk (Section 2.3) is italicized.", 
        "12": "of systems, we focus on a symmetric collaborative dialogue setting, which is task-oriented but encourages open-ended dialogue acts.", 
        "13": "In our setting, two agents, each with a private list of items with attributes, must communicate to identify the unique shared item.", 
        "14": "Consider the dialogue in Figure 1, in which two people are trying to find their mutual friend.", 
        "15": "By asking \u201cdo you have anyone who went to columbia?\u201d, B is suggesting that she has some Columbia friends, and that they probably work at Google.", 
        "16": "Such conversational implicature is lost when interpreting the utterance as simply an information request.", 
        "17": "In addition, it is hard to define a structured state that captures the diverse semantics in many utterances (e.g., defining \u201cmost of\u201d, \u201cmight be\u201d; see details in Table 1).", 
        "18": "To model both structured and open-ended context, we propose the Dynamic Knowledge Graph Network (DynoNet), in which the dialogue state is modeled as a knowledge graph with an embedding\n1766\nfor each node (Section 3).", 
        "19": "Our model is similar to EntNet (Henaff et al., 2017) in that node/entity embeddings are updated recurrently given new utterances.", 
        "20": "The difference is that we structure entities as a knowledge graph; as the dialogue proceeds, new nodes are added and new context is propagated on the graph.", 
        "21": "An attention-based mechanism (Bahdanau et al., 2015) over the node embeddings drives generation of new utterances.", 
        "22": "Our model\u2019s use of knowledge graphs captures the grounding capability of classic task-oriented systems and the graph embedding provides the representational flexibility of neural models.", 
        "23": "The naturalness of communication in the symmetric collaborative setting enables large-scale data collection: We were able to crowdsource around 11K human-human dialogues on Amazon Mechanical Turk (AMT) in less than 15 hours.1 We show that the new dataset calls for more flexible representations beyond fully-structured states (Section 2.2).", 
        "24": "In addition to conducting the third-party human evaluation adopted by most work (Liu et al., 2016; Li et al., 2016b,c), we also conduct partner evaluation (Wen et al., 2017) where AMT workers rate their conversational partners (other workers or our models) based on fluency, correctness, cooperation, and human-likeness.", 
        "25": "We compare DynoNet with baseline neural models and a strong rulebased system.", 
        "26": "The results show that DynoNet can perform the task with humans efficiently and naturally; it also captures some strategic aspects of human-human dialogues.", 
        "27": "The contributions of this work are: (i) a new symmetric collaborative dialogue setting and a large dialogue corpus that pushes the boundaries of existing dialogue systems; (ii) DynoNet, which integrates semantically rich utterances with structured knowledge to represent open-ended dialogue states; (iii) multiple automatic metrics based on bot-bot chat and a comparison of third-party and partner evaluation.", 
        "28": "2 Symmetric Collaborative Dialogue  We begin by introducing a collaborative task between two agents and describe the human-human dialogue collection process.", 
        "29": "We show that our data exhibits diverse, interesting language phenomena.", 
        "30": "1The dataset is available publicly at https:// stanfordnlp.github.io/cocoa/.", 
        "31": "2.1 Task Definition  In the symmetric collaborative dialogue setting, there are two agents, A and B, each with a private knowledge base\u2014KBA and KBB, respectively.", 
        "32": "Each knowledge base includes a list of items, where each item has a value for each attribute.", 
        "33": "For example, in the MutualFriends setting, Figure 1, items are friends and attributes are name, school, etc.", 
        "34": "There is a shared item that A and B both have; their goal is to converse with each other to determine the shared item and select it.", 
        "35": "Formally, an agent is a mapping from its private KB and the dialogue thus far (sequence of utterances) to the next utterance to generate or a selection.", 
        "36": "A dialogue is considered successful when both agents correctly select the shared item.", 
        "37": "This setting has parallels in human-computer collaboration where each agent has complementary expertise.", 
        "38": "2.2 Data collection  We created a schema with 7 attributes and approximately 3K entities (attribute values).", 
        "39": "To elicit linguistic and strategic variants, we generate a random scenario for each task by varying the number of items (5 to 12), the number attributes (3 or 4), and the distribution of values for each attribute (skewed to uniform).", 
        "40": "See Appendix A and B for details of schema and scenario generation.", 
        "41": "We crowdsourced dialogues on AMT by randomly pairing up workers to perform the task within 5 minutes.2 Our chat interface is shown in Figure 2.", 
        "42": "To discourage random guessing, we prevent workers from selecting more than once every 10 seconds.", 
        "43": "Our task was very popular and we col-\n2If the workers exceed the time limit, the dialogue is marked as unsuccessful (but still logged).", 
        "44": "lected 11K dialogues over a period of 13.5 hours.3 Of these, over 9K dialogues are successful.", 
        "45": "Unsuccessful dialogues are usually the result of either worker leaving the chat prematurely.", 
        "46": "2.3 Dataset statistics  We show the basic statistics of our dataset in Table 3.", 
        "47": "An utterance is defined as a message sent by one of the agents.", 
        "48": "The average utterance length is short due to the informality of the chat, however, an agent usually sends multiple utterances in one turn.", 
        "49": "Some example dialogues are shown in Table 6 and Appendix I.", 
        "50": "We categorize utterances into coarse types\u2014 inform, ask, answer, greeting, apology\u2014by pattern matching (Appendix E).", 
        "51": "There are 7.4% multitype utterances, and 30.9% utterances contain more than one entity.", 
        "52": "In Table 1, we show example utterances with rich semantics that cannot be sufficiently represented by traditional slot-values.", 
        "53": "3Tasks are put up in batches; the total time excludes intervals between batches.", 
        "54": "4Entity names are replaced by their entity types.", 
        "55": "Some of the standard ones are also non-trivial due to coreference and logical compositionality.", 
        "56": "Our dataset also exhibits some interesting communication phenomena.", 
        "57": "Coreference occurs frequently when people check multiple attributes of one item.", 
        "58": "Sometimes mentions are dropped, as an utterance simply continues from the partner\u2019s utterance.", 
        "59": "People occasionally use external knowledge to group items with out-of-schema attributes (e.g., gender based on names, location based on schools).", 
        "60": "We summarize these phenomena in Table 2.", 
        "61": "In addition, we find 30% utterances involve cross-talk where the conversation does not progress linearly (e.g., italic utterances in Figure 1), a common characteristic of online chat (Ivanovic, 2005).", 
        "62": "One strategic aspect of this task is choosing the order of attributes to mention.", 
        "63": "We find that people tend to start from attributes with fewer unique values, e.g., \u201call my friends like morning\u201d given the KBB in Table 6, as intuitively it would help exclude items quickly given fewer values to check.5 We provide a more detailed analysis of strategy in Section 4.2 and Appendix F.  3 Dynamic Knowledge Graph Network  The diverse semantics in our data motivates us to combine unstructured representation of the dialogue history with structured knowledge.", 
        "64": "Our\n5Our goal is to model human behavior thus we do not discuss the optimal strategy here.", 
        "65": "model consists of three components shown in Figure 3: (i) a dynamic knowledge graph, which represents the agent\u2019s private KB and shared dialogue history as a graph (Section 3.1), (ii) a graph embedding over the nodes (Section 3.2), and (iii) an utterance generator (Section 3.3).", 
        "66": "The knowledge graph represents entities and relations in the agent\u2019s private KB, e.g., item-1\u2019s company is google.", 
        "67": "As the conversation unfolds, utterances are embedded and incorporated into node embeddings of mentioned entities.", 
        "68": "For instance, in Figure 3, \u201canyone went to columbia\u201d updates the embedding of columbia.", 
        "69": "Next, each node recursively passes its embedding to neighboring nodes so that related entities (e.g., those in the same row or column) also receive information from the most recent utterance.", 
        "70": "In our example, jessica and josh both receive new context when columbia is mentioned.", 
        "71": "Finally, the utterance generator, an LSTM, produces the next utterance by attending to the node embeddings.", 
        "72": "3.1 Knowledge Graph  Given a dialogue of T utterances, we construct graphs (Gt)Tt=1 over the KB and dialogue history for agent A.6 There are three types of nodes: item nodes, attribute nodes, and entity nodes.", 
        "73": "Edges between nodes represent their relations.", 
        "74": "For example, (item-1, hasSchool, columbia) means that the first item has attribute school whose value\n6 It is important to differentiate perspectives of the two agents as they have different KBs.", 
        "75": "Thereafter we assume the perspective of agent A, i.e., accessing KBA for A only, and refer to B as the partner.", 
        "76": "is columbia.", 
        "77": "An example graph is shown in Figure 3.", 
        "78": "The graph Gt is updated based on utterance t by taking Gt 1 and adding a new node for any entity mentioned in utterance t but not in KBA.7  3.2 Graph Embedding  Given a knowledge graph, we are interested in computing a vector representation for each node v that captures both its unstructured context from the dialogue history and its structured context in the KB.", 
        "79": "A node embedding Vt(v) for each node v 2 Gt is built from three parts: structural properties of an entity defined by the KB, embeddings of utterances in the dialogue history, and message passing between neighboring nodes.", 
        "80": "Node Features.", 
        "81": "Simple structural properties of the KB often govern what is talked about; e.g., a high-frequency entity is usually interesting to mention (consider \u201cAll my friends like dancing.\u201d).", 
        "82": "We represent this type of information as a feature vector Ft(v), which includes the degree and type (item, attribute, or entity type) of node v, and whether it has been mentioned in the current turn.", 
        "83": "Each feature is encoded as a one-hot vector and they are concatenated to form Ft(v).", 
        "84": "Mention Vectors.", 
        "85": "A mention vector Mt(v) contains unstructured context from utterances relevant to node v up to turn t. To compute it, we first define the utterance representation u\u0303t and the set of relevant entities Et.", 
        "86": "Let ut be the embedding of utterance t (Section 3.3).", 
        "87": "To differentiate between\n7 We use a rule-based lexicon to link text spans to entities.", 
        "88": "See details in Appendix D.\nthe agent\u2019s and the partner\u2019s utterances, we represent it as u\u0303t = \u21e5 ut \u00b7 {ut2Uself}, ut \u00b7 {ut2Upartner} \u21e4 , where Uself and Upartner denote sets of utterances generated by the agent and the partner, and [\u00b7, \u00b7] denotes concatenation.", 
        "89": "Let Et be the set of entity nodes mentioned in utterance t if utterance t mentions some entities, or utterance t 1 otherwise.8 The mention vector Mt(v) of node v incorporates the current utterance if v is mentioned and inherits Mt 1(v) if not:\nMt(v) = tMt 1(v) + (1 t)u\u0303t; (1)\nt =\n( W inc [Mt 1(v), u\u0303t]\nif v 2 Et,\n1 otherwise.", 
        "90": "Here, is the sigmoid function and W inc is a parameter matrix.", 
        "91": "Recursive Node Embeddings.", 
        "92": "We propagate information between nodes according to the structure of the knowledge graph.", 
        "93": "In Figure 3, given \u201canyone went to columbia?\u201d, the agent should focus on her friends who went to Columbia University.", 
        "94": "Therefore, we want this utterance to be sent to item nodes connected to columbia, and one step further to other attributes of these items because they might be mentioned next as relevant information, e.g., jessica and josh.", 
        "95": "We compute the node embeddings recursively, analogous to belief propagation:\nV kt (v) = max v02Nt(v) tanh (2) \u21e3 W mp h V k 1t (v 0), R(ev!v0) i\u2318 ,\nwhere V kt (v) is the depth-k node embedding at turn t and Nt(v) denotes the set of nodes adjacent to v. The message from a neighboring node v0 depends on its embedding at depth-(k 1), the edge label ev!v0 (embedded by a relation embedding function R), and a parameter matrix W mp.", 
        "96": "Messages from all neighbors are aggregated by max, the element-wise max operation.9 Example message passing paths are shown in Figure 3.", 
        "97": "The final node embedding is the concatenation of embeddings at each depth:\nVt(v) = \u21e5 V 0t (v), .", 
        "98": ".", 
        "99": ".", 
        "100": ", V K t (v) \u21e4 , (3)\nwhere K is a hyperparameter (we experiment with K 2 {0, 1, 2}) and V 0t (v) = [Ft(v), Mt(v)].", 
        "101": "8 Relying on utterance t 1 is useful when utterance t answers a question, e.g., \u201cdo you have any google friends?\u201d \u201cNo.\u201d\n9Using sum or mean slightly hurts performance.", 
        "102": "3.3 Utterance Embedding and Generation  We embed and generate utterances using Long Short Term Memory (LSTM) networks that take the graph embeddings into account.", 
        "103": "Embedding.", 
        "104": "On turn t, upon receiving an utterance consisting of nt tokens, xt = (xt,1, .", 
        "105": ".", 
        "106": ".", 
        "107": ", xt,nt), the LSTM maps it to a vector as follows:\nht,j = LSTMenc(ht,j 1, At(xt,j)), (4)\nwhere ht,0 = ht 1,nt 1 , and At is an entity abstraction function, explained below.", 
        "108": "The final hidden state ht,nt is used as the utterance embedding ut, which updates the mention vectors as described in Section 3.2.", 
        "109": "In our dialogue task, the identity of an entity is unimportant.", 
        "110": "For example, replacing google with alphabet in Figure 1 should make little difference to the conversation.", 
        "111": "The role of an entity is determined instead by its relation to other entities and relevant utterances.", 
        "112": "Therefore, we define the abstraction At(y) for a word y as follows: if y is linked to an entity v, then we represent an entity by its type (school, company etc.)", 
        "113": "embedding concatenated with its current node embedding: At(y) = [Etype(y), Vt(v)].", 
        "114": "Note that Vt(v) is determined only by its structural features and its context.", 
        "115": "If y is a non-entity, then At(y) is the word embedding of y concatenated with a zero vector of the same dimensionality as Vt(v).", 
        "116": "This way, the representation of an entity only depends on its structural properties given by the KB and the dialogue context, which enables the model to generalize to unseen entities at test time.", 
        "117": "Generation.", 
        "118": "Now, assuming we have embedded utterance xt 1 into ht 1,nt 1 as described above, we use another LSTM to generate utterance xt.", 
        "119": "Formally, we carry over the last utterance embedding ht,0 = ht 1,nt 1 and define:\nht,j = LSTMdec(ht,j 1, [At(xt,j), ct,j ]), (5)\nwhere ct,j is a weighted sum of node embeddings in the current turn: ct,j = P v2Gt \u21b5t,j,vVt(v), where \u21b5t,j,v are the attention weights over the nodes.", 
        "120": "Intuitively, high weight should be given to relevant entity nodes as shown in Figure 3,.", 
        "121": "We compute the weights through standard attention mechanism (Bahdanau et al., 2015):\n\u21b5t,j = softmax(st,j),\nst,j,v = w attn \u00b7 tanh W attn [ht,j 1, Vt(v)] ,\nwhere vector wattn and W attn are parameters.", 
        "122": "Finally, we define a distribution over both words in the vocabulary and nodes in Gt using the copying mechanism of Jia and Liang (2016):\np(xt,j+1 = y | Gt, xt,j) / exp W vocabht,j + b , p(xt,j+1 = r(v) | Gt, xt,j) / exp (st,j,v) ,\nwhere y is a word in the vocabulary, W vocab and b are parameters, and r(v) is the realization of the entity represented by node v, e.g., google is realized to \u201cGoogle\u201d during copying.10  4 Experiments  We compare our model with a rule-based system and a baseline neural model.", 
        "123": "Both automatic and human evaluations are conducted to test the models in terms of fluency, correctness, cooperation, and human-likeness.", 
        "124": "The results show that DynoNet is able to converse with humans in a coherent and strategic way.", 
        "125": "4.1 Setup  We randomly split the data into train, dev, and test sets (8:1:1).", 
        "126": "We use a one-layer LSTM with 100 hidden units and 100-dimensional word vectors for both the encoder and the decoder (Section 3.3).", 
        "127": "Each successful dialogue is turned into two examples, each from the perspective of one of the two agents.", 
        "128": "We maximize the log-likelihood of all utterances in the dialogues.", 
        "129": "The parameters are optimized by AdaGrad (Duchi et al., 2010) with an initial learning rate of 0.5.", 
        "130": "We trained for at least 10 epochs; after that, training stops if there is no improvement on the dev set for 5 epochs.", 
        "131": "By default, we perform K = 2 iterations of message passing to compute node embeddings (Section 3.2).", 
        "132": "For decoding, we sequentially sample from the output distribution with a softmax temperature of 0.5.11 Hyperparameters are tuned on the dev set.", 
        "133": "We compare DynoNet with its static cousion (StanoNet) and a rule-based system (Rule).", 
        "134": "StanoNet uses G0 throughout the dialogue, thus the dialogue history is completely contained in the LSTM states instead of being injected into the knowledge graph.", 
        "135": "Rule maintains weights for each entity and each item in the KB to decide\n10 We realize an entity by sampling from the empirical distribution of its surface forms found in the training data.", 
        "136": "11 Since selection is a common \u2018utterance\u2019 in our dataset and neural generation models are susceptible to overgenerating common sentences, we halve its probability during sampling.", 
        "137": "what to talk about and which item to select.", 
        "138": "It has a pattern-matching semantic parser, a rulebased policy, and a templated generator.", 
        "139": "See Appendix G for details.", 
        "140": "4.2 Evaluation  We test our systems in two interactive settings: bot-bot chat and bot-human chat.", 
        "141": "We perform both automatic evaluation and human evaluation.", 
        "142": "Automatic Evaluation.", 
        "143": "First, we compute the cross-entropy (`) of a model on test data.", 
        "144": "As shown in Table 4, DynoNet has the lowest test loss.", 
        "145": "Next, we have a model chat with itself on the scenarios from the test set.12 We evaluate the chats with respect to language variation, effectiveness, and strategy.", 
        "146": "For language variation, we report the average utterance length Lu and the unigram entropy H in Table 4.", 
        "147": "Compared to Rule, the neural models tend to generate shorter utterances (Li et al., 2016b; Serban et al., 2017b).", 
        "148": "However, they are more diverse; for example, questions are asked in multiple ways such as \u201cDo you have ...\u201d, \u201cAny friends like ...\u201d, \u201cWhat about ...\u201d.", 
        "149": "At the discourse level, we expect the distribution of a bot\u2019s utterance types to match the distribution of human\u2019s.", 
        "150": "We show percentages of each utterance type in Table 4.", 
        "151": "For Rule, the decision about which action to take is written in the rules, while StanoNet and DynoNet learned to behave in a more human-like way, frequently informing and asking questions.", 
        "152": "To measure effectiveness, we compute the overall success rate (C) and the success rate per turn (CT ) and per selection (CS).", 
        "153": "As shown in Table 4, humans are the best at this game, followed by Rule which is comparable to DynoNet.", 
        "154": "Next, we investigate the strategies leading to these results.", 
        "155": "An agent needs to decide which entity/attribute to check first to quickly reduce the search space.", 
        "156": "We hypothesize that humans tend to first focus on a majority entity and an attribute with fewer unique values (Section 2.3).", 
        "157": "For example, in the scenario in Table 6, time and location are likely to be mentioned first.", 
        "158": "We show the average frequency of first-mentioned entities (#Ent1) and the average number of unique values for first-mentioned attributes (|Attr1|) in Ta-\n12 We limit the number of turns in bot-bot chat to be the maximum number of turns humans took in the test set (46 turns).", 
        "159": "ble 4.13 Both DynoNet and StanoNet successfully match human\u2019s starting strategy by favoring entities of higher frequency and attributes of smaller domain size.", 
        "160": "To examine the overall strategy, we show the average number of attributes (#Attr) and entities (#Ent) mentioned during the conversation in Table 4.", 
        "161": "Humans and DynoNet strategically focus on a few attributes and entities, whereas Rule needs almost twice entities to achieve similar success rates.", 
        "162": "This suggests that the effectiveness of Rule mainly comes from large amounts of unselective information, which is consistent with comments from their human partners.", 
        "163": "Partner Evaluation.", 
        "164": "We generated 200 new scenarios and put up the bots on AMT using the same chat interface that was used for data collection.", 
        "165": "The bots follow simple turn-taking rules explained in Appendix H. Each AMT worker is randomly paired with Rule, StanoNet, DynoNet, or another human (but the worker doesn\u2019t know which), and we make sure that all four types of agents are tested in each scenario at least once.", 
        "166": "At the end of each dialogue, humans are asked to rate their partner in terms of fluency, correctness, cooperation, and human-likeness from 1 (very bad) to 5 (very good), along with optional comments.", 
        "167": "We show the average ratings (with significance tests) in Table 5 and the histograms in Appendix J.", 
        "168": "In terms of fluency, the models have similar performance since the utterances are usually short.", 
        "169": "Judgment on correctness is a mere guess since the evaluator cannot see the partner\u2019s KB; we will analyze correctness more meaningfully in the thirdparty evaluation below.", 
        "170": "13 Both numbers are normalized to [0, 1] with respect to all entities/attributes in the corresponding KB.", 
        "171": "Noticeably, DynoNet is more cooperative than the other models.", 
        "172": "As shown in the example dialogues in Table 6, DynoNet cooperates smoothly with the human partner, e.g., replying with relevant information about morning/indoor friends when the partner mentioned that all her friends prefer morning and most like indoor.", 
        "173": "StanoNet starts well but doesn\u2019t follow up on the morning friend, presumably because the morning node is not updated dynamically when mentioned by the partner.", 
        "174": "Rule follows the partner poorly.", 
        "175": "In the comments, the biggest complaint about Rule was that it was not \u2018listening\u2019 or \u2018understanding\u2019.", 
        "176": "Overall, DynoNet achieves better partner satisfaction, especially in cooperation.", 
        "177": "Third-party Evaluation.", 
        "178": "We also created a third-party evaluation task, where an independent AMT worker is shown a conversation and the KB of one of the agents; she is asked to rate the same aspects of the agent as in the partner evaluation and provide justifications.", 
        "179": "Each agent in a dialogue is rated by at least 5 people.", 
        "180": "The average ratings and histograms are shown in Table 5 and Appendix J.", 
        "181": "For correctness, we see that Rule has the best performance since it always tells the truth, whereas humans can make mistakes due to carelessness and the neural models can generate false information.", 
        "182": "For example, in Table 6, DynoNet \u2018lied\u2019 when saying that it has a morning friend who likes outdoor.", 
        "183": "Surprisingly, there is a discrepancy between the two evaluation modes in terms of cooperation and human-likeness.", 
        "184": "Manual analysis of the comments indicates that third-party evaluators focus less on the dialogue strategy and more on linguistic features, probably because they were not fully engaged in the dialogue.", 
        "185": "For example, justification\nfor cooperation often mentions frequent questions and timely answers, less attention is paid to what is asked about though.", 
        "186": "For human-likeness, partner evaluation is largely correlated with coherence (e.g., not repeating or ignoring past information) and task success, whereas third-party evaluators often rely on informality (e.g., usage of colloquia like \u201chiya\u201d, capitalization, and abbreviation) or intuition.", 
        "187": "Interestingly, third-party evaluators noted most phenomena listed in Table 2 as indicators of humanbeings, e.g., correcting oneself, making chit-chat other than simply finishing the task.", 
        "188": "See example comments in Appendix K.  4.3 Ablation Studies  Our model has two novel designs: entity abstraction and message passing for node embeddings.", 
        "189": "Table 7 shows what happens if we ablate these.", 
        "190": "When the number of message passing iterations, K, is reduced from 2 to 0, the loss consistently increases.", 
        "191": "Removing entity abstraction\u2014meaning adding entity embeddings to node embeddings and the LSTM input embeddings\u2014also degrades performance.", 
        "192": "This shows that DynoNet benefits from contextually-defined, structural node embeddings rather than ones based on a classic lookup table.", 
        "193": "5 Discussion and Related Work  There has been a recent surge of interest in end-to-end task-oriented dialogue systems, though progress has been limited by the size of available datasets (Serban et al., 2015a).", 
        "194": "Most work focuses on information-querying tasks, using Wizard-ofOz data collection (Williams et al., 2016; Asri et al., 2016) or simulators (Bordes and Weston, 2017; Li et al., 2016d), In contrast, collaborative dialogues are easy to collect as natural human conversations, and are also challenging enough given the large number of scenarios and diverse conversation phenomena.", 
        "195": "There are some interesting strategic dialogue datasets\u2014settlers of Catan (Afantenos et al., 2012) (2K turns) and the cards corpus (Potts, 2012) (1.3K dialogues), as well as work on dialogue strategies (Keizer et al., 2017; Vogel et al., 2013), though no full dialogue system has been built for these datasets.", 
        "196": "Most task-oriented dialogue systems follow the POMDP-based approach (Williams and Young, 2007; Young et al., 2013).", 
        "197": "Despite their success (Wen et al., 2017; Dhingra et al., 2017; Su et al., 2016), the requirement for handcrafted slots limits their scalability to new domains and burdens data collection with extra state labeling.", 
        "198": "To go past this limit, Bordes and Weston (2017) proposed a Memory-Networks-based approach without domain-specific features.", 
        "199": "However, the memory is unstructured and interfacing with KBs relies on API calls, whereas our model embeds both the dialogue history and the KB structurally.", 
        "200": "Williams et al.", 
        "201": "(2017) use an LSTM to automatically infer the dialogue state, but as they focus on dialogue control rather than the full problem, the response is modeled as a templated action, which restricts the generation of richer utterances.", 
        "202": "Our network ar-\nchitecture is most similar to EntNet (Henaff et al., 2017), where memories are also updated by input sentences recurrently.", 
        "203": "The main difference is that our model allows information to be propagated between structured entities, which is shown to be crucial in our setting (Section 4.3).", 
        "204": "Our work is also related to language generation conditioned on knowledge bases (Mei et al., 2016; Kiddon et al., 2016).", 
        "205": "One challenge here is to avoid generating false or contradicting statements, which is currently a weakness of neural models.", 
        "206": "Our model is mostly accurate when generating facts and answering existence questions about a single entity, but will need a more advanced attention mechanism for generating utterances involving multiple entities, e.g., attending to items or attributes first, then selecting entities; generating high-level concepts before composing them to natural tokens (Serban et al., 2017a).", 
        "207": "In conclusion, we believe the symmetric collaborative dialogue setting and our dataset pro-\nvide unique opportunities at the interface of traditional task-oriented dialogue and open-domain chat.", 
        "208": "We also offered DynoNet as a promising means for open-ended dialogue state representation.", 
        "209": "Our dataset facilitates the study of pragmatics and human strategies in dialogue\u2014a good stepping stone towards learning more complex dialogues such as negotiation.", 
        "210": "Acknowledgments.", 
        "211": "This work is supported by DARPA Communicating with Computers (CwC) program under ARO prime contract no.", 
        "212": "W911NF15-1-0462.", 
        "213": "Mike Kayser worked on an early version of the project while he was at Stanford.", 
        "214": "We also thank members of the Stanford NLP group for insightful discussions.", 
        "215": "Reproducibility.", 
        "216": "All code, data, and experiments for this paper are available on the CodaLab platform: https: //worksheets.codalab.org/worksheets/ 0xc757f29f5c794e5eb7bfa8ca9c945573."
    }, 
    "document_id": "P17-1162.pdf.json"
}
