{
    "abstract_sentences": {
        "1": "In this work, we present a minimal neural model for constituency parsing based on independent scoring of labels and spans.", 
        "2": "We show that this model is not only compatible with classical dynamic programming techniques, but also admits a novel greedy top-down inference algorithm based on recursive partitioning of the input.", 
        "3": "We demonstrate empirically that both prediction schemes are competitive with recent work, and when combined with basic extensions to the scoring model are capable of achieving state-of-the-art single-model performance on the Penn Treebank (91.79 F1) and strong performance on the French Treebank (82.23 F1)."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 818\u2013827 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1076  1 Introduction  This paper presents a minimal but surprisingly effective span-based neural model for constituency parsing.", 
        "2": "Recent years have seen a great deal of interest in parsing architectures that make use of recurrent neural network (RNN) representations of input sentences (Vinyals et al., 2015).", 
        "3": "Despite evidence that linear RNN decoders are implicitly able to respect some nontrivial well-formedness constraints on structured outputs (Graves, 2013), researchers have consistently found that the best performance is achieved by systems that explicitly require the decoder to generate well-formed tree structures (Chen and Manning, 2014).", 
        "4": "There are two general approaches to ensuring this structural consistency.", 
        "5": "The most common is to encode the output as a sequence of operations within a transition system which constructs trees incrementally.", 
        "6": "This transforms the parsing problem back into a sequence-to-sequence problem, while making it easy to force the decoder to take only actions guaranteed to produce well-formed\noutputs.", 
        "7": "However, transition-based models do not admit fast dynamic programs and require careful feature engineering to support exact search-based inference (Thang et al., 2015).", 
        "8": "Moreover, models with recurrent state require complex training procedures to benefit from anything other than greedy decoding (Wiseman and Rush, 2016).", 
        "9": "An alternative line of work focuses on chart parsers, which use log-linear or neural scoring potentials to parameterize a tree-structured dynamic program for maximization or marginalization (Finkel et al., 2008; Durrett and Klein, 2015).", 
        "10": "These models enjoy a number of appealing formal properties, including support for exact inference and structured loss functions.", 
        "11": "However, previous chart-based approaches have required considerable scaffolding beyond a simple well-formedness potential, e.g.", 
        "12": "pre-specification of a complete context-free grammar for generating output structures and initial pruning of the output space with a weaker model (Hall et al., 2014).", 
        "13": "Additionally, we are unaware of any recent chartbased models that achieve results competitive with the best transition-based models.", 
        "14": "In this work, we present an extremely simple chart-based neural parser based on independent scoring of labels and spans, and show how this model can be adapted to support a greedy topdown decoding procedure.", 
        "15": "Our goal is to preserve the basic algorithmic properties of span-oriented (rather than transition-oriented) parse representations, while exploring the extent to which neural representational machinery can replace the additional structure required by existing chart parsers.", 
        "16": "On the Penn Treebank, our approach outperforms a number of recent models for chart-based and transition-based parsing\u2014including the state-ofthe-art models of Cross and Huang (2016) and Liu and Zhang (2016)\u2014achieving an F1 score of 91.79.", 
        "17": "We additionally obtain a strong F1 score of 82.23 on the French Treebank.", 
        "18": "818  2 Model  A constituency tree can be regarded as a collection of labeled spans over a sentence.", 
        "19": "Taking this view as a guiding principle, we propose a model with two components, one which assigns scores to span labels and one which assigns scores directly to span existence.", 
        "20": "The former is used to determine the labeling of the output, and the latter provides its structure.", 
        "21": "At the core of both of these components is the issue of span representation.", 
        "22": "Given that a span\u2019s correct label and its quality as a constituent depend heavily on the context in which it appears, we naturally turn to recurrent neural networks as a starting point, since they have previously been shown to capture contextual information suitable for use in a variety of natural language applications (Bahdanau et al., 2014; Wang et al., 2015)\nIn particular, we run a bidirectional LSTM over the input to obtain context-sensitive forward and backward encodings for each position i, denoted by fi and bi, respectively.", 
        "23": "Our representation of the span (i, j) is then the concatenatation the vector differences fj \u2212 fi and bi \u2212 bj .", 
        "24": "This corresponds to a bidirectional version of the LSTMMinus features first proposed by Wang and Chang (2016).", 
        "25": "On top of this base, our label and span scoring functions are implemented as one-layer feedforward networks, taking as input the concatenated span difference and producing as output either a vector of label scores or a single span score.", 
        "26": "More formally, letting sij denote the vector representation of span (i, j), we define\nslabels(i, j) = V`g(W`sij + b`),\nsspan(i, j) = v > s g(Wssij + bs),\nwhere g denotes an elementwise nonlinearity.", 
        "27": "For notational convenience, we also let the score of an individual label ` be denoted by\nslabel(i, j, `) = [slabels(i, j)]`,\nwhere the right-hand side is the corresponding element of the label score vector.", 
        "28": "One potential issue is the existence of unary chains, corresponding to nested labeled spans with the same endpoints.", 
        "29": "We take the common approach of treating these as additional atomic labels alongside all elementary nonterminals.", 
        "30": "To accommodate n-ary trees, our inventory additionally includes a special empty label \u2205 used for spans that\nare not themselves full constituents but arise during the course of implicit binarization.", 
        "31": "Our model shares several features in common with that of Cross and Huang (2016).", 
        "32": "In particular, our representation of spans and the form of our label scoring function were directly inspired by their work, as were our handling of unary chains and our use of an empty label.", 
        "33": "However, our approach differs in its treatment of structural decisions, and consequently, the inference algorithms we describe below diverge significantly from their transition-based framework.", 
        "34": "3 Chart Parsing  Our basic model is compatible with traditional chart-based dynamic programming.", 
        "35": "Representing a constituency tree T by its labeled spans,\nT := {(`t, (it, jt)) : t = 1, .", 
        "36": ".", 
        "37": ".", 
        "38": ", |T |},\nwe define the score of a tree to be the sum of its constituent label and span scores,\nstree(T ) = \u2211\n(`,(i,j))\u2208T [slabel(i, j, `) + sspan(i, j)] .", 
        "39": "To find the tree with the highest score for a given sentence, we use a modified CKY recursion.", 
        "40": "As with classical chart parsing, the running time of our procedure is O(n3) for a sentence of length n.  3.1 Dynamic Program for Inference  The base case is a span (i, i + 1) consisting of a single word.", 
        "41": "Since every valid tree must include all singleton spans, possibly with an empty label, we need not consider the span score in this case and perform only a single maximization over the choice of label:\nsbest(i, i + 1) = max ` [slabel(i, i + 1, `)] .", 
        "42": "For a general span (i, j), we define the score of the split (i, k, j) as the sum of its subspan scores,\nssplit(i, k, j) = sspan(i, k) + sspan(k, j).", 
        "43": "(1)\nFor convenience, we also define an augmented split score incorporating the scores of the corresponding subtrees,\ns\u0303split(i, k, j) = ssplit(i, k, j)\n+ sbest(i, k) + sbest(k, j).", 
        "44": "Using these quantities, we can then write the general joint label and split decision as\nsbest(i, j) = max `,k [slabel(i, j, `) + s\u0303split(i, k, j)] .", 
        "45": "(2)\nBecause our model assigns independent scores to labels and spans, this maximization decomposes into two disjoint subproblems, greatly reducing the size of the state space:\nsbest(i, j) = max ` [slabel(i, j, `)]\n+ max k [s\u0303split(i, k, j)] .", 
        "46": "We also note that the span scores sspan(i, j) for each span (i, j) in the sentence can be computed once at the beginning of the procedure and shared across different subproblems with common left or right endpoints, allowing for a quadratic rather than cubic number of span score computations.", 
        "47": "3.2 Margin Training  Training the model under this inference scheme is accomplished using a margin-based approach.", 
        "48": "When presented with an example sentence and its corresponding parse tree T \u2217, we compute the best prediction under the current model using the above dynamic program,\nT\u0302 = argmax T [stree(T )] .", 
        "49": "If T\u0302 = T \u2217, then our prediction was correct and no changes need to be made.", 
        "50": "Otherwise, we incur a hinge penalty of the form\nmax ( 0, 1\u2212 stree(T \u2217) + stree(T\u0302 ) )\nto encourage the model to keep a margin of at least 1 between the gold tree and the best alternative.", 
        "51": "The loss to be minimized is then the sum of penalties across all training examples.", 
        "52": "Prior work has found that it can be beneficial in a variety of applications to incorporate a structured loss function into this margin objective, replacing the hinge penalty above with one of the form\nmax ( 0, \u2206(T\u0302 , T \u2217)\u2212 stree(T \u2217) + stree(T\u0302 ) )\nfor a loss function \u2206 that measures the similarity between the prediction T\u0302 and the reference T \u2217.", 
        "53": "Here we take \u2206 to be a Hamming loss on labeled spans.", 
        "54": "To incorporate this loss into the training objective, we modify the dynamic program of\nSection 3.1 to support loss-augmented decoding (Taskar et al., 2005).", 
        "55": "Since the label decisions are isolated from the structural decisions, it suffices to replace every occurrence of the label scoring function slabel(i, j, `) by\nslabel(i, j, `) + 1(` 6= `\u2217ij),\nwhere `\u2217ij is the label of span (i, j) in the gold tree T \u2217.", 
        "56": "This has the effect of requiring larger margins between the gold tree and predictions that contain more mistakes, offering a greater degree of robustness and better generalization.", 
        "57": "4 Top-Down Parsing  While we have so far motivated our model from the perspective of classical chart parsing, it also allows for a novel inference algorithm in which trees are constructed greedily from the top down.", 
        "58": "At a high level, given a span, we independently assign it a label and pick a split point, then repeat this process for the left and right subspans; the recursion bottoms out with length-one spans that can no longer be split.", 
        "59": "Figure 1 gives an illustration of the process, which we describe in more detail below.", 
        "60": "The base case is again a singleton span (i, i+1), and follows the same form as the base case for the chart parser.", 
        "61": "In particular, we select the label \u0302\u0300that satisfies\n\u0302\u0300= argmax ` [slabel(i, i + 1, `)] ,\nomitting span scores from consideration since singleton spans cannot be split.", 
        "62": "To construct a tree over a general span (i, j), we aim to solve the maximization problem\n(\u0302\u0300, k\u0302) = argmax `,k [slabel(i, j, `) + ssplit(i, k, j)] ,\nwhere ssplit(i, k, j) is defined as in Equation (1).", 
        "63": "The independence of our label and span scoring functions again yields the decomposed form\n\u0302\u0300= argmax ` [slabel(i, j, `)] ,\nk\u0302 = argmax k\n[ssplit(i, k, j)] , (3)\nleading to a significant reduction in the size of the state space.", 
        "64": "To generate a tree for the whole sentence, we call this procedure on the full sentence span (0, n) and return the result.", 
        "65": "As there are O(n) spans each\nrequiring one label evaluation and at most n \u2212 1 split point evaluations, the running time of the procedure is O(n2).", 
        "66": "The algorithm outlined here bears a strong resemblance to the chart parsing dynamic program discussed in Section 3, but differs in one key aspect.", 
        "67": "When performing inference from the bottom up, we have already computed the scores of all of the subtrees below the current span, and we can take this knowledge into consideration when selecting a split point.", 
        "68": "In contrast, when producing a tree from the top down, we can only select a split point based on top-level evaluations of span quality, without knowing anything about the subtrees that will be generated below them.", 
        "69": "This difference is manifested in the augmented split score s\u0303split used in the definition of sbest in Equation (2), where the scores of the subtrees associated with a split point are included in the chart recursion but necessarily excluded from the top-down recursion.", 
        "70": "While this apparent deficiency may be a cause for concern, we demonstrate the surprising empirical result in Section 6 that there is no loss in per-\nformance when moving from the globally-optimal chart parser to the greedy top-down procedure.", 
        "71": "4.1 Margin Training  As with the chart parsing formulation, we also use a margin-based method for learning under the topdown model.", 
        "72": "However, rather than requiring separation between the scores of full trees, we instead enforce a local margin at every decision point.", 
        "73": "For a span (i, j) occurring in the gold tree, let `\u2217 and k\u2217 represent the correct label and split point, and let \u0302\u0300and k\u0302 be the predictions made by computing the maximizations in Equation (3).", 
        "74": "If \u0302\u0300 6= `\u2217, meaning the prediction is incorrect, we incur a hinge penalty of the form\nmax ( 0, 1\u2212 slabel(i, j, `\u2217) + slabel(i, j, \u0302\u0300) ) .", 
        "75": "Similarly, if k\u0302 6= k\u2217, we incur a hinge penalty of the form\nmax ( 0, 1\u2212 ssplit(i, k\u2217, j) + ssplit(i, k\u0302, j) ) .", 
        "76": "To obtain the loss for a given training example, we trace out the actions corresponding to the gold tree and accumulate the above penalties over all decision points.", 
        "77": "As before, the total loss to be minimized is the sum of losses across all training examples.", 
        "78": "Loss augmentation is also beneficial for the local decisions made by the top-down model, and can be implemented in a manner akin to the one discussed in Section 3.2.", 
        "79": "4.2 Training with Exploration  The hinge penalties given above are only defined for spans (i, j) that appear in the example tree.", 
        "80": "The model must therefore be constrained at training time to follow decisions that exactly reproduce the gold tree, since supervision cannot be provided otherwise.", 
        "81": "As a result, the model is never exposed to its mistakes, which can lead to a lack of calibration and poor performance at test time.", 
        "82": "To circumvent this issue, a dynamic oracle can be defined to inform the model about correct behavior even after it has deviated from the gold tree.", 
        "83": "Cross and Huang (2016) propose such an oracle for a related transition-based parsing system, and prove its optimality for the F1 metric on labeled spans.", 
        "84": "We adapt their result here to obtain a dynamic oracle for the present model with similar guarantees.", 
        "85": "The oracle for labeling decisions carries over without modification: the correct label for a span is the label assigned to that span if it is part of the gold tree, or the empty label \u2205 otherwise.", 
        "86": "For split point decisions, the oracle can be broken down into two cases.", 
        "87": "If a span (i, j) appears as a constituent in the gold tree T , we let b(i, j) denote the collection of its interior boundary points.", 
        "88": "For example, if the constituent over (1, 7) has children spanning (1, 3), (3, 6), and (6, 7), then we would have the two interior boundary points, b(1, 7) = {3, 6}.", 
        "89": "The oracle for a span appearing in the gold tree is then precisely the output of this function.", 
        "90": "Otherwise, for spans (i, j) not corresponding to gold constituents, we must instead identify the smallest enclosing gold constituent:\n(i\u2217, j\u2217) = min{(i\u2032, j\u2032) \u2208 T : i\u2032 \u2264 i < j \u2264 j\u2032}, where the minimum is taken with respect to the partial ordering induced by span length.", 
        "91": "The output of the oracle is then the set of interior boundary points of this enclosing span that also lie inside the original, {k \u2208 b(i\u2217, j\u2217) : i < k < j}.", 
        "92": "The proof of correctness is similar to the proof in Cross and Huang (2016); we refer to the Dynamic Oracle section in their paper for a more detailed discussion.", 
        "93": "As presented, the dynamic oracle for split point decisions returns a collection of one or more splits rather than a single correct answer.", 
        "94": "Any of these is a valid choice, with different splits corresponding to different binarizations of the original n-ary tree.", 
        "95": "We choose to use the leftmost split point for consistency in our implementation, but remark that the oracle split with the highest score could also be chosen at training time to allow for additional flexibility.", 
        "96": "Having defined the dynamic oracle for our system, we note that training with exploration can be implemented by a single modification to the procedure described in Section 4.1.", 
        "97": "Local penalties are accumulated as before, but instead of tracing out the decisions required to produce the gold tree, we instead follow the decisions predicted by the model.", 
        "98": "In this way, supervision is provided at states within the prediction procedure that are more likely to arise at test time when greedy inference is performed.", 
        "99": "5 Scoring and Loss Alternatives  The model presented in Section 2 is designed to be as simple as possible.", 
        "100": "However, there are many variations of the label and span scoring functions that could be explored; we discuss some of the options here.", 
        "101": "5.1 Top-Middle-Bottom Label Scoring  Our basic model treats the empty label, elementary nonterminals, and unary chains each as atomic units, obscuring similarities between unary chains and their component nonterminals or between different unary chains with common prefixes or suffixes.", 
        "102": "To address this lack of structure, we consider an alternative scoring scheme in which labels are predicted in three parts: a top nonterminal, a middle unary chain, and a bottom nonterminal (each of which is possibly empty).1 This not only allows for parameter sharing across labels with common subcomponents, but also has the added benefit of allowing the model to produce novel unary chains at test time.", 
        "103": "1In more detail, \u2205 decomposes as (\u2205, \u2205, \u2205), X decomposes as (X , \u2205, \u2205), X\u2013Y decomposes as (X , \u2205, Y ), and X\u2013Z1\u2013 \u00b7 \u00b7 \u00b7 \u2013Zk\u2013Y decomposes as (X , Z1\u2013 \u00b7 \u00b7 \u00b7 \u2013Zk, Y ).", 
        "104": "More precisely, we introduce the decomposition\nslabel(i, j, (`t, `m, `b)) =\nstop(i, j, `t) + smiddle(i, j, `m) + sbottom(i, j, `b),\nwhere stop, smiddle, and sbottom are independent one-layer feedforward networks of the same form as slabel that output vectors of scores for all label tops, label middle chains, and label bottoms encountered in the training corpus, respectively.", 
        "105": "The best label for a span (i, j) is then computed by solving the maximization problem\nmax `t,`m,`b [slabel(i, j, (`t, `m, `b))] ,\nwhich decomposes into three independent subproblems corresponding to the three label components.", 
        "106": "The final label is obtained by concatenating `t, `m, and `b, with empty components being omitted from the concatenation.", 
        "107": "5.2 Left and Right Span Scoring  The basic model uses the same span scoring function sspan to assign a score to the left and right subspans of a given span.", 
        "108": "One simple extension is to replace this by a pair of distinct left and right feedforward networks of the same form, giving the decomposition\nssplit(i, k, j) = sleft(i, k) + sright(k, j).", 
        "109": "5.3 Span Concatenation Scoring  Since span scores are only used to score splits in our model, we also consider directly scoring a split by feeding the concatenation of the span representations of the left and right subspans through a single feedforward network, giving\nssplit(i, k, j) = v > s g (Ws[sik; skj ] + bs) .", 
        "110": "This is similar to the structural scoring function used by Cross and Huang (2016), although whereas they additionally include features for the outside spans (0, i) and (j, n) in their concatenation, we omit these from our implementation, finding that they do not improve performance.", 
        "111": "5.4 Deep Biaffine Span Scoring  Inspired by the success of deep biaffine scoring in recent work by Dozat and Manning (2016) for dependency parsing, we also consider a split scoring function of a similar form for our model.", 
        "112": "Specifically, we let hik = fleft(sik) and hkj =\nfright(skj) be deep left and right span representations obtained by passing the child vectors through corresponding left and right feedforward networks.", 
        "113": "We then define the biaffine split scoring function\nssplit(i, k, j) = h > ikWshkj + v > lefthik + v > righthkj ,\nwhich consists of the sum of a bilinear form between the two hidden representations together with two inner products.", 
        "114": "5.5 Structured Label Loss  The three-way label scoring scheme described in Section 5.1 offers one path towards the incorporation of label structure into the model.", 
        "115": "We additionally consider a structured Hamming loss on labels.", 
        "116": "More specifically, given two labels `1 and `2 consisting of zero or more nonterminals, we define the loss as |`1 \\ `2|+ |`2 \\ `1|, treating each label as a multiset of nonterminals.", 
        "117": "This structured loss can be incorporated into the training process using the methods described in Sections 3.2 and 4.1.", 
        "118": "6 Experiments  We first describe the general setup used for our experiments.", 
        "119": "We use the Penn Treebank (Marcus et al., 1993) for our English experiments, with standard splits of sections 2-21 for training, section 22 for development, and section 23 for testing.", 
        "120": "We use the French Treebank from the SPMRL 2014 shared task (Seddah et al., 2014) with its provided splits for our French experiments.", 
        "121": "No token preprocessing is performed, and only a single <UNK> token is used for unknown words at test time.", 
        "122": "The inputs to our system are concatenations of 100-dimensional word embeddings and 50-dimensional part-of-speech embeddings.", 
        "123": "In the case of the French Treebank, we also include 50-dimensional embeddings of each morphological tag.", 
        "124": "We use automatically predicted tags for training and testing, obtaining predicted part-ofspeech tags for the Penn Treebank using the Stanford tagger (Toutanova et al., 2003) with 10-way jackknifing, and using the provided predicted partof-speech and morphological tags for the French Treebank.", 
        "125": "Words are replaced by <UNK> with probability 1/(1+freq(w)) during training, where freq(w) is the frequency of w in the training data.", 
        "126": "We use a two-layer bidirectional LSTM for our base span features.", 
        "127": "Dropout with a ratio selected from {0.2, 0.3, 0.4} is applied to all non-recurrent\nconnections of the LSTM, including its inputs and outputs.", 
        "128": "We tie the hidden dimension of the LSTM and all feedforward networks, selecting a size from {150, 200, 250}.", 
        "129": "All parameters (including word and tag embeddings) are randomly initialized using Glorot initialization (Glorot and Bengio, 2010), and are tuned on development set performance.", 
        "130": "We use the Adam optimizer (Kingma and Ba, 2014) with its default settings for optimization, with a batch size of 10.", 
        "131": "Our system is implemented in C++ using the DyNet neural network library (Neubig et al., 2017).", 
        "132": "We begin by training the minimal version of our proposed chart and top-down parsers on the Penn Treebank.", 
        "133": "Out of the box, we obtain test F1 scores of 91.69 for the chart parser and 91.58 for the topdown parser.", 
        "134": "The higher of these matches the recent state-of-the-art score of 91.7 reported by Liu and Zhang (2016), demonstrating that our simple neural parsing system is already capable of achieving strong results.", 
        "135": "Building on this, we explore the effects of different split scoring functions when using either the basic 0-1 label loss or the structured label loss discussed in Section 5.5.", 
        "136": "Our results are presented in Tables 1a and 1b.", 
        "137": "We observe that regardless of the label loss, the minimal and deep biaffine split scoring schemes perform a notch below the left-right and concatenation scoring schemes.", 
        "138": "That the minimal scoring scheme performs worse than the left-right scheme is unsurprising, since the latter is a strict generalization of the former.", 
        "139": "It is evident, however,\nthat joint scoring of left and right subspans is not required for strong results\u2014in fact, the left-right scheme which scores child subspans in isolation slightly outperforms the concatenation scheme in all but one case, and is stronger than the deep biaffine scoring function across the board.", 
        "140": "Comparing results across the choice of label loss, however, we find that fewer trends are apparent.", 
        "141": "The scores obtained by training with a 0-1 loss are all within 0.1 of those obtained using a structured Hamming loss, being slightly higher in four out of eight cases and slightly lower in the other half.", 
        "142": "This leads us to conclude that the more elementary approach is sufficient when selecting atomic labels from a fixed inventory.", 
        "143": "We also perform the same set of experiments under the setting where the top-middle-bottom label scoring function described in Section 5.1 is used in place of an atomic label scoring function.", 
        "144": "These results are shown in Tables 1c and 1d.", 
        "145": "A priori, we might expect that exposing additional structure would allow the model to make better predictions, but on the whole we find that the scores in this set of experiments are worse than those in the previous set.", 
        "146": "Trends similar to before hold across the different choices of scoring functions, though in this case the minimal setting has scores closer to those of the left-right setting, even exceeding its performance in the case of a chart parser with a 0-1 label loss.", 
        "147": "Our final test results are given in Table 2, along with the results of other recent single-model parsers trained without external parse data.", 
        "148": "We\nachieve a new state-of-the-art F1 score of 91.79 with our best model.", 
        "149": "Interestingly, we observe that our parsers have a noticeably higher gap between precision and recall than do other top parsers, likely owing to the structured label loss which penalizes mismatching nonterminals more heavily than it does a nonterminal and empty label mismatch.", 
        "150": "In addition, there is little difference between the best top-down model and the best chart model, indicating that global normalization is not required to achieve strong results.", 
        "151": "Processing one sentence at a time on a c4.4xlarge Amazon EC2 instance, our best chart and top-down parsers operate at speeds of 20.3 sentences per second and 75.5 sentences per second, respectively, as measured on the test set.", 
        "152": "We additionally train parsers on the French Treebank using the same settings from our English experiments, selecting the best model of each type based on development performance.", 
        "153": "We list our test results along with those of several other recent papers in Table 3.", 
        "154": "Although we fall short of the scores obtained by Cross and Huang (2016), we achieve competitive performance relative to the neural CRF parser of Durrett and Klein (2015).", 
        "155": "7 Related Work  Many early successful approaches to constituency parsing focused on rich modeling of correlations in the output space, typically by engineering proabilistic context-free grammars with state spaces enriched to capture long-distance dependencies and lexical phenomena (Collins, 2003; Klein and Manning, 2003; Petrov and Klein, 2007).", 
        "156": "By contrast, the approach we have described here continues a recent line of work on direct modeling of correlations in the input space, by using rich feature representations to parameterize local potentials that interact with a comparatively unconstrained structured decoder.", 
        "157": "As noted in the introduction, this class of feature-based tree scoring functions can be implemented with either a linear transition system (Chen and Manning, 2014) or a global decoder (Finkel et al., 2008).", 
        "158": "Kiperwasser and Goldberg (2016) describe an approach closely related to ours but targeted at dependency formalisms, and which easily accommodates both sparse log-linear scoring models (Hall et al., 2014) and deep neural potentials (Henderson, 2004; Ballesteros et al., 2016).", 
        "159": "The best-performing constituency parsers in the last two years have largely been transition-based rather than global; examples include the models of Dyer et al.", 
        "160": "(2016), Cross and Huang (2016) and Liu and Zhang (2016).", 
        "161": "The present work takes many of the insights developed in these models (e.g.", 
        "162": "the recurrent representation of spans (Kiperwasser and Goldberg, 2016), and the use of a dynamic oracle and exploration policy during training (Goldberg and Nivre, 2013)) and extends these insights to span-oriented models, which support a wider range of decoding procedures.", 
        "163": "Our approach differs from other recent chart-based neural models (e.g.", 
        "164": "Durrett and Klein (2015)) in the use of a recurrent input representation, structured loss function, and comparatively simple parameterization of the scoring function.", 
        "165": "In addition to the globally optimal decoding procedures for which these models were designed, and in contrast to the left-to-right decoder typically employed by transition-based models, our model admits an additional greedy top-to-bottom inference procedure.", 
        "166": "8 Conclusion  We have presented a minimal span-oriented parser that uses a recurrent input representation to score\ntrees with a sum of independent potentials on their constituent spans and labels.", 
        "167": "Our model supports both exact chart-based decoding and a novel top-down inference procedure.", 
        "168": "Both approaches achieve state-of-the-art performance on the Penn Treebank, and our best model achieves competitive performance on the French Treebank.", 
        "169": "Our experiments show that many of the key insights from recent neural transition-based approaches to parsing can be easily ported to the chart parsing setting, resulting in a pair of extremely simple models that nonetheless achieve excellent performance.", 
        "170": "Acknowledgments  We would like to thank Nick Altieri and the anonymous reviewers for their valuable comments and suggestions.", 
        "171": "MS is supported by an NSF Graduate Research Fellowship.", 
        "172": "JA is supported by a Facebook graduate fellowship and a Berkeley AI / Huawei fellowship."
    }, 
    "document_id": "P17-1076.pdf.json"
}
