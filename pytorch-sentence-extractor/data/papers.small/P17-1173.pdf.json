{
    "abstract_sentences": {
        "1": "Though feature extraction is a necessary first step in statistical NLP, it is often seen as a mere preprocessing step.", 
        "2": "Yet, it can dominate computation time, both during training, and especially at deployment.", 
        "3": "In this paper, we formalize feature extraction from an algebraic perspective.", 
        "4": "Our formalization allows us to define a message passing algorithm that can restructure feature templates to be more computationally efficient.", 
        "5": "We show via experiments on text chunking and relation extraction that this restructuring does indeed speed up feature extraction in practice by reducing redundant computation."
    }, 
    "body_sentences": {
        "1": "  Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1891\u20131900 Vancouver, Canada, July 30 - August 4, 2017. c\u00a92017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1173  1 Introduction  Often, the first step in building statistical NLP models involves feature extraction.", 
        "2": "It is well understood that the right choice of features can substantially improve classifier performance.", 
        "3": "However, from the computational point of view, the process of feature extraction is typically treated, at best as the preprocessing step of caching featurized inputs over entire datasets, and at worst, as \u2018somebody else\u2019s problem\u2019.", 
        "4": "While such approaches work for training, when trained models are deployed, the computational cost of feature extraction cannot be ignored.", 
        "5": "In this paper, we present the first (to our knowledge) algebraic characterization of the process of feature extraction.", 
        "6": "We formalize feature extractors as arbitrary functions that map objects (words, sentences, etc) to a vector space and show that this set forms a commutative semiring with respect to feature addition and feature conjunction.", 
        "7": "An immediate consequence of the semiring characterization is a computational one.", 
        "8": "Every\nsemiring admits the Generalized Distributive Law (GDL) Algorithm (Aji and McEliece, 2000) that exploits the distributive property to provide computational speedups.", 
        "9": "Perhaps the most common manifestation of this algorithm in NLP is in the form of inference algorithms for factor graphs and Bayesian networks like the max-product, maxsum and sum-product algorithms (e.g.", 
        "10": "Goodman, 1999; Kschischang et al., 2001).", 
        "11": "When applied to feature extractors, the GDL algorithm can refactor a feature extractor into a faster one by reducing redundant computation.", 
        "12": "In this paper, we propose a junction tree construction to allow such refactoring.", 
        "13": "Since the refactoring is done at the feature template level, the actual computational savings grow as classifiers encounter more examples.", 
        "14": "We demonstrate the practical utility of our approach by factorizing existing feature sets for text chunking and relation extraction.", 
        "15": "We show that, by reducing the number of operations performed, we can obtain significant savings in the time taken to extract features.", 
        "16": "To summarize, the main contribution of this paper is the recognition that feature extractors form a commutative semiring over addition and conjunction.", 
        "17": "We demonstrate a practical consequence of this characterization in the form of a mechanism for automatically refactoring any feature extractor into a faster one.", 
        "18": "Finally, we show the empirical usefulness of our approach on relation extraction and text chunking tasks.", 
        "19": "2 Problem Definition  Before formal definitions, let us first see a running example.", 
        "20": "2.1 Motivating Example  Consider the frequently used unigram, bigram and trigram features.", 
        "21": "Each of these is a template that specifies a feature representation for a word.", 
        "22": "In\n1891\nfact, the bigram and trigram templates themselves are compositional by definition.", 
        "23": "A bigram is simply the conjunction of a word w and previous word, which we will denote as w-1; i.e., bigram = w-1&w.", 
        "24": "Similarity, a trigram is the conjunction of w-2 and bigram.", 
        "25": "These templates are a function that operate on inputs.", 
        "26": "Given a sentence, say John ate alone, and a target word, say alone, they will produce indicators for the strings w=alone, w-1=ate&w=alone and w-2=John&w-1=ate&w=alone respectively.", 
        "27": "Equivalently, each template maps an input to a vector.", 
        "28": "Here, the three vectors will be basis vectors associated with the feature strings.", 
        "29": "Observe that the function that extracts the target word (i.e., w) has to be executed in all three feature templates.", 
        "30": "Similarly, w-1 has to be extracted to compute both the bigrams and the trigrams.", 
        "31": "Can we optimize feature computation by automatically detecting such repetitions?", 
        "32": "2.2 Definitions and Preliminaries  Let X be a set of inputs to a classification problem at hand; e.g., X could be words, sentences, etc.", 
        "33": "Let V be a possibly infinite dimensional vector space that represents the feature space.", 
        "34": "Feature extractors are functions that map the input space X to the feature space V to produce feature vectors for inputs.", 
        "35": "Let F represent the set of feature functions, defined as the set {f : X \u2192 V}.", 
        "36": "We will use the typewriter font to denote feature functions like w and bigram.", 
        "37": "To round up the definitions, we will name two special feature extractors inF .", 
        "38": "The feature extractor 0 maps all inputs to the zero vector.", 
        "39": "The feature extractor 1 maps all inputs to a bias feature vector.", 
        "40": "Without loss of generality, we will designate the basis vector i0 \u2208 V as the bias feature vector.", 
        "41": "In this paper, we are concerned about two generally well understood operators on feature functions \u2013 addition and conjunction.", 
        "42": "However, let us see formal definitions for completeness.", 
        "43": "Feature Addition.", 
        "44": "Given two feature extractors f1, f2 \u2208 F , feature addition (denoted by +) produces a feature extractor f1 + f2 that adds up the images of f1 and f2.", 
        "45": "That is, for any example x \u2208 X , we have\n(f1 + f2) (x) = f1 (x) + f2 (x) (1)\nFor example, the feature extractor w + w-1 will map the word alone to a vector that is one for the\nbasis elements w=alone and w-1=went.", 
        "46": "This vector is the sum of the indicator vectors produced by the two operands w and w-1.", 
        "47": "Feature Conjunction.", 
        "48": "Given two feature extractors f1, f2 \u2208 F , their conjunction (denoted by &) can be interpreted as an extension of Boolean conjunction.", 
        "49": "Indicator features like bigram are predicates for certain observations.", 
        "50": "Conjoining indicator features for two predicates is equivalent to an indicator feature for the Boolean conjunction of the predicates.", 
        "51": "More generally, with feature extractors that produce real valued vectors, the conjunction will produce their tensor product.", 
        "52": "The equivalence of feature conjunctions to tensor products has been explored and exploited in recent literature for various NLP tasks (Lei et al., 2014; Srikumar and Manning, 2014; Gormley et al., 2015; Lei et al., 2015).", 
        "53": "We can further generalize this with an additional observation that is crucial for the rest of this paper.", 
        "54": "We argue that the conjunction operator produces symmetric tensor products rather than general tensor products.", 
        "55": "To see why, consider the bigram example.", 
        "56": "Though we defined the bigram feature as the conjunction of w-1 and w, their ordering is irrelevant from classification perspective \u2013 the eventual goal is to associate weights with this combination of features.", 
        "57": "This observation allows us to formally define the conjunction operator as:\n(f1&f2) (x) = vec (f1 (x) f2 (x)) (2)\nHere, vec (\u00b7) stands for vectorize, which simply converts the resulting tensor into a vector and denotes the symmetric tensor product, introduced by Ryan (1980, Proposition 1.1).", 
        "58": "A symmetric tensor product is defined to be the average of the tensor products of all possible permutations of the operands, and thus, unlike a simple tensor product, is invariant to permutation of is operands.", 
        "59": "Informally, if we think of a tensor as a mapping from an ordered sequence of keys to real numbers, then, symmetric tensor product can be thought of as a mapping from a set of keys to numbers.", 
        "60": "3 An Algebra for Feature Extraction  In this section, we will see that the set of feature extractors F form a commutative semiring with respect to addition and conjunction.", 
        "61": "First, let us revisit the definition of a commutative semiring.", 
        "62": "Definition 1.", 
        "63": "A commutative semiring is an algebraic structure consisting of a set K and two bi-\nnary operations \u2295 and \u2297 (addition and multiplication respectively) such that: S1.", 
        "64": "(K,\u2295) is a commutative monoid: \u2295 is asso-\nciative and commutative, and the set K contains a unique additive identity 0 such that \u2200x \u2208 K, we have 0\u2295 x = x\u2295 0 = x. S2.", 
        "65": "(K,\u2297) is a commutative monoid: \u2297 is associative and commutative, and the set K contains a unique multiplicative identity 1 such that \u2200x \u2208 K, we have 1\u2297 x = x\u2297 1 = x. S3.", 
        "66": "Multiplication distributes over addition on both sides.", 
        "67": "That is, for any x, y, z \u2208 K, we have x \u2297 (y \u2295 z) = (x \u2297 y) \u2295 (x \u2297 z) and (x\u2295 y)\u2297 z = (x\u2297 z)\u2295 (y \u2297 z).", 
        "68": "S4.", 
        "69": "The additive identity is an annihilating element with respect to multiplication.", 
        "70": "That is, for any x \u2208 K, we have x\u2297 0 = 0 = 0\u2297 x.", 
        "71": "We refer the reader to Golan (2013) for a broadranging survey of semiring theory.", 
        "72": "We can now state and prove the main result of this paper.", 
        "73": "Theorem 1.", 
        "74": "LetX be any set and letF denote the set of feature extractors defined on the set.", 
        "75": "Then, (F ,+,&) is a commutative semiring.", 
        "76": "Proof.", 
        "77": "We will show that the properties of a commutative semiring hold for (F ,+,&) using the definitions of the operators from \u00a72.2.", 
        "78": "Let f1, f2 and f \u2208 F be feature extractors.", 
        "79": "S1.", 
        "80": "For any example x \u2208 X , we have\n(f1 + f2) (x) = f1 (x) + f2 (y).", 
        "81": "The right hand side denotes vector addition, which is associative and commutative.", 
        "82": "The 0 feature extractor is the additive identify because it produces the zero vector for any input.", 
        "83": "Thus, (F ,+) is a commutative monoid.", 
        "84": "S2.", 
        "85": "To show that the conjunction operator is associative over feature extractors, it suffices to observe that the tensor product (and hence the symmetric tensor product) is associative.", 
        "86": "Furthermore, the symmetric tensor product is commutative by definition, because it is invariant to permutation of its operands.", 
        "87": "Finally, the bias feature extractor, 1, that maps all inputs to the bias vector i0, is the multiplicative identity.", 
        "88": "To see this, consider the conjunction f&1, applied to an input x:\n(f&1) (x) = vec (f (x) 1 (x)) = vec (f (x) i0)\nThe product term within the vec (\u00b7) in the final expression is a symmetric tensor, defined by basis vectors that are sets of the form\n{i0, i0}, {i1, i0}, \u00b7 \u00b7 \u00b7 .", 
        "89": "Each basis {ij , i0} is associated with a feature value f (x)j .", 
        "90": "Thus, the vectorized form of this tensor will contain the same elements as f (x), perhaps mapped to different bases.", 
        "91": "The mapping from f (x) to the final vector is independent of the input x because the bias feature extractor is independent of x.", 
        "92": "Without loss of generality, we can fix this mapping to be the identity mapping, thereby rendering the final vectorized form equal to f (x).", 
        "93": "That is, f&1 = f. Thus, (F ,&) is a commutative monoid.", 
        "94": "S3.", 
        "95": "Since tensor products distribute over addition, we get the distributive property.", 
        "96": "S4.", 
        "97": "By definition, conjoining with the 0 feature extractor annihilates all feature functions because 0 maps all inputs to the zero vector.", 
        "98": "4 From Algebra to an Algorithm  The fact that feature extractors form a commutative semiring has a computational consequence.", 
        "99": "The generalized distributive law (GDL) algorithm (Aji and McEliece, 2000) exploits the properties of a commutative semiring to potentially reduce the computational effort for marginalizing sums of products.", 
        "100": "The GDL algorithm manifests itself as the Viterbi, Baum-Welch, Floyd-Warshall and belief propagation algorithms, and the Fast Fourier and Hadamard transforms.", 
        "101": "Each corresponds to a different commutative semiring and a specific associated marginalization problem.", 
        "102": "Here, we briefly describe the general marginalization problem from Aji and McEliece (2000) to introduce notation and also highlight the analogies to inference in factor graphs.", 
        "103": "Let x1, x2, \u00b7 \u00b7 \u00b7 , xn denote a collection of variables that can take values from finite sets A1, A2, \u00b7 \u00b7 \u00b7 , An respectively.", 
        "104": "Let boldface x denote the entire set of variables.", 
        "105": "These variables are akin to inference variables in factor graphs that may be assigned values or marginalized away.", 
        "106": "Let (K,\u2295,\u2297) denote a commutative semiring.", 
        "107": "Suppose \u03b1i is a function that maps a subset of the variables {xi1 , xi2 , \u00b7 \u00b7 \u00b7 } to the set K. The subset of variables that constitute the domain of \u03b1i is called the local domain of the corresponding local function.", 
        "108": "Local domains and local functions are analogous to factors and factor potentials in a factor graph.", 
        "109": "With a collection of local domains, each associated with a function \u03b1i, the \u201cmarginalize the\nproduct\u201d problem is that of computing: \u2211\nx\n\u220f\ni\n\u03b1i (xi1 , xi2 , \u00b7 \u00b7 \u00b7 ) (3)\nHere, the sum and product use the semiring operators.", 
        "110": "The summation is over all possible valid assignments of the variables x over the cross product of the setsA1, A2, \u00b7 \u00b7 \u00b7 , An.", 
        "111": "This problem generalizes the familiar max-product or sum-product settings.", 
        "112": "Indeed, the GDL algorithm is a generalization of the message passing (Pearl, 2014) for efficiently computing marginals.", 
        "113": "To make feature extraction efficient using the GDL algorithm, in the next section, we will define a marginalization problem in terms of the semiring operators by specifying the variables involved, the local domains and local functions.", 
        "114": "Instead of describing the algorithm in the general setting, we will instantiate it on the semiring at hand.", 
        "115": "5 Marginalizing Feature Extractors  First, let us see why we can expect any benefit from the GDL algorithm by revisiting our running example (unigrams, bigrams and trigrams), written below using the semiring operations:\nf = w+ (w-1&w) + (w-2&w-1&w) (4)\nWhen applied to a token, f performs two additions and three conjunctions.", 
        "116": "However, by applying the distributive property, we can refactor it as follows to reduce the number of operations:\nf\u2032 = (1 + (1 + w-2)&w-1)&w (5)\nThe refactored version f\u2032 \u2013 equivalent to the original one \u2013 only performs two additions and two conjunctions, offering a computational saving of one operation.", 
        "117": "This refactoring is done at the level of feature templates (i.e., feature extractors); the actual savings are realized when the feature vectors are computed by applying this feature function to an input.", 
        "118": "Thus, the simplification, though seemingly modest at the template level, can lead to a substantial speed improvements when the features vectors are actually manifested from data.", 
        "119": "The GDL algorithm instantiated with the feature extractor semiring, automates such factorization at a symbolic level.", 
        "120": "In the rest of this section, first (\u00a75.1), we will write our problem as a marginalization problem, as in Equation (3).", 
        "121": "Then (\u00a75.2), we will construct a junction tree to apply the message passing algorithm.", 
        "122": "5.1 Canonicalizing Feature Extractors  To frame feature simplification as marginalization, we need to first write any feature extractor as a canonical sum of products that is amenable for factorization (i.e., as in (3)).", 
        "123": "To do so, in this section, we will define: (a) the variables involved, (b) the local domains (i.e., subsets of variables contributing to each product term), and, (c) a local function for each local domain (i.e., the \u03b1i\u2019s).", 
        "124": "Variables.", 
        "125": "First, we write a feature extractor as a sum of products.", 
        "126": "Our running example (4) is already one.", 
        "127": "If we had an expression like f1&(f2 + f3), we can expand it into f1&f2 + f1&f3.", 
        "128": "From the sum of products, we identify the base feature extractors (i.e., ones not composed of other feature extractors) and define a variable xi for each.", 
        "129": "In our example, we have w, w-1 and w-2.", 
        "130": "Next, recall from \u00a74 that each variable xi can take values from a finite set Ai.", 
        "131": "If a base feature extractor fi corresponds to the variable xi, then, we define xi\u2019s domain to be the set Ai = {1, fi}.", 
        "132": "That is, each variable can either be the bias feature extractor or the feature extractor associated with it.", 
        "133": "Our example gives three variables x1, x2, x3 with domains A1 = {1, w}, A2 = {1, w-1}, A3 = {1, w-2} respectively.", 
        "134": "Local domains.", 
        "135": "Local domains are subsets of the variables defined above.", 
        "136": "They are the domains of functions that constitute products in the canonical form of a feature extractor.", 
        "137": "We define the following local domains, each illustrated with the corresponding instantiation in our running example:\n1.", 
        "138": "A singleton set for each variable: {x1}, {x2}, and {x3}.", 
        "139": "2.", 
        "140": "One local domain consisting of all the variables: The set {x1, x2, x3}.", 
        "141": "3.", 
        "142": "One local domain consisting of no variables: The empty set {}.", 
        "143": "4.", 
        "144": "One local domain for each subset of base feature extractors that participate in at least two conjunctions in the sum-of-products (i. e., the ones that can be factored away): Only {x1, x2} in our example, because only w and w-1 participate in two conjunctions in (4).", 
        "145": "Local functions.", 
        "146": "Each local domain is associated with a function that maps variable assignments to feature extractors.", 
        "147": "These functions (called local kernels by Aji and McEliece (2000)) are like potential functions in a factor graph.", 
        "148": "We define two kinds of local functions, driven by the goal of de-\nsigning a marginalization problem that pushes towards simpler feature functions.", 
        "149": "1.", 
        "150": "We associate the identity function with all singleton local domains, and the constant function that returns the bias 1 with the empty domain {}.", 
        "151": "2.", 
        "152": "With all other local domains, we associate an indicator function, denoted by z.", 
        "153": "For a local domain, z is an indicator for those assignments of the variables involved, whose conjunctions are present in any product term in sum-of-products.", 
        "154": "In our running example, the function z(x1, x2) is the indicator for (x1, x2) belonging to the set {(w, 1) , (w, w-1)}, represented by the table:\nx1 x2 z(x1, x2) 1 1 0 1 w-1 0 w 1 1 w w-1 1\nThe indicator returns the semiring\u2019s multiplicative and additive identities.", 
        "155": "The value of z above for inputs (w,1) is 1 because the first term in (4) that defines the feature extractor contains w, but not w-1.", 
        "156": "On the other hand, the input (1,1) is mapped to 0 because every product term contains either w or w-1.", 
        "157": "For the local domain {x1, x2, x3}, the local function is the indicator for the set {(w, 1, 1), (w, w-1,1), (w, w-1, w-2)}, corresponding to each product term.", 
        "158": "In summary, for the running example we have: Local domain Local function {x1} x1 {x2} x2 {x3} x3 {x1, x2, x3} z(x1, x2, x3) {} 1 {x1, x2} z(x1, x2)\nThe procedure described here aims to convert any feature function into a canonical form that can be factorized using the GDL algorithm.", 
        "159": "Indeed, using local domains and functions specified above, any feature extractor can we written as a canonical sum of products as in (3).", 
        "160": "For example, using the table above, our running example is identical to\n\u2211\nx1,x2,x3\nz(x1, x2, x3)&z(x1, x2)&x1&x2&x3 (6)\nHere, the summation is over the cross product of theAi\u2019s.", 
        "161": "The choice of the z functions ensures that only those conjunctions that were in the original feature extractor remain.", 
        "162": "This section shows one approach for canonicalization; the local domains and functions are a de-\nsign choice that may be optimized in future work.", 
        "163": "We should also point out that, while this process is notationally tedious, its actual computational cost is negligible, especially given that it is to be performed only once at the template level.", 
        "164": "5.2 Simplifying feature extractors  As mentioned in \u00a74, a commutative semiring can allow us to employ the GDL algorithm to efficiently compute a sum of products.", 
        "165": "Starting from a canonical sum-of-products expression such as the one in (6), this process is similar to variable elimination for Bayesian networks.", 
        "166": "The junction tree algorithm is a general scheme to avoid redundant computation in such networks (Cowell, 2006).", 
        "167": "To formalize this, we will first build a junction tree and then define the messages sent from the leaves to the root.", 
        "168": "The final message at the root will give us the simplified feature function.", 
        "169": "Constructing a Junction Tree.", 
        "170": "First, we will construct a junction tree using the local domains from \u00a7 5.1.", 
        "171": "In any junction tree, the edges should satisfy the running intersection property: i.e., if a variable xi is in two nodes in the tree, then it should be in every node in the path connecting them.", 
        "172": "To build a junction tree, we will first create a graph whose nodes are the local domains.", 
        "173": "The edges of this graph connect pairs of nodes if the variables in one are a subset of the other.", 
        "174": "For simplicity, we will assume that our nodes are arranged in a lattice as shown in Figure 1, with edges connecting nodes in subsequent levels.", 
        "175": "For example, there is no edge connecting nodes B and C.\nEvery spanning tree of this lattice is a junction tree.", 
        "176": "Which one should we consider?", 
        "177": "Let us examine the properties that we need.", 
        "178": "First, the root of the tree should correspond to the empty local domain {} because messages arriving at this node will accumulate all products.", 
        "179": "Second, as we will see, feature extractors farther from the root will appear in inner terms in the factorized form.", 
        "180": "That is, frequent or more expensive feature extractors should be incentivized to appear higher in the tree.", 
        "181": "To capture these preferences, we frame the task of constructing the junction tree as a maximum spanning tree problem over the graph, with edge weights incorporating the preferences.", 
        "182": "One natural weighting function is the computational expense of the base feature extractors associated with that edge.", 
        "183": "For example, the weight associated with the edge connecting nodes E and D in the fig-\nure can be the average cost of the w and w-1 feature extractors.", 
        "184": "If computational costs are unavailable, we can use the number times a feature extractor appears in the expression to be simplified.", 
        "185": "Under this criterion, in our example, edges connecting E to its neighbors will be weighted highest.", 
        "186": "Once we have a spanning tree, we make the edges directed so that the empty set is the root.", 
        "187": "Figure 1 shows the junction tree obtained for our running example.", 
        "188": "Message Passing for Feature Simplification.", 
        "189": "Given the junction tree, we can use a standard message passing scheme for factorization.", 
        "190": "The goal is to collect information at each node in the tree from its children all the way to the root.", 
        "191": "Suppose vi, vj denote two nodes in the tree.", 
        "192": "Since nodes are associated with sets of variables, their intersections vi \u2229 vj and differences vi \\ vj are defined.", 
        "193": "For example, in the example, A \u2229 B = {x3} and B \\ D = {x3}.", 
        "194": "We will denote children of a node vi in the junction tree by C(vi).", 
        "195": "The message from any node vi to its parent vj is a function that maps the variables vi \u2229 vj to a feature extractor by marginalizing out all variables that are in vi but not in vj .", 
        "196": "Formally, we define the message \u00b5ij from a node vi to a node vj as:\n\u00b5ij (vi \u2229 vj) = \u2211\nvj\\vi\n\u03b1i (vi) \u220f\nvk\u2208C(vi) \u00b5ki (vk \u2229 vi) .", 
        "197": "(7)\nHere, \u03b1i is the local function at node vi.", 
        "198": "To complete the formal definition of the algorithm, we note that by performing post-order traversal of the junction tree, we will accumulate all messages at the root of the tree, that corresponds to the empty set of variables.", 
        "199": "The incoming message at this node represents the factorized feature extractor.", 
        "200": "Algorithm 1 briefly summarizes the entire simplification process.", 
        "201": "The proof of correctness of the algorithm follows from the fact that the range of all the local functions is a commutative semiring, namely the feature extractor semiring.", 
        "202": "We refer the reader to (Aji and McEliece, 2000, Appendix A) for details.", 
        "203": "Algorithm 1 The Generalized Distributive Law Algorithm for simplifying a feature extractor f. See the text for details.", 
        "204": "1: Convert f into a canonical sum of products representa-\ntion (\u00a7 5.1).", 
        "205": "2: Construct a junction tree whose nodes are local domains.", 
        "206": "3: for edge (vj , vi) in the post-order traversal of the tree do 4: Receive a message \u00b5ij at vj using (7).", 
        "207": "5: end for 6: return the incoming message at the root\nExample run of message propagation.", 
        "208": "As an illustration, let us apply it to our running example.", 
        "209": "1.", 
        "210": "The first message is from A to B.", 
        "211": "Since A has no children and its local function is the identity function, we have \u00b5AB(x) = x.", 
        "212": "Similarly, we have \u00b5CD(x) = x.", 
        "213": "2.", 
        "214": "The message from B to D has to marginalize out the variable x3.", 
        "215": "That is, we have \u00b5BD(x1, x2) =\n\u2211 x3 z(x1, x2, x3)\u00b5AB(x3).", 
        "216": "The summation is over the domain of x3, namely {1, w-2}.", 
        "217": "By substituting for z and \u00b5AB , and simplifying, we get the message:\nx1 x2 \u00b5BD(x1, x2) 1 1 0 1 w-1 0 w 1 1 w w-1 1 + w-2\n3.", 
        "218": "The message from D to E marginalizes out the variable x2 to give us \u00b5DE(x1) =\u2211 x2 z(x1, x2)\u00b5CD(x2)\u00b5BD(x1, x2).", 
        "219": "Here, the\nsummation is over the domain of x2, namely {1, w-1}.", 
        "220": "We can simplify the message as:\nx1 \u00b5DE(x1) 1 0 w 1 + (1 + w-2)&w-1\n4.", 
        "221": "Finally, the message from E to the root F marginalizes out the variable x1 by summing over its domain {1, w} to give us the message (1 + (1 + w-2)&w-1)&w. The message received at the root is the factorized feature extractor.", 
        "222": "Note that the final form is identical to (5) at the beginning of \u00a75.", 
        "223": "Discussion.", 
        "224": "An optimal refactoring algorithm would produce a feature extractor that is both correct and fastest.", 
        "225": "The algorithm above has the former guarantee.", 
        "226": "While it does reduce the number of operations performed, the closeness of the refac-\ntored feature function to the fastest one depends on the heuristic used to weight edges for identifying the junction tree.", 
        "227": "Changing the heuristic can change the junction tree, thus changing the final factorized function.", 
        "228": "We found via experiments that using the number of times a feature extractor occurs in the sum-of-products to weight edges is promising.", 
        "229": "A formal study of optimality of factorization is an avenue of future research.", 
        "230": "6 Experiments  We show the practical usefulness of feature function refactoring using text chunking and relation extraction.", 
        "231": "In both cases, the question we seek to evaluate empirically is: Does the feature function refactoring algorithm improve feature extraction time?", 
        "232": "We should point out that our goal is not to measure accuracy of prediction, but the efficiency of feature extraction.", 
        "233": "Indeed, we are guaranteed that refactoring will not change accuracy; factorized feature extractors produce the same feature vectors as the original ones.", 
        "234": "In all experiments, we compare a feature extractor and its refactored variant.", 
        "235": "For the factorization, we incentivized the junction tree to factor out base feature extractors that occurred most frequently in the feature extractor.", 
        "236": "For both tasks, we use existing feature representations that we briefly describe.", 
        "237": "We refer the reader to the original work that developed the feature representations for further details.", 
        "238": "For both the original and the factorized feature extractors, we report (a) the number of additions and conjunctions at the template level, and, (b) the time for feature extraction on the entire dataset.", 
        "239": "For the time measurements, we report average times for the original and factorized feature extractors over five paired runs to average out variations in system load.1  6.1 Text Chunking  We use data from the CoNLL 2000 shared task (Tjong Kim Sang and Buchholz, 2000) of text chunking and the feature set described by Martins et al.", 
        "240": "(2011), consisting of the following templates extracted at each word: (1) Up to 3-grams of POS tags within a window of size ten centered at the word, (2) up to 3-grams of words, within a window of size six centered at the word, and (3) up to 2-grams of word shapes, within a window of size\n1We performed all our experiments on a server with 128GB RAM and 24 CPU cores, each clocking at 2600 MHz.", 
        "241": "four centered at the word.", 
        "242": "In all, there are 96 feature templates.", 
        "243": "We factorized the feature representation using Algorithm 1.", 
        "244": "Table 1 reports the number of operations (addition and conjunction) in the templates in the original and factorized versions of the feature extractor.", 
        "245": "The table also reports feature extraction time taken from the entire training set of 8,936 sentences, corresponding to 211,727 tokens.", 
        "246": "First, we see that the factorization reduces the number of feature conjunction operations.", 
        "247": "Thus, to produce exactly the same feature vector, the factorized feature extractor does less work.", 
        "248": "The time results show that this computational gain is not merely a theoretical one; it also manifests itself practically.", 
        "249": "6.2 Relation Extraction  Our second experiment is based on the task of relation extraction using the English section of the ACE 2005 corpus (Walker et al., 2006).", 
        "250": "The goal is to identify semantic relations between two entity mentions in text.", 
        "251": "We use the feature representation developed by Zhou et al.", 
        "252": "(2005) as part of an investigation of how various lexical, syntactic and semantic sources of information affect the relation extraction task.", 
        "253": "To this end, the feature set consists of word level information about mentions, their entity types, their relationships with chunks, path features from parse trees, and semantic features based on WordNet and various word lists.", 
        "254": "Given the complexity of the features, we do not describe them here and refer the reader to the original work for details.", 
        "255": "Note that compared to the chunking features, these features are more diverse in their computational costs.", 
        "256": "We report the results of our experiments in Ta-\nble 2.", 
        "257": "As before, we see that the number of conjunction operations decreases after factorization.", 
        "258": "Curiously, however, despite the complexity of the feature set, the actual number of operations is smaller than text chunking.", 
        "259": "Due to this, we see a more modest, yet significant decrease in the time for feature extraction after factorization.", 
        "260": "7 Related Work and Discussion  Simplifying Expressions.", 
        "261": "The problem of simplifying expressions with an eye on computational efficiency is the focus of logic synthesis (cf.", 
        "262": "Hachtel and Somenzi, 2006), albeit largely geared towards analyzing and verifying digital circuits.", 
        "263": "Logic synthesis is NP-hard in general.", 
        "264": "In our case, the hardness is hidden in the fact that our approach does not guarantee that we will find the smallest (or most efficient) factorization.", 
        "265": "The junction tree construction determines the factorization quality.", 
        "266": "Semirings in NLP.", 
        "267": "Semirings abound in NLP, though primarily as devices to design efficient inference algorithms for various graphical models (e.g.", 
        "268": "Wainwright and Jordan, 2008; Sutton et al., 2012).", 
        "269": "Goodman (1999) synthesized various parsing algorithms in terms of semiring operations.", 
        "270": "Since then, we have seen several explorations of the interplay between weighted dynamic programs and semirings for inference in tasks such as parsing and machine translation (e. g. Eisner et al., 2005; Li and Eisner, 2009; Lopez, 2009; Gimpel and Smith, 2009).", 
        "271": "Allauzen et al.", 
        "272": "(2003) developed efficient algorithms for constructing statistical language models by exploiting the algebraic structure of the probability semiring.", 
        "273": "Feature Extraction and Modeling Languages.", 
        "274": "Much work around features in NLP is aimed at improving classifier accuracy.", 
        "275": "There is some work on developing languages to better construct feature spaces (Cumby and Roth, 2002; Broda et al., 2013; Sammons et al., 2016), but they do not formalize feature extraction from an algebraic perspective.", 
        "276": "We expect that the algorithm proposed in this paper can be integrated into such feature construction languages, and also into libraries geared towards designing feature rich models (e.g.", 
        "277": "McCallum et al., 2009; Chang et al., 2015).", 
        "278": "Representation vs.", 
        "279": "Speed.", 
        "280": "As the recent successes (Goodfellow et al., 2016) of distributed representations show, the representational capacity of a feature space is of primary importance.", 
        "281": "Indeed, several recent lines of work that use distributed\nrepresentations have independently identified the connection between conjunctions (of features or factors in a factor graph) and tensor products (Lei et al., 2014; Srikumar and Manning, 2014; Gormley et al., 2015; Yu et al., 2015; Lei et al., 2015; Primadhanty et al., 2015).", 
        "282": "They typically impose sparsity or low-rank requirements to induce better representations for learning.", 
        "283": "In this paper, we use the connection between tensor products and conjunctions to prove algebraic properties of feature extractors, leading to speed improvements via factorization.", 
        "284": "In this context, we note that in both our experiments, the number of conjunctions are reduced by factorization.", 
        "285": "We argue that this is an important saving because conjunctions can be a more expensive operation.", 
        "286": "This is especially true when dealing with dense feature representations, as is increasingly common with word vectors and neural networks, because conjunctions of dense feature vectors are tensor products, which can be slow.", 
        "287": "Finally, while training classifiers can be time consuming, when trained classifiers are deployed, feature extraction will dominate computation time over the classifier\u2019s lifetime.", 
        "288": "However, the prediction step includes both feature extraction and computing inner products between features and weights.", 
        "289": "Many features may be associated with zero weights because of sparsity-inducing learning (e.g.", 
        "290": "Andrew and Gao, 2007; Martins et al., 2011; Strubell et al., 2015).", 
        "291": "Since these two aspects are orthogonal to each other, the factorization algorithm presented in this paper can be used to speed up extraction of those features that have non-zero weights.", 
        "292": "8 Conclusion  In this paper, we studied the process of feature extraction using an algebraic lens.", 
        "293": "We showed that the set of feature extractors form a commutative semiring over addition and conjunction.", 
        "294": "We exploited this characterization to develop a factorization algorithm that simplifies feature extractors to be more computationally efficient.", 
        "295": "We demonstrated the practical value of the refactoring algorithm by speeding up feature extraction for text chunking and relation extraction tasks.", 
        "296": "Acknowledgments  The author thanks the anonymous reviewers for their insightful comments and feedback."
    }, 
    "document_id": "P17-1173.pdf.json"
}
